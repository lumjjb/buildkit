From cc3909b72412053713a8001d2cde639fc75874a9 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 19 Jul 2018 12:31:59 -0400
Subject: [PATCH 01/79] Add ctr images encrypt command and take a new name
 parameter for the enc. image

---
 api/next.pb.txt                     |   9 ++-
 api/services/images/v1/images.pb.go | 146 +++++++++++++++++++++++-------------
 api/services/images/v1/images.proto |   3 +-
 cmd/ctr/commands/images/encrypt.go  |  84 +++++++++++++++++++++
 cmd/ctr/commands/images/images.go   |   1 +
 cmd/ctr/commands/images/push.go     |   2 +-
 image_store.go                      |   7 +-
 images/image.go                     |   3 +-
 metadata/images.go                  |   7 +-
 services/images/local.go            |   2 +-
 10 files changed, 200 insertions(+), 64 deletions(-)
 create mode 100644 cmd/ctr/commands/images/encrypt.go

diff --git a/api/next.pb.txt b/api/next.pb.txt
index e0862f2..78429f4 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2245,9 +2245,16 @@ file {
       json_name: "name"
     }
     field {
-      name: "ec"
+      name: "newName"
       number: 2
       label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "newName"
+    }
+    field {
+      name: "ec"
+      number: 3
+      label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
       type_name: ".containerd.services.images.v1.EncryptConfig"
       json_name: "ec"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index db2094a..2045d9b 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -185,8 +185,9 @@ func (*EncryptConfig) ProtoMessage()               {}
 func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
 
 type EncryptImageRequest struct {
-	Name string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	Ec   *EncryptConfig `protobuf:"bytes,2,opt,name=ec" json:"ec,omitempty"`
+	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Ec      *EncryptConfig `protobuf:"bytes,3,opt,name=ec" json:"ec,omitempty"`
 }
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
@@ -860,9 +861,15 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Name)))
 		i += copy(dAtA[i:], m.Name)
 	}
-	if m.Ec != nil {
+	if len(m.NewName) > 0 {
 		dAtA[i] = 0x12
 		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.NewName)))
+		i += copy(dAtA[i:], m.NewName)
+	}
+	if m.Ec != nil {
+		dAtA[i] = 0x1a
+		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.Ec.Size()))
 		n10, err := m.Ec.MarshalTo(dAtA[i:])
 		if err != nil {
@@ -1048,6 +1055,10 @@ func (m *EncryptImageRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
+	l = len(m.NewName)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
 	if m.Ec != nil {
 		l = m.Ec.Size()
 		n += 1 + l + sovImages(uint64(l))
@@ -1209,6 +1220,7 @@ func (this *EncryptImageRequest) String() string {
 	}
 	s := strings.Join([]string{`&EncryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
+		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
 		`Ec:` + strings.Replace(fmt.Sprintf("%v", this.Ec), "EncryptConfig", "EncryptConfig", 1) + `,`,
 		`}`,
 	}, "")
@@ -2463,6 +2475,35 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 2:
 			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.NewName = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Ec", wireType)
 			}
 			var msglen int
@@ -2705,53 +2746,54 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 758 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0xd3, 0x4e,
-	0x10, 0x8d, 0xf3, 0xaf, 0xed, 0xa4, 0xd5, 0xaf, 0xbf, 0x6d, 0x85, 0x22, 0x03, 0x69, 0x64, 0x15,
-	0x29, 0x07, 0xb0, 0x69, 0x7a, 0x81, 0xb6, 0x42, 0x34, 0x6d, 0x29, 0x48, 0x85, 0x83, 0xa1, 0x10,
-	0x71, 0xa9, 0x1c, 0x67, 0x62, 0xac, 0x24, 0xb6, 0xf1, 0x6e, 0x82, 0x72, 0xe3, 0x0b, 0x20, 0x21,
-	0xf1, 0xa5, 0x7a, 0xe4, 0xc8, 0x09, 0x68, 0x0e, 0x7c, 0x0e, 0xe4, 0xdd, 0x0d, 0xcd, 0x3f, 0xe1,
-	0xa4, 0xf4, 0x36, 0xb6, 0xdf, 0x7b, 0x33, 0xf3, 0x66, 0x77, 0x12, 0x38, 0x74, 0x5c, 0xf6, 0xae,
-	0x53, 0xd3, 0x6d, 0xbf, 0x6d, 0xd8, 0xbe, 0xc7, 0x2c, 0xd7, 0xc3, 0xb0, 0x3e, 0x1c, 0x5a, 0x81,
-	0x6b, 0x50, 0x0c, 0xbb, 0xae, 0x8d, 0xd4, 0x70, 0xdb, 0x96, 0x83, 0xd4, 0xe8, 0x6e, 0xc9, 0x48,
-	0x0f, 0x42, 0x9f, 0xf9, 0xe4, 0xf6, 0x25, 0x5e, 0x1f, 0x60, 0x75, 0x89, 0xe8, 0x6e, 0xa9, 0xeb,
-	0x8e, 0xef, 0xf8, 0x1c, 0x69, 0x44, 0x91, 0x20, 0xa9, 0x37, 0x1d, 0xdf, 0x77, 0x5a, 0x68, 0xf0,
-	0xa7, 0x5a, 0xa7, 0x61, 0x60, 0x3b, 0x60, 0x3d, 0xf9, 0xb1, 0x38, 0xfe, 0xb1, 0xe1, 0x62, 0xab,
-	0x7e, 0xd6, 0xb6, 0x68, 0x53, 0x22, 0x36, 0xc6, 0x11, 0xcc, 0x6d, 0x23, 0x65, 0x56, 0x3b, 0x90,
-	0x80, 0xdd, 0x99, 0x5a, 0x63, 0xbd, 0x00, 0xa9, 0x51, 0x47, 0x6a, 0x87, 0x6e, 0xc0, 0xfc, 0x50,
-	0x90, 0xb5, 0x5f, 0x49, 0xc8, 0x3c, 0x8b, 0x1a, 0x20, 0x04, 0xd2, 0x9e, 0xd5, 0xc6, 0xbc, 0x52,
-	0x54, 0x4a, 0x4b, 0x26, 0x8f, 0xc9, 0x53, 0xc8, 0xb6, 0xac, 0x1a, 0xb6, 0x68, 0x3e, 0x59, 0x4c,
-	0x95, 0x72, 0xe5, 0xfb, 0xfa, 0x5f, 0x0d, 0xd0, 0xb9, 0x92, 0x7e, 0xc2, 0x29, 0x47, 0x1e, 0x0b,
-	0x7b, 0xa6, 0xe4, 0x93, 0x1d, 0xc8, 0x32, 0x2b, 0x74, 0x90, 0xe5, 0x53, 0x45, 0xa5, 0x94, 0x2b,
-	0xdf, 0x1a, 0x56, 0xe2, 0xb5, 0xe9, 0x87, 0x7f, 0x6a, 0xab, 0xa4, 0xcf, 0xbf, 0x6f, 0x24, 0x4c,
-	0xc9, 0x20, 0x07, 0x00, 0x76, 0x88, 0x16, 0xc3, 0xfa, 0x99, 0xc5, 0xf2, 0x0b, 0x9c, 0xaf, 0xea,
-	0xc2, 0x16, 0x7d, 0x60, 0x8b, 0xfe, 0x6a, 0x60, 0x4b, 0x65, 0x31, 0x62, 0x7f, 0xfe, 0xb1, 0xa1,
-	0x98, 0x4b, 0x92, 0xb7, 0xcf, 0x45, 0x3a, 0x41, 0x7d, 0x20, 0xb2, 0x38, 0x8f, 0x88, 0xe4, 0xed,
-	0x33, 0xf5, 0x21, 0xe4, 0x86, 0x9a, 0x23, 0xab, 0x90, 0x6a, 0x62, 0x4f, 0x3a, 0x16, 0x85, 0x64,
-	0x1d, 0x32, 0x5d, 0xab, 0xd5, 0xc1, 0x7c, 0x92, 0xbf, 0x13, 0x0f, 0x3b, 0xc9, 0x07, 0x8a, 0x76,
-	0x07, 0xfe, 0x3b, 0x46, 0xc6, 0x0d, 0x32, 0xf1, 0x7d, 0x07, 0x29, 0x9b, 0xe6, 0xb8, 0xf6, 0x02,
-	0x56, 0x2f, 0x61, 0x34, 0xf0, 0x3d, 0x8a, 0x64, 0x07, 0x32, 0xdc, 0x62, 0x0e, 0xcc, 0x95, 0x37,
-	0x67, 0x19, 0x82, 0x29, 0x28, 0xda, 0x6b, 0x20, 0x07, 0xdc, 0x83, 0x91, 0xcc, 0x8f, 0xaf, 0xa0,
-	0x28, 0x87, 0x22, 0x75, 0xdf, 0xc0, 0xda, 0x88, 0xae, 0x2c, 0xf5, 0xdf, 0x85, 0xbf, 0x28, 0x40,
-	0x4e, 0xb9, 0xe1, 0xd7, 0x5b, 0x31, 0xd9, 0x85, 0x9c, 0x18, 0x24, 0xbf, 0x5c, 0x7c, 0x40, 0xd3,
-	0x4e, 0xc0, 0x93, 0xe8, 0xfe, 0x3d, 0xb7, 0x68, 0xd3, 0x94, 0xe7, 0x25, 0x8a, 0xa3, 0x76, 0x47,
-	0x8a, 0xba, 0xb6, 0x76, 0xef, 0xc1, 0xff, 0x27, 0x2e, 0x15, 0x03, 0xa7, 0x83, 0x66, 0xf3, 0xb0,
-	0xd0, 0x70, 0x5b, 0x0c, 0x43, 0x9a, 0x57, 0x8a, 0xa9, 0xd2, 0x92, 0x39, 0x78, 0xd4, 0xaa, 0x40,
-	0x86, 0xe1, 0xb2, 0x8c, 0x0a, 0x64, 0x45, 0x12, 0x0e, 0x9f, 0xaf, 0x0e, 0xc9, 0xd4, 0xf6, 0x80,
-	0x1c, 0x62, 0x0b, 0xc7, 0x6c, 0x9f, 0xb6, 0x14, 0x08, 0xa4, 0x69, 0xcf, 0xb3, 0xb9, 0x83, 0x8b,
-	0x26, 0x8f, 0xb5, 0x53, 0x58, 0x39, 0xf2, 0xec, 0xb0, 0x17, 0xb0, 0x03, 0xdf, 0x6b, 0xb8, 0x0e,
-	0x29, 0x00, 0x84, 0x68, 0xbb, 0x81, 0x8b, 0x1e, 0x1b, 0x74, 0x31, 0xf4, 0x86, 0x6c, 0xc2, 0x8a,
-	0x13, 0x38, 0x41, 0xa7, 0xd6, 0xc4, 0x5e, 0xe8, 0x7a, 0x0e, 0x57, 0x5b, 0x36, 0x47, 0x5f, 0x6a,
-	0x0e, 0xac, 0x49, 0xd9, 0xd8, 0xaa, 0xf6, 0x20, 0x89, 0xb6, 0x9c, 0xea, 0xdd, 0x98, 0xfe, 0x47,
-	0x4a, 0x35, 0x93, 0x68, 0x6b, 0x55, 0x58, 0x1f, 0x4d, 0x74, 0x5d, 0x03, 0x2e, 0x7f, 0xca, 0x40,
-	0x56, 0x8c, 0x8b, 0x34, 0x20, 0x75, 0x8c, 0x8c, 0xe8, 0x31, 0x22, 0x63, 0x6b, 0x42, 0x35, 0x66,
-	0xc6, 0xcb, 0xa2, 0x9b, 0x90, 0x8e, 0x0e, 0x09, 0x89, 0xdb, 0xd6, 0x13, 0x07, 0x4f, 0xdd, 0x9a,
-	0x83, 0x21, 0x93, 0xf9, 0x90, 0x15, 0x8b, 0x80, 0xc4, 0x91, 0x27, 0xf7, 0x90, 0x5a, 0x9e, 0x87,
-	0x72, 0x99, 0x50, 0x5c, 0xc5, 0xd8, 0x84, 0x93, 0x6b, 0x24, 0x36, 0xe1, 0xb4, 0x4b, 0xfe, 0x12,
-	0xb2, 0xe2, 0x66, 0xc4, 0x26, 0x9c, 0xbc, 0x40, 0xea, 0x8d, 0x89, 0x05, 0x73, 0x14, 0xfd, 0xfa,
-	0x93, 0x0f, 0xb0, 0x3c, 0x7c, 0xe0, 0x48, 0x79, 0xb6, 0x23, 0x3b, 0xa2, 0xbd, 0x3d, 0x17, 0x47,
-	0x74, 0x53, 0xa9, 0x9e, 0x5f, 0x14, 0x12, 0xdf, 0x2e, 0x0a, 0x89, 0x8f, 0xfd, 0x82, 0x72, 0xde,
-	0x2f, 0x28, 0x5f, 0xfb, 0x05, 0xe5, 0x67, 0xbf, 0xa0, 0xbc, 0x7d, 0x74, 0xc5, 0xbf, 0x48, 0xbb,
-	0x22, 0xaa, 0x26, 0x6a, 0x59, 0xde, 0xe4, 0xf6, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xb5,
-	0xb3, 0x36, 0x6d, 0x09, 0x00, 0x00,
+	// 774 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0xd3, 0x58,
+	0x10, 0x8f, 0xf3, 0xaf, 0xed, 0xa4, 0xd5, 0x76, 0x5f, 0xab, 0x95, 0xe5, 0xdd, 0x4d, 0x23, 0xab,
+	0x2b, 0xe5, 0xb0, 0xd8, 0x34, 0xbd, 0x40, 0x5b, 0x21, 0x9a, 0xb6, 0x14, 0xa4, 0xd2, 0x83, 0xa1,
+	0x10, 0x71, 0xa9, 0x1c, 0x67, 0x62, 0xac, 0x24, 0xb6, 0xf1, 0x7b, 0x49, 0x95, 0x1b, 0x7c, 0x00,
+	0x24, 0x24, 0xbe, 0x54, 0x8f, 0x1c, 0x39, 0x01, 0xcd, 0x81, 0xcf, 0x81, 0xfc, 0xfc, 0x4c, 0xf3,
+	0x4f, 0x38, 0x29, 0xbd, 0xcd, 0x7b, 0x9e, 0xdf, 0x6f, 0x66, 0x7e, 0xf3, 0x66, 0x64, 0x38, 0xb4,
+	0x1d, 0xf6, 0xba, 0x5b, 0xd7, 0x2c, 0xaf, 0xa3, 0x5b, 0x9e, 0xcb, 0x4c, 0xc7, 0xc5, 0xa0, 0x31,
+	0x6c, 0x9a, 0xbe, 0xa3, 0x53, 0x0c, 0x7a, 0x8e, 0x85, 0x54, 0x77, 0x3a, 0xa6, 0x8d, 0x54, 0xef,
+	0x6d, 0x09, 0x4b, 0xf3, 0x03, 0x8f, 0x79, 0xe4, 0xdf, 0x6b, 0x7f, 0x2d, 0xf6, 0xd5, 0x84, 0x47,
+	0x6f, 0x4b, 0x59, 0xb7, 0x3d, 0xdb, 0xe3, 0x9e, 0x7a, 0x68, 0x45, 0x20, 0xe5, 0x6f, 0xdb, 0xf3,
+	0xec, 0x36, 0xea, 0xfc, 0x54, 0xef, 0x36, 0x75, 0xec, 0xf8, 0xac, 0x2f, 0x3e, 0x96, 0xc6, 0x3f,
+	0x36, 0x1d, 0x6c, 0x37, 0xce, 0x3b, 0x26, 0x6d, 0x09, 0x8f, 0x8d, 0x71, 0x0f, 0xe6, 0x74, 0x90,
+	0x32, 0xb3, 0xe3, 0x0b, 0x87, 0xdd, 0x99, 0x4a, 0x63, 0x7d, 0x1f, 0xa9, 0xde, 0x40, 0x6a, 0x05,
+	0x8e, 0xcf, 0xbc, 0x20, 0x02, 0xab, 0xdf, 0xd3, 0x90, 0x7b, 0x12, 0x16, 0x40, 0x08, 0x64, 0x5d,
+	0xb3, 0x83, 0xb2, 0x54, 0x92, 0xca, 0x4b, 0x06, 0xb7, 0xc9, 0x63, 0xc8, 0xb7, 0xcd, 0x3a, 0xb6,
+	0xa9, 0x9c, 0x2e, 0x65, 0xca, 0x85, 0xca, 0x5d, 0xed, 0x97, 0x02, 0x68, 0x9c, 0x49, 0x3b, 0xe1,
+	0x90, 0x23, 0x97, 0x05, 0x7d, 0x43, 0xe0, 0xc9, 0x0e, 0xe4, 0x99, 0x19, 0xd8, 0xc8, 0xe4, 0x4c,
+	0x49, 0x2a, 0x17, 0x2a, 0xff, 0x0c, 0x33, 0xf1, 0xdc, 0xb4, 0xc3, 0x9f, 0xb9, 0x55, 0xb3, 0x97,
+	0x5f, 0x36, 0x52, 0x86, 0x40, 0x90, 0x03, 0x00, 0x2b, 0x40, 0x93, 0x61, 0xe3, 0xdc, 0x64, 0xf2,
+	0x02, 0xc7, 0x2b, 0x5a, 0x24, 0x8b, 0x16, 0xcb, 0xa2, 0x3d, 0x8f, 0x65, 0xa9, 0x2e, 0x86, 0xe8,
+	0x0f, 0x5f, 0x37, 0x24, 0x63, 0x49, 0xe0, 0xf6, 0x39, 0x49, 0xd7, 0x6f, 0xc4, 0x24, 0x8b, 0xf3,
+	0x90, 0x08, 0xdc, 0x3e, 0x53, 0xee, 0x43, 0x61, 0xa8, 0x38, 0xb2, 0x0a, 0x99, 0x16, 0xf6, 0x85,
+	0x62, 0xa1, 0x49, 0xd6, 0x21, 0xd7, 0x33, 0xdb, 0x5d, 0x94, 0xd3, 0xfc, 0x2e, 0x3a, 0xec, 0xa4,
+	0xef, 0x49, 0xea, 0x7f, 0xf0, 0xc7, 0x31, 0x32, 0x2e, 0x90, 0x81, 0x6f, 0xba, 0x48, 0xd9, 0x34,
+	0xc5, 0xd5, 0x53, 0x58, 0xbd, 0x76, 0xa3, 0xbe, 0xe7, 0x52, 0x24, 0x3b, 0x90, 0xe3, 0x12, 0x73,
+	0xc7, 0x42, 0x65, 0x73, 0x96, 0x26, 0x18, 0x11, 0x44, 0x7d, 0x01, 0xe4, 0x80, 0x6b, 0x30, 0x12,
+	0xf9, 0xe1, 0x0d, 0x18, 0x45, 0x53, 0x04, 0xef, 0x4b, 0x58, 0x1b, 0xe1, 0x15, 0xa9, 0xfe, 0x3e,
+	0xf1, 0x47, 0x09, 0xc8, 0x19, 0x17, 0xfc, 0x76, 0x33, 0x26, 0xbb, 0x50, 0x88, 0x1a, 0xc9, 0x87,
+	0x8b, 0x37, 0x68, 0xda, 0x0b, 0x78, 0x14, 0xce, 0xdf, 0x53, 0x93, 0xb6, 0x0c, 0xf1, 0x5e, 0x42,
+	0x3b, 0x2c, 0x77, 0x24, 0xa9, 0x5b, 0x2b, 0xf7, 0x0e, 0xfc, 0x79, 0xe2, 0xd0, 0xa8, 0xe1, 0x34,
+	0x2e, 0x56, 0x86, 0x85, 0xa6, 0xd3, 0x66, 0x18, 0x50, 0x59, 0x2a, 0x65, 0xca, 0x4b, 0x46, 0x7c,
+	0x54, 0x6b, 0x40, 0x86, 0xdd, 0x45, 0x1a, 0x55, 0xc8, 0x47, 0x41, 0xb8, 0xfb, 0x7c, 0x79, 0x08,
+	0xa4, 0xba, 0x07, 0xe4, 0x10, 0xdb, 0x38, 0x26, 0xfb, 0xb4, 0xa5, 0x40, 0x20, 0x4b, 0xfb, 0xae,
+	0xc5, 0x15, 0x5c, 0x34, 0xb8, 0xad, 0x9e, 0xc1, 0xca, 0x91, 0x6b, 0x05, 0x7d, 0x9f, 0x1d, 0x78,
+	0x6e, 0xd3, 0xb1, 0x49, 0x11, 0x20, 0x40, 0xcb, 0xf1, 0x1d, 0x74, 0x59, 0x5c, 0xc5, 0xd0, 0x0d,
+	0xd9, 0x84, 0x15, 0xdb, 0xb7, 0xfd, 0x6e, 0xbd, 0x85, 0xfd, 0xc0, 0x71, 0x6d, 0xce, 0xb6, 0x6c,
+	0x8c, 0x5e, 0xaa, 0xef, 0x24, 0x58, 0x13, 0xbc, 0x89, 0x69, 0xc9, 0xb0, 0xe0, 0xe2, 0xc5, 0x69,
+	0x78, 0x1d, 0x0d, 0x5f, 0x7c, 0x24, 0x7b, 0x90, 0x46, 0x4b, 0xec, 0x9d, 0xff, 0x13, 0xa4, 0x19,
+	0xa9, 0xc2, 0x48, 0xa3, 0xa5, 0xd6, 0x60, 0x7d, 0x34, 0x85, 0xdb, 0xea, 0x7d, 0xe5, 0x7d, 0x0e,
+	0xf2, 0x51, 0x27, 0x49, 0x13, 0x32, 0xc7, 0xc8, 0x88, 0x96, 0x40, 0x32, 0xb6, 0x41, 0x14, 0x7d,
+	0x66, 0x7f, 0x91, 0x74, 0x0b, 0xb2, 0xe1, 0xfb, 0x21, 0x49, 0x8b, 0x7c, 0xe2, 0x4d, 0x2a, 0x5b,
+	0x73, 0x20, 0x44, 0x30, 0x0f, 0xf2, 0xd1, 0x8e, 0x20, 0x49, 0xe0, 0xc9, 0x15, 0xa5, 0x54, 0xe6,
+	0x81, 0x5c, 0x07, 0x8c, 0xa6, 0x34, 0x31, 0xe0, 0xe4, 0x86, 0x49, 0x0c, 0x38, 0x6d, 0xfe, 0x9f,
+	0x41, 0x3e, 0x1a, 0x9a, 0xc4, 0x80, 0x93, 0xb3, 0xa5, 0xfc, 0x35, 0xb1, 0x7b, 0x8e, 0xc2, 0x1f,
+	0x03, 0x72, 0x01, 0xcb, 0xc3, 0x0f, 0x8e, 0x54, 0x66, 0x7b, 0xb2, 0x23, 0xdc, 0xdb, 0x73, 0x61,
+	0xa2, 0x6a, 0xaa, 0xb5, 0xcb, 0xab, 0x62, 0xea, 0xf3, 0x55, 0x31, 0xf5, 0x76, 0x50, 0x94, 0x2e,
+	0x07, 0x45, 0xe9, 0xd3, 0xa0, 0x28, 0x7d, 0x1b, 0x14, 0xa5, 0x57, 0x0f, 0x6e, 0xf8, 0xf7, 0xb4,
+	0x1b, 0x59, 0xb5, 0x54, 0x3d, 0xcf, 0x8b, 0xdc, 0xfe, 0x11, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x97,
+	0x31, 0xae, 0x88, 0x09, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index d3a62f0..721028c 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -133,8 +133,9 @@ message EncryptConfig {
 
 message EncryptImageRequest {
 	string name = 1;
+	string newName = 2;
 
-	EncryptConfig ec = 2;
+	EncryptConfig ec = 3;
 }
 
 message EncryptImageResponse {
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
new file mode 100644
index 0000000..1ad7d47
--- /dev/null
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -0,0 +1,84 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package images
+
+import (
+	"fmt"
+
+	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/containerd/containerd/images"
+	"github.com/pkg/errors"
+	"github.com/urfave/cli"
+)
+
+var encryptCommand = cli.Command{
+	Name:      "encrypt",
+	Usage:     "encrypt an image locally",
+	ArgsUsage: "[flags] <local> <new name>",
+	Description: `Encrypt and image.
+
+	XYZ
+`,
+	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
+		Name:  "recipient",
+		Usage: "Recipient of the image is the person who can decrypt it",
+	}),
+	Action: func(context *cli.Context) error {
+		var (
+			local = context.Args().First()
+			newName = context.Args().Get(1)
+		)
+		if local == "" {
+			return errors.New("please provide the name of an image to encrypt")
+		}
+		if newName == "" {
+			return errors.New("please provide a name for the encrypted image")
+		}
+		fmt.Printf("Encrypting %s to %s\n", local, newName)
+		client, ctx, cancel, err := commands.NewClient(context)
+		if err != nil {
+			return err
+		}
+		defer cancel()
+		img, err := client.ImageService().Get(ctx, local)
+		if err != nil {
+			return errors.Wrap(err, "unable to resolve image to manifest")
+		}
+
+		var ec *images.EncryptConfig
+		recipients := context.StringSlice("recipient")
+		if len(recipients) == 0 {
+			return errors.New("no recipients given -- nothing to do")			
+		}
+
+		gpgPubRingFile, err := images.ReadGPGPubRingFile()
+		if err != nil {
+			return err
+		}
+		ec = &images.EncryptConfig{
+			GPGPubRingFile: gpgPubRingFile,
+			Recipients:     recipients,
+		}
+		img, err = client.ImageService().EncryptImage(ctx, local, newName, ec)
+		if err != nil {
+			return err
+		}
+		fmt.Printf("local: %s,  img.Name: %s", local, img.Name)
+		return nil
+	},
+}
+
diff --git a/cmd/ctr/commands/images/images.go b/cmd/ctr/commands/images/images.go
index 29fc459..58f83b0 100644
--- a/cmd/ctr/commands/images/images.go
+++ b/cmd/ctr/commands/images/images.go
@@ -47,6 +47,7 @@ var Command = cli.Command{
 		pushCommand,
 		removeCommand,
 		setLabelsCommand,
+		encryptCommand,
 	},
 }
 
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index f45aa85..ff3925b 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -104,7 +104,7 @@ var pushCommand = cli.Command{
 				GPGPubRingFile: gpgPubRingFile,
 				Recipients:     recipients,
 			}
-			img, err := client.ImageService().EncryptImage(ctx, local, ec)
+			img, err := client.ImageService().EncryptImage(ctx, local, local, ec)
 			if err != nil {
 				return err
 			}
diff --git a/image_store.go b/image_store.go
index 58b13d0..b2162db 100644
--- a/image_store.go
+++ b/image_store.go
@@ -50,11 +50,12 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name string, ec *images.EncryptConfig) (images.Image, error) {
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, ec *images.EncryptConfig) (images.Image, error) {
 	fmt.Printf("image_store.go: EncryptImage() name=%s\n", name);
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
-		Name: name,
-		Ec: &imagesapi.EncryptConfig{
+		Name:    name,
+		NewName: newName,
+		Ec:      &imagesapi.EncryptConfig{
 			Recipients   : ec.Recipients,
 			Gpgpubkeyring: ec.GPGPubRingFile,
 		},
diff --git a/images/image.go b/images/image.go
index ede41e0..d738d26 100644
--- a/images/image.go
+++ b/images/image.go
@@ -88,7 +88,7 @@ type Store interface {
 
 	Delete(ctx context.Context, name string, opts ...DeleteOpt) error
 
-	EncryptImage(ctx context.Context, name string, ec *EncryptConfig) (Image, error)
+	EncryptImage(ctx context.Context, name, newName string, ec *EncryptConfig) (Image, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -119,7 +119,6 @@ func (image *Image) RootFS(ctx context.Context, provider content.Provider, platf
 func (image *Image) Size(ctx context.Context, provider content.Provider, platform platforms.MatchComparer) (int64, error) {
 	var size int64
 	return size, Walk(ctx, Handlers(HandlerFunc(func(ctx context.Context, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
-		fmt.Printf("images/image: Size()")
 		if desc.Size < 0 {
 			return nil, errors.Errorf("invalid size %v in %v (%v)", desc.Size, desc.Digest, desc.MediaType)
 		}
diff --git a/metadata/images.go b/metadata/images.go
index e1d27cc..2263bb6 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -77,7 +77,7 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 	return image, nil
 }
 
-func (s *imageStore) EncryptImage(ctx context.Context, name string, ec *images.EncryptConfig) (images.Image, error) {
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec *images.EncryptConfig) (images.Image, error) {
 	fmt.Printf("metadata/images.go: EncryptImage() name=%s\n", name)
 	var image images.Image
 
@@ -119,7 +119,9 @@ func (s *imageStore) EncryptImage(ctx context.Context, name string, ec *images.E
 	}
 
 	image.Target = newSpec
+	image.Name = newName
 	fmt.Printf("newSpec.Digest: %s\n", newSpec.Digest)
+	fmt.Printf("newName: %s\n", newName)
 	image.UpdatedAt = time.Now().UTC()
 
 	if err := update(ctx, s.db, func(tx *bolt.Tx) error {
@@ -142,8 +144,7 @@ func (s *imageStore) EncryptImage(ctx context.Context, name string, ec *images.E
 			return err
 		}
 
-		name = image.Name + ".enc"
-		ibkt, err := bkt.CreateBucket([]byte(name))
+		ibkt, err := bkt.CreateBucket([]byte(image.Name))
 		if err != nil {
 			if err != bolt.ErrBucketExists {
 				return err
diff --git a/services/images/local.go b/services/images/local.go
index af7b085..f5b1f1f 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -186,7 +186,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 
 	var resp       imagesapi.EncryptImageResponse
 
-	encrypted, err := l.store.EncryptImage(ctx, req.Name, &images.EncryptConfig{
+	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.EncryptConfig{
 		Recipients: req.Ec.Recipients,
 		GPGPubRingFile: req.Ec.Gpgpubkeyring,
 	})
-- 
2.7.4


From 254d7c0c1428962546818cd04c104ffe8f0b6624 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 19 Jul 2018 12:33:38 -0400
Subject: [PATCH 02/79] Add vendor package mitchellh/go-homedir

---
 vendor/mitchellh/go-homedir/LICENSE         |  21 ++++
 vendor/mitchellh/go-homedir/README.md       |  14 +++
 vendor/mitchellh/go-homedir/homedir.go      | 155 ++++++++++++++++++++++++++++
 vendor/mitchellh/go-homedir/homedir_test.go | 129 +++++++++++++++++++++++
 4 files changed, 319 insertions(+)
 create mode 100644 vendor/mitchellh/go-homedir/LICENSE
 create mode 100644 vendor/mitchellh/go-homedir/README.md
 create mode 100644 vendor/mitchellh/go-homedir/homedir.go
 create mode 100644 vendor/mitchellh/go-homedir/homedir_test.go

diff --git a/vendor/mitchellh/go-homedir/LICENSE b/vendor/mitchellh/go-homedir/LICENSE
new file mode 100644
index 0000000..f9c841a
--- /dev/null
+++ b/vendor/mitchellh/go-homedir/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2013 Mitchell Hashimoto
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/vendor/mitchellh/go-homedir/README.md b/vendor/mitchellh/go-homedir/README.md
new file mode 100644
index 0000000..d70706d
--- /dev/null
+++ b/vendor/mitchellh/go-homedir/README.md
@@ -0,0 +1,14 @@
+# go-homedir
+
+This is a Go library for detecting the user's home directory without
+the use of cgo, so the library can be used in cross-compilation environments.
+
+Usage is incredibly simple, just call `homedir.Dir()` to get the home directory
+for a user, and `homedir.Expand()` to expand the `~` in a path to the home
+directory.
+
+**Why not just use `os/user`?** The built-in `os/user` package requires
+cgo on Darwin systems. This means that any Go code that uses that package
+cannot cross compile. But 99% of the time the use for `os/user` is just to
+retrieve the home directory, which we can do for the current user without
+cgo. This library does that, enabling cross-compilation.
diff --git a/vendor/mitchellh/go-homedir/homedir.go b/vendor/mitchellh/go-homedir/homedir.go
new file mode 100644
index 0000000..acbb605
--- /dev/null
+++ b/vendor/mitchellh/go-homedir/homedir.go
@@ -0,0 +1,155 @@
+package homedir
+
+import (
+	"bytes"
+	"errors"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"runtime"
+	"strconv"
+	"strings"
+	"sync"
+)
+
+// DisableCache will disable caching of the home directory. Caching is enabled
+// by default.
+var DisableCache bool
+
+var homedirCache string
+var cacheLock sync.RWMutex
+
+// Dir returns the home directory for the executing user.
+//
+// This uses an OS-specific method for discovering the home directory.
+// An error is returned if a home directory cannot be detected.
+func Dir() (string, error) {
+	if !DisableCache {
+		cacheLock.RLock()
+		cached := homedirCache
+		cacheLock.RUnlock()
+		if cached != "" {
+			return cached, nil
+		}
+	}
+
+	cacheLock.Lock()
+	defer cacheLock.Unlock()
+
+	var result string
+	var err error
+	if runtime.GOOS == "windows" {
+		result, err = dirWindows()
+	} else {
+		// Unix-like system, so just assume Unix
+		result, err = dirUnix()
+	}
+
+	if err != nil {
+		return "", err
+	}
+	homedirCache = result
+	return result, nil
+}
+
+// Expand expands the path to include the home directory if the path
+// is prefixed with `~`. If it isn't prefixed with `~`, the path is
+// returned as-is.
+func Expand(path string) (string, error) {
+	if len(path) == 0 {
+		return path, nil
+	}
+
+	if path[0] != '~' {
+		return path, nil
+	}
+
+	if len(path) > 1 && path[1] != '/' && path[1] != '\\' {
+		return "", errors.New("cannot expand user-specific home dir")
+	}
+
+	dir, err := Dir()
+	if err != nil {
+		return "", err
+	}
+
+	return filepath.Join(dir, path[1:]), nil
+}
+
+func dirUnix() (string, error) {
+	homeEnv := "HOME"
+	if runtime.GOOS == "plan9" {
+		// On plan9, env vars are lowercase.
+		homeEnv = "home"
+	}
+
+	// First prefer the HOME environmental variable
+	if home := os.Getenv(homeEnv); home != "" {
+		return home, nil
+	}
+
+	var stdout bytes.Buffer
+
+	// If that fails, try OS specific commands
+	if runtime.GOOS == "darwin" {
+		cmd := exec.Command("sh", "-c", `dscl -q . -read /Users/"$(whoami)" NFSHomeDirectory | sed 's/^[^ ]*: //'`)
+		cmd.Stdout = &stdout
+		if err := cmd.Run(); err == nil {
+			result := strings.TrimSpace(stdout.String())
+			if result != "" {
+				return result, nil
+			}
+		}
+	} else {
+		cmd := exec.Command("getent", "passwd", strconv.Itoa(os.Getuid()))
+		cmd.Stdout = &stdout
+		if err := cmd.Run(); err != nil {
+			// If the error is ErrNotFound, we ignore it. Otherwise, return it.
+			if err != exec.ErrNotFound {
+				return "", err
+			}
+		} else {
+			if passwd := strings.TrimSpace(stdout.String()); passwd != "" {
+				// username:password:uid:gid:gecos:home:shell
+				passwdParts := strings.SplitN(passwd, ":", 7)
+				if len(passwdParts) > 5 {
+					return passwdParts[5], nil
+				}
+			}
+		}
+	}
+
+	// If all else fails, try the shell
+	stdout.Reset()
+	cmd := exec.Command("sh", "-c", "cd && pwd")
+	cmd.Stdout = &stdout
+	if err := cmd.Run(); err != nil {
+		return "", err
+	}
+
+	result := strings.TrimSpace(stdout.String())
+	if result == "" {
+		return "", errors.New("blank output when reading home directory")
+	}
+
+	return result, nil
+}
+
+func dirWindows() (string, error) {
+	// First prefer the HOME environmental variable
+	if home := os.Getenv("HOME"); home != "" {
+		return home, nil
+	}
+
+	drive := os.Getenv("HOMEDRIVE")
+	path := os.Getenv("HOMEPATH")
+	home := drive + path
+	if drive == "" || path == "" {
+		home = os.Getenv("USERPROFILE")
+	}
+	if home == "" {
+		return "", errors.New("HOMEDRIVE, HOMEPATH, and USERPROFILE are blank")
+	}
+
+	return home, nil
+}
diff --git a/vendor/mitchellh/go-homedir/homedir_test.go b/vendor/mitchellh/go-homedir/homedir_test.go
new file mode 100644
index 0000000..cd52127
--- /dev/null
+++ b/vendor/mitchellh/go-homedir/homedir_test.go
@@ -0,0 +1,129 @@
+package homedir
+
+import (
+	"os"
+	"os/user"
+	"path/filepath"
+	"testing"
+)
+
+func patchEnv(key, value string) func() {
+	bck := os.Getenv(key)
+	deferFunc := func() {
+		os.Setenv(key, bck)
+	}
+
+	if value != "" {
+		os.Setenv(key, value)
+	} else {
+		os.Unsetenv(key)
+	}
+
+	return deferFunc
+}
+
+func BenchmarkDir(b *testing.B) {
+	// We do this for any "warmups"
+	for i := 0; i < 10; i++ {
+		Dir()
+	}
+
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		Dir()
+	}
+}
+
+func TestDir(t *testing.T) {
+	u, err := user.Current()
+	if err != nil {
+		t.Fatalf("err: %s", err)
+	}
+
+	dir, err := Dir()
+	if err != nil {
+		t.Fatalf("err: %s", err)
+	}
+
+	if u.HomeDir != dir {
+		t.Fatalf("%#v != %#v", u.HomeDir, dir)
+	}
+
+	DisableCache = true
+	defer func() { DisableCache = false }()
+	defer patchEnv("HOME", "")()
+	dir, err = Dir()
+	if err != nil {
+		t.Fatalf("err: %s", err)
+	}
+
+	if u.HomeDir != dir {
+		t.Fatalf("%#v != %#v", u.HomeDir, dir)
+	}
+}
+
+func TestExpand(t *testing.T) {
+	u, err := user.Current()
+	if err != nil {
+		t.Fatalf("err: %s", err)
+	}
+
+	cases := []struct {
+		Input  string
+		Output string
+		Err    bool
+	}{
+		{
+			"/foo",
+			"/foo",
+			false,
+		},
+
+		{
+			"~/foo",
+			filepath.Join(u.HomeDir, "foo"),
+			false,
+		},
+
+		{
+			"",
+			"",
+			false,
+		},
+
+		{
+			"~",
+			u.HomeDir,
+			false,
+		},
+
+		{
+			"~foo/foo",
+			"",
+			true,
+		},
+	}
+
+	for _, tc := range cases {
+		actual, err := Expand(tc.Input)
+		if (err != nil) != tc.Err {
+			t.Fatalf("Input: %#v\n\nErr: %s", tc.Input, err)
+		}
+
+		if actual != tc.Output {
+			t.Fatalf("Input: %#v\n\nOutput: %#v", tc.Input, actual)
+		}
+	}
+
+	DisableCache = true
+	defer func() { DisableCache = false }()
+	defer patchEnv("HOME", "/custom/path/")()
+	expected := filepath.Join("/", "custom", "path", "foo/bar")
+	actual, err := Expand("~/foo/bar")
+
+	if err != nil {
+		t.Errorf("No error is expected, got: %v", err)
+	} else if actual != expected {
+		t.Errorf("Expected: %v; actual: %v", expected, actual)
+	}
+}
-- 
2.7.4


From 679ca1dbe35a705f25873c21eaba7ae89f370055 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 19 Jul 2018 13:25:47 -0400
Subject: [PATCH 03/79] Make the parsing of the reciepients and email addresses
 better

---
 images/encryption.go | 35 ++++++++++++++++++++++++++++++++++-
 1 file changed, 34 insertions(+), 1 deletion(-)

diff --git a/images/encryption.go b/images/encryption.go
index 2a10301..32017a2 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -19,6 +19,7 @@ import (
 	"bytes"
 	"fmt"
         "io/ioutil"
+	"net/mail"
 	"strings"
 
 	"github.com/mitchellh/go-homedir"
@@ -59,19 +60,48 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 		return nil, err
 	}
 
+	rSet := make(map[string]int)
+	for _, r := range ec.Recipients {
+		rSet[r] = 0
+	}
+
 	var filteredList openpgp.EntityList
 	for _, entity := range entityList {
 		for k, _ := range entity.Identities {
 			fmt.Printf("k = %s\n",k)
+			addr, err := mail.ParseAddress(k)
+			if err != nil {
+				return nil, err
+			}
 			for _, r := range ec.Recipients {
-				if strings.Contains(k, r) {
+				if strings.Compare(addr.Name, r) == 0 || strings.Compare(addr.Address, r) == 0 {
 					fmt.Printf(" TAKING key of %s\n", k)
 					filteredList = append(filteredList, entity)
+					rSet[r] = rSet[r] + 1
 				}
 			}
 		}
 	}
 
+	// make sure we found keys for all the Recipients...
+	var buffer bytes.Buffer
+	notFound := false;
+	buffer.WriteString("No key found for the following recipients: ")
+
+	for k, v := range rSet {
+		if v == 0 {
+			if notFound {
+				buffer.WriteString(", ")
+			}
+			buffer.WriteString(k)
+			notFound = true;
+		}
+	}
+
+	if notFound {
+		return nil, fmt.Errorf(buffer.String())
+	}
+
 	return filteredList, nil
 }
 
@@ -81,6 +111,9 @@ func Encrypt(ec *EncryptConfig, data []byte) ([]byte, error) {
 	if err != nil {
 		return nil, err
 	}
+	if len(filteredList) == 0 {
+		return nil, fmt.Errorf("No keys were found to encrypt message to.\n")
+	}
 
 	buf := new(bytes.Buffer)
 
-- 
2.7.4


From 8005c66e616595df42285ca7fe0ba6384cd983bf Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 19 Jul 2018 20:37:49 -0400
Subject: [PATCH 04/79] Add containerd.io/gc.ref.content.%d type of labels so
 gc doesn't throw it away

---
 images/image.go | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/images/image.go b/images/image.go
index d738d26..94d7358 100644
--- a/images/image.go
+++ b/images/image.go
@@ -481,8 +481,13 @@ func EncryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descrip
 		}
 		fmt.Printf("   old Index %s now written as %s\n", desc.Digest, nDesc.Digest)
 
+		labels := map[string]string{}
+		for i, m := range newIndex.Manifests {
+			labels[fmt.Sprintf("containerd.io/gc.ref.content.%d", i)] = m.Digest.String()
+		}
+
 		ref := fmt.Sprintf("index-%s", nDesc.Digest.String())
-		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), nDesc); err != nil {
+		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), nDesc, content.WithLabels(labels)); err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to write index")
 		}
 		return nDesc, true, nil
-- 
2.7.4


From e6c2310b09632372e06f574188c8aa1b789da606 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 10:22:02 -0400
Subject: [PATCH 05/79] Allow to replace an existing image with its encrypted
 form

A new name for an image doesn't need to be passed in anymore but we can
replace an existing image if no new name is given. All unreferenced
unencrypted layers will be removed as part of the garbage collection.
---
 cmd/ctr/commands/images/encrypt.go |  7 +++--
 metadata/images.go                 | 57 ++++++++++++++++++++++++++------------
 services/images/local.go           | 12 ++++----
 3 files changed, 50 insertions(+), 26 deletions(-)

diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 1ad7d47..2c85807 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -45,10 +45,11 @@ var encryptCommand = cli.Command{
 		if local == "" {
 			return errors.New("please provide the name of an image to encrypt")
 		}
-		if newName == "" {
-			return errors.New("please provide a name for the encrypted image")
+		if newName != "" {
+			fmt.Printf("Encrypting %s to %s\n", local, newName)
+		} else {
+			fmt.Printf("Encrypting %s and replacing it with the encrypted image\n");
 		}
-		fmt.Printf("Encrypting %s to %s\n", local, newName)
 		client, ctx, cancel, err := commands.NewClient(context)
 		if err != nil {
 			return err
diff --git a/metadata/images.go b/metadata/images.go
index 2263bb6..0687ba9 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -118,27 +118,51 @@ func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec
 		return image, nil
 	}
 
-	image.Target = newSpec
-	image.Name = newName
-	fmt.Printf("newSpec.Digest: %s\n", newSpec.Digest)
-	fmt.Printf("newName: %s\n", newName)
-	image.UpdatedAt = time.Now().UTC()
+	// if newName is either empty or equal to the existing name, it's an update
+	if (newName == "" || strings.Compare(image.Name, newName) == 0) {
+		if err := update(ctx, s.db, func(tx *bolt.Tx) error {
+			bkt, err := createImagesBucket(tx, namespace)
+			if err != nil {
+				return err
+			}
+
+			ibkt := bkt.Bucket([]byte(image.Name))
+			if ibkt == nil {
+				return errors.Wrapf(errdefs.ErrNotFound, "image %q", image.Name)
+			}
+
+			if err := validateImage(&image); err != nil {
+				return err
+			}
+
+			image.UpdatedAt = time.Now().UTC()
+			image.Target = newSpec
+			if err := writeImage(ibkt, &image); err != nil {
+				return err
+			}
+			// A reference to a piece of content has been removed,
+			// mark content store as dirty for triggering garbage
+			// collection
+			s.db.dirtyL.Lock()
+			s.db.dirtyCS = true
+			s.db.dirtyL.Unlock()
+
+			return nil
+		}); err != nil {
+			return image, err
+		}
+		return image, nil
+	}
 
 	if err := update(ctx, s.db, func(tx *bolt.Tx) error {
+		image.Target = newSpec
+		image.Name = newName
+		image.UpdatedAt = time.Now().UTC()
+
 		if err := validateImage(&image); err != nil {
 			return err
 		}
 
-		//bkt := getImagesBucket(tx, namespace)
-		//if bkt == nil {
-		//	return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		//}
-
-		//err = bkt.DeleteBucket([]byte(name))
-		//if err == bolt.ErrBucketNotFound {
-		//	return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		//}
-
 		bkt, err := createImagesBucket(tx, namespace)
 		if err != nil {
 			return err
@@ -153,7 +177,6 @@ func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec
 			return errors.Wrapf(errdefs.ErrAlreadyExists, "image %q", image.Name)
 		}
 
-		//return nil
 		return writeImage(ibkt, &image)
 	}); err != nil {
 		return image, err
@@ -233,7 +256,7 @@ func (s *imageStore) Create(ctx context.Context, image images.Image) (images.Ima
 
 		image.CreatedAt = time.Now().UTC()
 		image.UpdatedAt = image.CreatedAt
-		return writeImage(ibkt, &image)
+		return writeImage(ibkt, &image);
 	}); err != nil {
 		return images.Image{}, err
 	}
diff --git a/services/images/local.go b/services/images/local.go
index f5b1f1f..2de54c8 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -195,12 +195,12 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 	}
 	resp.Image = imageToProto(&encrypted)
 
-	//if err := l.publisher.Publish(ctx, "/images/update", &eventstypes.ImageUpdate{
-	//	Name:   resp.Image.Name,
-	//	Labels: resp.Image.Labels,
-	//}); err != nil {
-	//	return nil, err
-	//}
+	if err := l.publisher.Publish(ctx, "/images/update", &eventstypes.ImageUpdate{
+		Name:   resp.Image.Name,
+		Labels: resp.Image.Labels,
+	}); err != nil {
+		return nil, err
+	}
 
 	return &resp, nil
 }
-- 
2.7.4


From 5cf4ae96f61a95603d956315fdb6eb85e5f687f2 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 11:54:32 -0400
Subject: [PATCH 06/79] Fix output of ctr command

---
 cmd/ctr/commands/images/encrypt.go | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 2c85807..6b82f45 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -48,7 +48,7 @@ var encryptCommand = cli.Command{
 		if newName != "" {
 			fmt.Printf("Encrypting %s to %s\n", local, newName)
 		} else {
-			fmt.Printf("Encrypting %s and replacing it with the encrypted image\n");
+			fmt.Printf("Encrypting %s and replacing it with the encrypted image\n", local);
 		}
 		client, ctx, cancel, err := commands.NewClient(context)
 		if err != nil {
@@ -78,7 +78,6 @@ var encryptCommand = cli.Command{
 		if err != nil {
 			return err
 		}
-		fmt.Printf("local: %s,  img.Name: %s", local, img.Name)
 		return nil
 	},
 }
-- 
2.7.4


From e09ea7e7305cdd39faf67d04ed88aa68e6cef570 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 12:15:06 -0400
Subject: [PATCH 07/79] Lots of refactoring to have decryption and encryption
 use commong code

---
 api/next.pb.txt                     |  52 +++-
 api/services/images/v1/images.pb.go | 549 +++++++++++++++++++++++++++++++-----
 api/services/images/v1/images.proto |  18 +-
 cmd/ctr/commands/images/encrypt.go  |  13 +-
 cmd/ctr/commands/images/push.go     |   5 +-
 image_store.go                      |  20 +-
 images/encryption.go                |  20 +-
 images/image.go                     |  74 +++--
 metadata/images.go                  |  14 +-
 services/images/local.go            |  29 +-
 services/images/service.go          |   4 +
 11 files changed, 667 insertions(+), 131 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 78429f4..69bf042 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2219,7 +2219,7 @@ file {
     }
   }
   message_type {
-    name: "EncryptConfig"
+    name: "CryptoConfig"
     field {
       name: "recipients"
       number: 1
@@ -2252,12 +2252,12 @@ file {
       json_name: "newName"
     }
     field {
-      name: "ec"
+      name: "cc"
       number: 3
       label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
-      type_name: ".containerd.services.images.v1.EncryptConfig"
-      json_name: "ec"
+      type_name: ".containerd.services.images.v1.CryptoConfig"
+      json_name: "cc"
     }
   }
   message_type {
@@ -2274,6 +2274,45 @@ file {
       json_name: "image"
     }
   }
+  message_type {
+    name: "DecryptImageRequest"
+    field {
+      name: "name"
+      number: 1
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "name"
+    }
+    field {
+      name: "newName"
+      number: 2
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "newName"
+    }
+    field {
+      name: "cc"
+      number: 3
+      label: LABEL_OPTIONAL
+      type: TYPE_MESSAGE
+      type_name: ".containerd.services.images.v1.CryptoConfig"
+      json_name: "cc"
+    }
+  }
+  message_type {
+    name: "DecryptImageResponse"
+    field {
+      name: "image"
+      number: 1
+      label: LABEL_OPTIONAL
+      type: TYPE_MESSAGE
+      type_name: ".containerd.services.images.v1.Image"
+      options {
+        65001: 0
+      }
+      json_name: "image"
+    }
+  }
   service {
     name: "Images"
     method {
@@ -2306,6 +2345,11 @@ file {
       input_type: ".containerd.services.images.v1.EncryptImageRequest"
       output_type: ".containerd.services.images.v1.EncryptImageResponse"
     }
+    method {
+      name: "DecryptImage"
+      input_type: ".containerd.services.images.v1.DecryptImageRequest"
+      output_type: ".containerd.services.images.v1.DecryptImageResponse"
+    }
   }
   options {
     go_package: "github.com/containerd/containerd/api/services/images/v1;images"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 2045d9b..d51f0f4 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -18,9 +18,11 @@
 		ListImagesRequest
 		ListImagesResponse
 		DeleteImageRequest
-		EncryptConfig
+		CryptoConfig
 		EncryptImageRequest
 		EncryptImageResponse
+		DecryptImageRequest
+		DecryptImageResponse
 */
 package images
 
@@ -175,19 +177,20 @@ func (m *DeleteImageRequest) Reset()                    { *m = DeleteImageReques
 func (*DeleteImageRequest) ProtoMessage()               {}
 func (*DeleteImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{9} }
 
-type EncryptConfig struct {
+// CryptConfig serves to pass keys used for encryption and decryption
+type CryptoConfig struct {
 	Recipients    []string `protobuf:"bytes,1,rep,name=recipients" json:"recipients,omitempty"`
 	Gpgpubkeyring []byte   `protobuf:"bytes,2,opt,name=gpgpubkeyring,proto3" json:"gpgpubkeyring,omitempty"`
 }
 
-func (m *EncryptConfig) Reset()                    { *m = EncryptConfig{} }
-func (*EncryptConfig) ProtoMessage()               {}
-func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
+func (m *CryptoConfig) Reset()                    { *m = CryptoConfig{} }
+func (*CryptoConfig) ProtoMessage()               {}
+func (*CryptoConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
 
 type EncryptImageRequest struct {
-	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Ec      *EncryptConfig `protobuf:"bytes,3,opt,name=ec" json:"ec,omitempty"`
+	Name    string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName string        `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Cc      *CryptoConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
 }
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
@@ -202,6 +205,24 @@ func (m *EncryptImageResponse) Reset()                    { *m = EncryptImageRes
 func (*EncryptImageResponse) ProtoMessage()               {}
 func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
 
+type DecryptImageRequest struct {
+	Name    string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName string        `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Cc      *CryptoConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+}
+
+func (m *DecryptImageRequest) Reset()                    { *m = DecryptImageRequest{} }
+func (*DecryptImageRequest) ProtoMessage()               {}
+func (*DecryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{13} }
+
+type DecryptImageResponse struct {
+	Image Image `protobuf:"bytes,1,opt,name=image" json:"image"`
+}
+
+func (m *DecryptImageResponse) Reset()                    { *m = DecryptImageResponse{} }
+func (*DecryptImageResponse) ProtoMessage()               {}
+func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
+
 func init() {
 	proto.RegisterType((*Image)(nil), "containerd.services.images.v1.Image")
 	proto.RegisterType((*GetImageRequest)(nil), "containerd.services.images.v1.GetImageRequest")
@@ -213,9 +234,11 @@ func init() {
 	proto.RegisterType((*ListImagesRequest)(nil), "containerd.services.images.v1.ListImagesRequest")
 	proto.RegisterType((*ListImagesResponse)(nil), "containerd.services.images.v1.ListImagesResponse")
 	proto.RegisterType((*DeleteImageRequest)(nil), "containerd.services.images.v1.DeleteImageRequest")
-	proto.RegisterType((*EncryptConfig)(nil), "containerd.services.images.v1.EncryptConfig")
+	proto.RegisterType((*CryptoConfig)(nil), "containerd.services.images.v1.CryptoConfig")
 	proto.RegisterType((*EncryptImageRequest)(nil), "containerd.services.images.v1.EncryptImageRequest")
 	proto.RegisterType((*EncryptImageResponse)(nil), "containerd.services.images.v1.EncryptImageResponse")
+	proto.RegisterType((*DecryptImageRequest)(nil), "containerd.services.images.v1.DecryptImageRequest")
+	proto.RegisterType((*DecryptImageResponse)(nil), "containerd.services.images.v1.DecryptImageResponse")
 }
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -244,6 +267,8 @@ type ImagesClient interface {
 	Delete(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
 	// Encyrpt an image given its name
 	EncryptImage(ctx context.Context, in *EncryptImageRequest, opts ...grpc.CallOption) (*EncryptImageResponse, error)
+	// Decyrpt an image given its name
+	DecryptImage(ctx context.Context, in *DecryptImageRequest, opts ...grpc.CallOption) (*DecryptImageResponse, error)
 }
 
 type imagesClient struct {
@@ -308,6 +333,15 @@ func (c *imagesClient) EncryptImage(ctx context.Context, in *EncryptImageRequest
 	return out, nil
 }
 
+func (c *imagesClient) DecryptImage(ctx context.Context, in *DecryptImageRequest, opts ...grpc.CallOption) (*DecryptImageResponse, error) {
+	out := new(DecryptImageResponse)
+	err := grpc.Invoke(ctx, "/containerd.services.images.v1.Images/DecryptImage", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
 // Server API for Images service
 
 type ImagesServer interface {
@@ -326,6 +360,8 @@ type ImagesServer interface {
 	Delete(context.Context, *DeleteImageRequest) (*google_protobuf1.Empty, error)
 	// Encyrpt an image given its name
 	EncryptImage(context.Context, *EncryptImageRequest) (*EncryptImageResponse, error)
+	// Decyrpt an image given its name
+	DecryptImage(context.Context, *DecryptImageRequest) (*DecryptImageResponse, error)
 }
 
 func RegisterImagesServer(s *grpc.Server, srv ImagesServer) {
@@ -440,6 +476,24 @@ func _Images_EncryptImage_Handler(srv interface{}, ctx context.Context, dec func
 	return interceptor(ctx, in, info, handler)
 }
 
+func _Images_DecryptImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(DecryptImageRequest)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(ImagesServer).DecryptImage(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/containerd.services.images.v1.Images/DecryptImage",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(ImagesServer).DecryptImage(ctx, req.(*DecryptImageRequest))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
 var _Images_serviceDesc = grpc.ServiceDesc{
 	ServiceName: "containerd.services.images.v1.Images",
 	HandlerType: (*ImagesServer)(nil),
@@ -468,6 +522,10 @@ var _Images_serviceDesc = grpc.ServiceDesc{
 			MethodName: "EncryptImage",
 			Handler:    _Images_EncryptImage_Handler,
 		},
+		{
+			MethodName: "DecryptImage",
+			Handler:    _Images_DecryptImage_Handler,
+		},
 	},
 	Streams:  []grpc.StreamDesc{},
 	Metadata: "github.com/containerd/containerd/api/services/images/v1/images.proto",
@@ -801,7 +859,7 @@ func (m *DeleteImageRequest) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
-func (m *EncryptConfig) Marshal() (dAtA []byte, err error) {
+func (m *CryptoConfig) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalTo(dAtA)
@@ -811,7 +869,7 @@ func (m *EncryptConfig) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *EncryptConfig) MarshalTo(dAtA []byte) (int, error) {
+func (m *CryptoConfig) MarshalTo(dAtA []byte) (int, error) {
 	var i int
 	_ = i
 	var l int
@@ -867,11 +925,11 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.NewName)))
 		i += copy(dAtA[i:], m.NewName)
 	}
-	if m.Ec != nil {
+	if m.Cc != nil {
 		dAtA[i] = 0x1a
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(m.Ec.Size()))
-		n10, err := m.Ec.MarshalTo(dAtA[i:])
+		i = encodeVarintImages(dAtA, i, uint64(m.Cc.Size()))
+		n10, err := m.Cc.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
@@ -906,6 +964,72 @@ func (m *EncryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
+func (m *DecryptImageRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *DecryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Name) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Name)))
+		i += copy(dAtA[i:], m.Name)
+	}
+	if len(m.NewName) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.NewName)))
+		i += copy(dAtA[i:], m.NewName)
+	}
+	if m.Cc != nil {
+		dAtA[i] = 0x1a
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(m.Cc.Size()))
+		n12, err := m.Cc.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n12
+	}
+	return i, nil
+}
+
+func (m *DecryptImageResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	dAtA[i] = 0xa
+	i++
+	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
+	n13, err := m.Image.MarshalTo(dAtA[i:])
+	if err != nil {
+		return 0, err
+	}
+	i += n13
+	return i, nil
+}
+
 func encodeVarintImages(dAtA []byte, offset int, v uint64) int {
 	for v >= 1<<7 {
 		dAtA[offset] = uint8(v&0x7f | 0x80)
@@ -1032,7 +1156,7 @@ func (m *DeleteImageRequest) Size() (n int) {
 	return n
 }
 
-func (m *EncryptConfig) Size() (n int) {
+func (m *CryptoConfig) Size() (n int) {
 	var l int
 	_ = l
 	if len(m.Recipients) > 0 {
@@ -1059,8 +1183,8 @@ func (m *EncryptImageRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
-	if m.Ec != nil {
-		l = m.Ec.Size()
+	if m.Cc != nil {
+		l = m.Cc.Size()
 		n += 1 + l + sovImages(uint64(l))
 	}
 	return n
@@ -1074,6 +1198,32 @@ func (m *EncryptImageResponse) Size() (n int) {
 	return n
 }
 
+func (m *DecryptImageRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	l = len(m.NewName)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	if m.Cc != nil {
+		l = m.Cc.Size()
+		n += 1 + l + sovImages(uint64(l))
+	}
+	return n
+}
+
+func (m *DecryptImageResponse) Size() (n int) {
+	var l int
+	_ = l
+	l = m.Image.Size()
+	n += 1 + l + sovImages(uint64(l))
+	return n
+}
+
 func sovImages(x uint64) (n int) {
 	for {
 		n++
@@ -1203,11 +1353,11 @@ func (this *DeleteImageRequest) String() string {
 	}, "")
 	return s
 }
-func (this *EncryptConfig) String() string {
+func (this *CryptoConfig) String() string {
 	if this == nil {
 		return "nil"
 	}
-	s := strings.Join([]string{`&EncryptConfig{`,
+	s := strings.Join([]string{`&CryptoConfig{`,
 		`Recipients:` + fmt.Sprintf("%v", this.Recipients) + `,`,
 		`Gpgpubkeyring:` + fmt.Sprintf("%v", this.Gpgpubkeyring) + `,`,
 		`}`,
@@ -1221,7 +1371,7 @@ func (this *EncryptImageRequest) String() string {
 	s := strings.Join([]string{`&EncryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
-		`Ec:` + strings.Replace(fmt.Sprintf("%v", this.Ec), "EncryptConfig", "EncryptConfig", 1) + `,`,
+		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "CryptoConfig", "CryptoConfig", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1236,6 +1386,28 @@ func (this *EncryptImageResponse) String() string {
 	}, "")
 	return s
 }
+func (this *DecryptImageRequest) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&DecryptImageRequest{`,
+		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
+		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
+		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "CryptoConfig", "CryptoConfig", 1) + `,`,
+		`}`,
+	}, "")
+	return s
+}
+func (this *DecryptImageResponse) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&DecryptImageResponse{`,
+		`Image:` + strings.Replace(strings.Replace(this.Image.String(), "Image", "Image", 1), `&`, ``, 1) + `,`,
+		`}`,
+	}, "")
+	return s
+}
 func valueToStringImages(v interface{}) string {
 	rv := reflect.ValueOf(v)
 	if rv.IsNil() {
@@ -2305,7 +2477,7 @@ func (m *DeleteImageRequest) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
+func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -2328,10 +2500,10 @@ func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: EncryptConfig: wiretype end group for non-group")
+			return fmt.Errorf("proto: CryptoConfig: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: EncryptConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: CryptoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
@@ -2504,7 +2676,7 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Ec", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Cc", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -2528,10 +2700,10 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Ec == nil {
-				m.Ec = &EncryptConfig{}
+			if m.Cc == nil {
+				m.Cc = &CryptoConfig{}
 			}
-			if err := m.Ec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -2636,6 +2808,227 @@ func (m *EncryptImageResponse) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DecryptImageRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DecryptImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field NewName", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.NewName = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Cc", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Cc == nil {
+				m.Cc = &CryptoConfig{}
+			}
+			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *DecryptImageResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DecryptImageResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DecryptImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipImages(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
@@ -2746,54 +3139,56 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 774 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0xd3, 0x58,
-	0x10, 0x8f, 0xf3, 0xaf, 0xed, 0xa4, 0xd5, 0x76, 0x5f, 0xab, 0x95, 0xe5, 0xdd, 0x4d, 0x23, 0xab,
-	0x2b, 0xe5, 0xb0, 0xd8, 0x34, 0xbd, 0x40, 0x5b, 0x21, 0x9a, 0xb6, 0x14, 0xa4, 0xd2, 0x83, 0xa1,
-	0x10, 0x71, 0xa9, 0x1c, 0x67, 0x62, 0xac, 0x24, 0xb6, 0xf1, 0x7b, 0x49, 0x95, 0x1b, 0x7c, 0x00,
-	0x24, 0x24, 0xbe, 0x54, 0x8f, 0x1c, 0x39, 0x01, 0xcd, 0x81, 0xcf, 0x81, 0xfc, 0xfc, 0x4c, 0xf3,
-	0x4f, 0x38, 0x29, 0xbd, 0xcd, 0x7b, 0x9e, 0xdf, 0x6f, 0x66, 0x7e, 0xf3, 0x66, 0x64, 0x38, 0xb4,
-	0x1d, 0xf6, 0xba, 0x5b, 0xd7, 0x2c, 0xaf, 0xa3, 0x5b, 0x9e, 0xcb, 0x4c, 0xc7, 0xc5, 0xa0, 0x31,
-	0x6c, 0x9a, 0xbe, 0xa3, 0x53, 0x0c, 0x7a, 0x8e, 0x85, 0x54, 0x77, 0x3a, 0xa6, 0x8d, 0x54, 0xef,
-	0x6d, 0x09, 0x4b, 0xf3, 0x03, 0x8f, 0x79, 0xe4, 0xdf, 0x6b, 0x7f, 0x2d, 0xf6, 0xd5, 0x84, 0x47,
-	0x6f, 0x4b, 0x59, 0xb7, 0x3d, 0xdb, 0xe3, 0x9e, 0x7a, 0x68, 0x45, 0x20, 0xe5, 0x6f, 0xdb, 0xf3,
-	0xec, 0x36, 0xea, 0xfc, 0x54, 0xef, 0x36, 0x75, 0xec, 0xf8, 0xac, 0x2f, 0x3e, 0x96, 0xc6, 0x3f,
-	0x36, 0x1d, 0x6c, 0x37, 0xce, 0x3b, 0x26, 0x6d, 0x09, 0x8f, 0x8d, 0x71, 0x0f, 0xe6, 0x74, 0x90,
-	0x32, 0xb3, 0xe3, 0x0b, 0x87, 0xdd, 0x99, 0x4a, 0x63, 0x7d, 0x1f, 0xa9, 0xde, 0x40, 0x6a, 0x05,
-	0x8e, 0xcf, 0xbc, 0x20, 0x02, 0xab, 0xdf, 0xd3, 0x90, 0x7b, 0x12, 0x16, 0x40, 0x08, 0x64, 0x5d,
-	0xb3, 0x83, 0xb2, 0x54, 0x92, 0xca, 0x4b, 0x06, 0xb7, 0xc9, 0x63, 0xc8, 0xb7, 0xcd, 0x3a, 0xb6,
-	0xa9, 0x9c, 0x2e, 0x65, 0xca, 0x85, 0xca, 0x5d, 0xed, 0x97, 0x02, 0x68, 0x9c, 0x49, 0x3b, 0xe1,
-	0x90, 0x23, 0x97, 0x05, 0x7d, 0x43, 0xe0, 0xc9, 0x0e, 0xe4, 0x99, 0x19, 0xd8, 0xc8, 0xe4, 0x4c,
-	0x49, 0x2a, 0x17, 0x2a, 0xff, 0x0c, 0x33, 0xf1, 0xdc, 0xb4, 0xc3, 0x9f, 0xb9, 0x55, 0xb3, 0x97,
-	0x5f, 0x36, 0x52, 0x86, 0x40, 0x90, 0x03, 0x00, 0x2b, 0x40, 0x93, 0x61, 0xe3, 0xdc, 0x64, 0xf2,
-	0x02, 0xc7, 0x2b, 0x5a, 0x24, 0x8b, 0x16, 0xcb, 0xa2, 0x3d, 0x8f, 0x65, 0xa9, 0x2e, 0x86, 0xe8,
-	0x0f, 0x5f, 0x37, 0x24, 0x63, 0x49, 0xe0, 0xf6, 0x39, 0x49, 0xd7, 0x6f, 0xc4, 0x24, 0x8b, 0xf3,
-	0x90, 0x08, 0xdc, 0x3e, 0x53, 0xee, 0x43, 0x61, 0xa8, 0x38, 0xb2, 0x0a, 0x99, 0x16, 0xf6, 0x85,
-	0x62, 0xa1, 0x49, 0xd6, 0x21, 0xd7, 0x33, 0xdb, 0x5d, 0x94, 0xd3, 0xfc, 0x2e, 0x3a, 0xec, 0xa4,
-	0xef, 0x49, 0xea, 0x7f, 0xf0, 0xc7, 0x31, 0x32, 0x2e, 0x90, 0x81, 0x6f, 0xba, 0x48, 0xd9, 0x34,
-	0xc5, 0xd5, 0x53, 0x58, 0xbd, 0x76, 0xa3, 0xbe, 0xe7, 0x52, 0x24, 0x3b, 0x90, 0xe3, 0x12, 0x73,
-	0xc7, 0x42, 0x65, 0x73, 0x96, 0x26, 0x18, 0x11, 0x44, 0x7d, 0x01, 0xe4, 0x80, 0x6b, 0x30, 0x12,
-	0xf9, 0xe1, 0x0d, 0x18, 0x45, 0x53, 0x04, 0xef, 0x4b, 0x58, 0x1b, 0xe1, 0x15, 0xa9, 0xfe, 0x3e,
-	0xf1, 0x47, 0x09, 0xc8, 0x19, 0x17, 0xfc, 0x76, 0x33, 0x26, 0xbb, 0x50, 0x88, 0x1a, 0xc9, 0x87,
-	0x8b, 0x37, 0x68, 0xda, 0x0b, 0x78, 0x14, 0xce, 0xdf, 0x53, 0x93, 0xb6, 0x0c, 0xf1, 0x5e, 0x42,
-	0x3b, 0x2c, 0x77, 0x24, 0xa9, 0x5b, 0x2b, 0xf7, 0x0e, 0xfc, 0x79, 0xe2, 0xd0, 0xa8, 0xe1, 0x34,
-	0x2e, 0x56, 0x86, 0x85, 0xa6, 0xd3, 0x66, 0x18, 0x50, 0x59, 0x2a, 0x65, 0xca, 0x4b, 0x46, 0x7c,
-	0x54, 0x6b, 0x40, 0x86, 0xdd, 0x45, 0x1a, 0x55, 0xc8, 0x47, 0x41, 0xb8, 0xfb, 0x7c, 0x79, 0x08,
-	0xa4, 0xba, 0x07, 0xe4, 0x10, 0xdb, 0x38, 0x26, 0xfb, 0xb4, 0xa5, 0x40, 0x20, 0x4b, 0xfb, 0xae,
-	0xc5, 0x15, 0x5c, 0x34, 0xb8, 0xad, 0x9e, 0xc1, 0xca, 0x91, 0x6b, 0x05, 0x7d, 0x9f, 0x1d, 0x78,
-	0x6e, 0xd3, 0xb1, 0x49, 0x11, 0x20, 0x40, 0xcb, 0xf1, 0x1d, 0x74, 0x59, 0x5c, 0xc5, 0xd0, 0x0d,
-	0xd9, 0x84, 0x15, 0xdb, 0xb7, 0xfd, 0x6e, 0xbd, 0x85, 0xfd, 0xc0, 0x71, 0x6d, 0xce, 0xb6, 0x6c,
-	0x8c, 0x5e, 0xaa, 0xef, 0x24, 0x58, 0x13, 0xbc, 0x89, 0x69, 0xc9, 0xb0, 0xe0, 0xe2, 0xc5, 0x69,
-	0x78, 0x1d, 0x0d, 0x5f, 0x7c, 0x24, 0x7b, 0x90, 0x46, 0x4b, 0xec, 0x9d, 0xff, 0x13, 0xa4, 0x19,
-	0xa9, 0xc2, 0x48, 0xa3, 0xa5, 0xd6, 0x60, 0x7d, 0x34, 0x85, 0xdb, 0xea, 0x7d, 0xe5, 0x7d, 0x0e,
-	0xf2, 0x51, 0x27, 0x49, 0x13, 0x32, 0xc7, 0xc8, 0x88, 0x96, 0x40, 0x32, 0xb6, 0x41, 0x14, 0x7d,
-	0x66, 0x7f, 0x91, 0x74, 0x0b, 0xb2, 0xe1, 0xfb, 0x21, 0x49, 0x8b, 0x7c, 0xe2, 0x4d, 0x2a, 0x5b,
-	0x73, 0x20, 0x44, 0x30, 0x0f, 0xf2, 0xd1, 0x8e, 0x20, 0x49, 0xe0, 0xc9, 0x15, 0xa5, 0x54, 0xe6,
-	0x81, 0x5c, 0x07, 0x8c, 0xa6, 0x34, 0x31, 0xe0, 0xe4, 0x86, 0x49, 0x0c, 0x38, 0x6d, 0xfe, 0x9f,
-	0x41, 0x3e, 0x1a, 0x9a, 0xc4, 0x80, 0x93, 0xb3, 0xa5, 0xfc, 0x35, 0xb1, 0x7b, 0x8e, 0xc2, 0x1f,
-	0x03, 0x72, 0x01, 0xcb, 0xc3, 0x0f, 0x8e, 0x54, 0x66, 0x7b, 0xb2, 0x23, 0xdc, 0xdb, 0x73, 0x61,
-	0xa2, 0x6a, 0xaa, 0xb5, 0xcb, 0xab, 0x62, 0xea, 0xf3, 0x55, 0x31, 0xf5, 0x76, 0x50, 0x94, 0x2e,
-	0x07, 0x45, 0xe9, 0xd3, 0xa0, 0x28, 0x7d, 0x1b, 0x14, 0xa5, 0x57, 0x0f, 0x6e, 0xf8, 0xf7, 0xb4,
-	0x1b, 0x59, 0xb5, 0x54, 0x3d, 0xcf, 0x8b, 0xdc, 0xfe, 0x11, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x97,
-	0x31, 0xae, 0x88, 0x09, 0x00, 0x00,
+	// 804 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcf, 0x6f, 0xd3, 0x4a,
+	0x10, 0x8e, 0x93, 0xd4, 0x6d, 0x27, 0x79, 0x7a, 0x7d, 0xdb, 0xea, 0xc9, 0xf2, 0x7b, 0xa4, 0x91,
+	0x55, 0xa4, 0x48, 0x08, 0x9b, 0xa4, 0x17, 0x68, 0x10, 0xa2, 0x49, 0x4a, 0x41, 0x2a, 0x3d, 0x98,
+	0x02, 0x11, 0x97, 0xca, 0x71, 0x36, 0xc6, 0x4a, 0x62, 0x1b, 0xef, 0x26, 0x55, 0x6e, 0x3d, 0x71,
+	0x46, 0xe2, 0x9f, 0xea, 0x91, 0x23, 0x27, 0xa0, 0x39, 0xf0, 0x77, 0x20, 0xaf, 0xd7, 0xd4, 0xf9,
+	0x21, 0xdc, 0x94, 0x48, 0xdc, 0x66, 0x37, 0xf3, 0xcd, 0xcc, 0xf7, 0xcd, 0xce, 0xc4, 0xd0, 0xb0,
+	0x6c, 0xfa, 0x76, 0xd0, 0x52, 0x4d, 0xb7, 0xaf, 0x99, 0xae, 0x43, 0x0d, 0xdb, 0xc1, 0x7e, 0x3b,
+	0x6e, 0x1a, 0x9e, 0xad, 0x11, 0xec, 0x0f, 0x6d, 0x13, 0x13, 0xcd, 0xee, 0x1b, 0x16, 0x26, 0xda,
+	0xb0, 0xcc, 0x2d, 0xd5, 0xf3, 0x5d, 0xea, 0xa2, 0x5b, 0x57, 0xfe, 0x6a, 0xe4, 0xab, 0x72, 0x8f,
+	0x61, 0x59, 0xde, 0xb2, 0x5c, 0xcb, 0x65, 0x9e, 0x5a, 0x60, 0x85, 0x20, 0xf9, 0x3f, 0xcb, 0x75,
+	0xad, 0x1e, 0xd6, 0xd8, 0xa9, 0x35, 0xe8, 0x68, 0xb8, 0xef, 0xd1, 0x11, 0xff, 0xb1, 0x38, 0xfd,
+	0x63, 0xc7, 0xc6, 0xbd, 0xf6, 0x69, 0xdf, 0x20, 0x5d, 0xee, 0xb1, 0x3d, 0xed, 0x41, 0xed, 0x3e,
+	0x26, 0xd4, 0xe8, 0x7b, 0xdc, 0xa1, 0x7a, 0x2d, 0x6a, 0x74, 0xe4, 0x61, 0xa2, 0xb5, 0x31, 0x31,
+	0x7d, 0xdb, 0xa3, 0xae, 0x1f, 0x82, 0x95, 0xef, 0x69, 0x58, 0x79, 0x16, 0x10, 0x40, 0x08, 0xb2,
+	0x8e, 0xd1, 0xc7, 0x92, 0x50, 0x14, 0x4a, 0xeb, 0x3a, 0xb3, 0xd1, 0x53, 0x10, 0x7b, 0x46, 0x0b,
+	0xf7, 0x88, 0x94, 0x2e, 0x66, 0x4a, 0xb9, 0xca, 0x3d, 0xf5, 0x97, 0x02, 0xa8, 0x2c, 0x92, 0x7a,
+	0xc4, 0x20, 0x07, 0x0e, 0xf5, 0x47, 0x3a, 0xc7, 0xa3, 0x3d, 0x10, 0xa9, 0xe1, 0x5b, 0x98, 0x4a,
+	0x99, 0xa2, 0x50, 0xca, 0x55, 0xfe, 0x8f, 0x47, 0x62, 0xb5, 0xa9, 0x8d, 0x9f, 0xb5, 0xd5, 0xb2,
+	0x17, 0x5f, 0xb6, 0x53, 0x3a, 0x47, 0xa0, 0x3a, 0x80, 0xe9, 0x63, 0x83, 0xe2, 0xf6, 0xa9, 0x41,
+	0xa5, 0x55, 0x86, 0x97, 0xd5, 0x50, 0x16, 0x35, 0x92, 0x45, 0x3d, 0x89, 0x64, 0xa9, 0xad, 0x05,
+	0xe8, 0x0f, 0x5f, 0xb7, 0x05, 0x7d, 0x9d, 0xe3, 0xf6, 0x59, 0x90, 0x81, 0xd7, 0x8e, 0x82, 0xac,
+	0x2d, 0x12, 0x84, 0xe3, 0xf6, 0xa9, 0xfc, 0x00, 0x72, 0x31, 0x72, 0x68, 0x03, 0x32, 0x5d, 0x3c,
+	0xe2, 0x8a, 0x05, 0x26, 0xda, 0x82, 0x95, 0xa1, 0xd1, 0x1b, 0x60, 0x29, 0xcd, 0xee, 0xc2, 0xc3,
+	0x5e, 0xfa, 0xbe, 0xa0, 0xdc, 0x86, 0xbf, 0x0f, 0x31, 0x65, 0x02, 0xe9, 0xf8, 0xdd, 0x00, 0x13,
+	0x3a, 0x4f, 0x71, 0xe5, 0x18, 0x36, 0xae, 0xdc, 0x88, 0xe7, 0x3a, 0x04, 0xa3, 0x3d, 0x58, 0x61,
+	0x12, 0x33, 0xc7, 0x5c, 0x65, 0xe7, 0x3a, 0x4d, 0xd0, 0x43, 0x88, 0xf2, 0x0a, 0x50, 0x9d, 0x69,
+	0x30, 0x91, 0xf9, 0xf1, 0x0d, 0x22, 0xf2, 0xa6, 0xf0, 0xb8, 0xaf, 0x61, 0x73, 0x22, 0x2e, 0x2f,
+	0xf5, 0xf7, 0x03, 0x7f, 0x14, 0x00, 0xbd, 0x64, 0x82, 0x2f, 0xb7, 0x62, 0x54, 0x85, 0x5c, 0xd8,
+	0x48, 0x36, 0x5c, 0xac, 0x41, 0xf3, 0x5e, 0xc0, 0x93, 0x60, 0xfe, 0x9e, 0x1b, 0xa4, 0xab, 0xf3,
+	0xf7, 0x12, 0xd8, 0x01, 0xdd, 0x89, 0xa2, 0x96, 0x46, 0xf7, 0x2e, 0xfc, 0x73, 0x64, 0x93, 0xb0,
+	0xe1, 0x24, 0x22, 0x2b, 0xc1, 0x6a, 0xc7, 0xee, 0x51, 0xec, 0x13, 0x49, 0x28, 0x66, 0x4a, 0xeb,
+	0x7a, 0x74, 0x54, 0x9a, 0x80, 0xe2, 0xee, 0xbc, 0x8c, 0x1a, 0x88, 0x61, 0x12, 0xe6, 0xbe, 0x58,
+	0x1d, 0x1c, 0xa9, 0x3c, 0x04, 0xd4, 0xc0, 0x3d, 0x3c, 0x25, 0xfb, 0xbc, 0xa5, 0x80, 0x20, 0x4b,
+	0x46, 0x8e, 0xc9, 0x14, 0x5c, 0xd3, 0x99, 0xad, 0x9c, 0x40, 0xbe, 0xee, 0x8f, 0x3c, 0xea, 0xd6,
+	0x5d, 0xa7, 0x63, 0x5b, 0xa8, 0x00, 0xe0, 0x63, 0xd3, 0xf6, 0x6c, 0xec, 0xd0, 0x88, 0x44, 0xec,
+	0x06, 0xed, 0xc0, 0x5f, 0x96, 0x67, 0x79, 0x83, 0x56, 0x17, 0x8f, 0x7c, 0xdb, 0xb1, 0x58, 0xb0,
+	0xbc, 0x3e, 0x79, 0xa9, 0x9c, 0x0b, 0xb0, 0x79, 0xe0, 0x98, 0x41, 0xe0, 0xc4, 0xaa, 0x24, 0x58,
+	0x75, 0xf0, 0xd9, 0x71, 0x70, 0x1d, 0xce, 0x5e, 0x74, 0x44, 0x55, 0x48, 0x9b, 0x26, 0x5f, 0x3b,
+	0x77, 0x12, 0x94, 0x89, 0x93, 0xd0, 0xd3, 0xa6, 0xa9, 0x34, 0x61, 0x6b, 0xb2, 0x82, 0xa5, 0x75,
+	0x3e, 0x20, 0xd7, 0xc0, 0x7f, 0x9a, 0xdc, 0x64, 0x05, 0xcb, 0x22, 0x57, 0x79, 0x2f, 0x82, 0x18,
+	0x3e, 0x52, 0xd4, 0x81, 0xcc, 0x21, 0xa6, 0x48, 0x4d, 0x08, 0x32, 0xb5, 0x1c, 0x65, 0xed, 0xda,
+	0xfe, 0xbc, 0xe8, 0x2e, 0x64, 0x83, 0xd1, 0x40, 0x49, 0xff, 0x51, 0x33, 0xe3, 0x26, 0x97, 0x17,
+	0x40, 0xf0, 0x64, 0x2e, 0x88, 0xe1, 0xfa, 0x43, 0xe5, 0x44, 0xd1, 0xa7, 0xb7, 0xaf, 0x5c, 0x59,
+	0x04, 0x72, 0x95, 0x30, 0x5c, 0x40, 0x89, 0x09, 0x67, 0x97, 0x67, 0x62, 0xc2, 0x79, 0xab, 0xed,
+	0x05, 0x88, 0xe1, 0x3e, 0x48, 0x4c, 0x38, 0xbb, 0x36, 0xe4, 0x7f, 0x67, 0xd6, 0xea, 0x41, 0xf0,
+	0xcd, 0x83, 0xce, 0x20, 0x1f, 0x9f, 0x26, 0x94, 0x54, 0xd8, 0x9c, 0xe1, 0x97, 0x77, 0x17, 0xc2,
+	0x70, 0x36, 0x67, 0x90, 0x8f, 0xbf, 0xf4, 0xc4, 0xc4, 0x73, 0x06, 0x33, 0x31, 0xf1, 0xbc, 0x51,
+	0xaa, 0x35, 0x2f, 0x2e, 0x0b, 0xa9, 0xcf, 0x97, 0x85, 0xd4, 0xf9, 0xb8, 0x20, 0x5c, 0x8c, 0x0b,
+	0xc2, 0xa7, 0x71, 0x41, 0xf8, 0x36, 0x2e, 0x08, 0x6f, 0x1e, 0xdd, 0xf0, 0x8b, 0xb4, 0x1a, 0x5a,
+	0xcd, 0x54, 0x4b, 0x64, 0xea, 0xee, 0xfe, 0x08, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x31, 0x33, 0xc6,
+	0xdc, 0x0a, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 721028c..e8f7fd6 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -42,6 +42,8 @@ service Images {
 
 	// Encyrpt an image given its name
 	rpc EncryptImage(EncryptImageRequest) returns (EncryptImageResponse);
+	// Decyrpt an image given its name
+	rpc DecryptImage(DecryptImageRequest) returns (DecryptImageResponse);
 }
 
 message Image {
@@ -126,7 +128,8 @@ message DeleteImageRequest {
 	bool sync = 2;
 }
 
-message EncryptConfig {
+// CryptConfig serves to pass keys used for encryption and decryption
+message CryptoConfig {
 	repeated string recipients = 1;
 	bytes gpgpubkeyring = 2;
 }
@@ -135,10 +138,21 @@ message EncryptImageRequest {
 	string name = 1;
 	string newName = 2;
 
-	EncryptConfig ec = 3;
+	CryptoConfig cc = 3;
 }
 
 message EncryptImageResponse {
 	Image image = 1 [(gogoproto.nullable) = false];
 }
 
+message DecryptImageRequest {
+	string name = 1;
+	string newName = 2;
+
+	CryptoConfig cc = 3;
+}
+
+message DecryptImageResponse {
+	Image image = 1 [(gogoproto.nullable) = false];
+}
+
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 6b82f45..8c2bcbb 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -55,12 +55,11 @@ var encryptCommand = cli.Command{
 			return err
 		}
 		defer cancel()
-		img, err := client.ImageService().Get(ctx, local)
-		if err != nil {
-			return errors.Wrap(err, "unable to resolve image to manifest")
-		}
+		//img, err := client.ImageService().Get(ctx, local)
+		//if err != nil {
+		//	return errors.Wrap(err, "unable to resolve image to manifest")
+		//}
 
-		var ec *images.EncryptConfig
 		recipients := context.StringSlice("recipient")
 		if len(recipients) == 0 {
 			return errors.New("no recipients given -- nothing to do")			
@@ -70,11 +69,11 @@ var encryptCommand = cli.Command{
 		if err != nil {
 			return err
 		}
-		ec = &images.EncryptConfig{
+		cc := &images.CryptoConfig{
 			GPGPubRingFile: gpgPubRingFile,
 			Recipients:     recipients,
 		}
-		img, err = client.ImageService().EncryptImage(ctx, local, newName, ec)
+		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc)
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index ff3925b..396ad81 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -94,17 +94,16 @@ var pushCommand = cli.Command{
 			desc = img.Target
 		}
 
-		var ec *images.EncryptConfig
 		if recipients := context.StringSlice("recipient"); len(recipients) > 0 {
 			gpgPubRingFile, err := images.ReadGPGPubRingFile()
 			if err != nil {
 				return err
 			}
-			ec = &images.EncryptConfig{
+			cc := &images.CryptoConfig{
 				GPGPubRingFile: gpgPubRingFile,
 				Recipients:     recipients,
 			}
-			img, err := client.ImageService().EncryptImage(ctx, local, local, ec)
+			img, err := client.ImageService().EncryptImage(ctx, local, local, cc)
 			if err != nil {
 				return err
 			}
diff --git a/image_store.go b/image_store.go
index b2162db..1920714 100644
--- a/image_store.go
+++ b/image_store.go
@@ -50,12 +50,12 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, ec *images.EncryptConfig) (images.Image, error) {
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, ec *images.CryptoConfig) (images.Image, error) {
 	fmt.Printf("image_store.go: EncryptImage() name=%s\n", name);
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
-		Ec:      &imagesapi.EncryptConfig{
+		Cc:      &imagesapi.CryptoConfig{
 			Recipients   : ec.Recipients,
 			Gpgpubkeyring: ec.GPGPubRingFile,
 		},
@@ -67,6 +67,22 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, e
 	return imageFromProto(&resp.Image), nil
 }
 
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, ec *images.CryptoConfig) (images.Image, error) {
+	fmt.Printf("image_store.go: DecryptImage() name=%s\n", name);
+	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
+		Name:    name,
+		NewName: newName,
+		Cc:      &imagesapi.CryptoConfig{
+			// FIXME: missing parameters here
+		},
+	});
+	if err != nil {
+		return images.Image{}, errdefs.FromGRPC(err)
+	}
+
+	return imageFromProto(&resp.Image), nil
+}
+
 func (s *remoteImages) List(ctx context.Context, filters ...string) ([]images.Image, error) {
 	resp, err := s.client.List(ctx, &imagesapi.ListImagesRequest{
 		Filters: filters,
diff --git a/images/encryption.go b/images/encryption.go
index 32017a2..d32a81a 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -29,7 +29,7 @@ import (
 // EncryptConfig is the container image PGP encryption configuration holding
 // the identifiers of those that will be able to decrypt the container and
 // the PGP public keyring file data that contains their public keys.
-type EncryptConfig struct {
+type CryptoConfig struct {
        Recipients     []string
        GPGPubRingFile []byte
 }
@@ -52,8 +52,8 @@ func ReadGPGPubRingFile() ([]byte, error) {
 
 // createEntityList creates the opengpg EntityList by reading the KeyRing
 // first and then filtering out recipients' keys
-func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
-	r := bytes.NewReader(ec.GPGPubRingFile)
+func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
+	r := bytes.NewReader(cc.GPGPubRingFile)
 
 	entityList, err := openpgp.ReadKeyRing(r)
 	if err != nil {
@@ -61,7 +61,7 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 	}
 
 	rSet := make(map[string]int)
-	for _, r := range ec.Recipients {
+	for _, r := range cc.Recipients {
 		rSet[r] = 0
 	}
 
@@ -73,7 +73,7 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 			if err != nil {
 				return nil, err
 			}
-			for _, r := range ec.Recipients {
+			for _, r := range cc.Recipients {
 				if strings.Compare(addr.Name, r) == 0 || strings.Compare(addr.Address, r) == 0 {
 					fmt.Printf(" TAKING key of %s\n", k)
 					filteredList = append(filteredList, entity)
@@ -106,8 +106,8 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 }
 
 // Encrypt encrypts a byte array using data from the EncryptConfig
-func Encrypt(ec *EncryptConfig, data []byte) ([]byte, error) {
-	filteredList, err := createEntityList(ec)
+func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
+	filteredList, err := createEntityList(cc)
 	if err != nil {
 		return nil, err
 	}
@@ -131,3 +131,9 @@ func Encrypt(ec *EncryptConfig, data []byte) ([]byte, error) {
 	return ioutil.ReadAll(buf)
 }
 
+// Decrypt decrypts a byte array using data from the EncryptConfig
+func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
+	// nothing here for now...
+	return data, nil
+}
+
diff --git a/images/image.go b/images/image.go
index 94d7358..6462040 100644
--- a/images/image.go
+++ b/images/image.go
@@ -88,7 +88,8 @@ type Store interface {
 
 	Delete(ctx context.Context, name string, opts ...DeleteOpt) error
 
-	EncryptImage(ctx context.Context, name, newName string, ec *EncryptConfig) (Image, error)
+	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
+	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -324,15 +325,20 @@ func Check(ctx context.Context, provider content.Provider, image ocispec.Descrip
 }
 
 // encryptLayer encryts a single layer and writes the encrypted layer back into storage
-func encryptLayer(ctx context.Context, provider content.Store, desc ocispec.Descriptor, ec *EncryptConfig) (ocispec.Descriptor, error) {
-	plain, err := content.ReadBlob(ctx, provider, desc);
+func cryptLayer(ctx context.Context, provider content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
+	data, err := content.ReadBlob(ctx, provider, desc);
 	if err != nil {
 		return ocispec.Descriptor{}, err
 	}
 	//fmt.Printf("   ... read %d bytes of layer %s data\n", len(p), desc.Digest)
 	// now we should encrypt
 
-	p, err := Encrypt(ec, plain)
+	var p []byte
+	if encrypt {
+		p, err = Encrypt(cc, data)
+	} else {
+		p, err = Decrypt(cc, data)
+	}
 	if err != nil {
 		return ocispec.Descriptor{}, err
 	}
@@ -340,32 +346,36 @@ func encryptLayer(ctx context.Context, provider content.Store, desc ocispec.Desc
 	size := int64(len(p))
 	d := digest.FromBytes(p)
 
-	encDesc := ocispec.Descriptor{
+	newDesc := ocispec.Descriptor{
 		Digest:   d,
 		Size:     size,
 		Platform: desc.Platform,
 	}
-	encDesc.Annotations = make(map[string]string)
-	encDesc.Annotations["org.opencontainers.image.pgp.keys"] = "foo-bar"
+	newDesc.Annotations = make(map[string]string)
+	newDesc.Annotations["org.opencontainers.image.pgp.keys"] = "foo-bar"
 
 	switch (desc.MediaType) {
 	case MediaTypeDockerSchema2LayerGzip:
-		encDesc.MediaType = MediaTypeDockerSchema2LayerGzipPGP
+		newDesc.MediaType = MediaTypeDockerSchema2LayerGzipPGP
+	case MediaTypeDockerSchema2LayerGzipPGP:
+		newDesc.MediaType = MediaTypeDockerSchema2LayerGzip
 	case MediaTypeDockerSchema2Layer:
-		encDesc.MediaType = MediaTypeDockerSchema2LayerPGP
+		newDesc.MediaType = MediaTypeDockerSchema2LayerPGP
+	case MediaTypeDockerSchema2LayerPGP:
+		newDesc.MediaType = MediaTypeDockerSchema2Layer
 	default:
 		return ocispec.Descriptor{}, fmt.Errorf("Unsupporter layer MediaType: %s\n", desc.MediaType)
 	}
 
 	fmt.Printf("   ... writing layer %s in encrypted form as %s\n", desc.Digest, d)
-	ref := fmt.Sprintf("layer-%s", encDesc.Digest.String())
-	content.WriteBlob(ctx, provider, ref, bytes.NewReader(p), encDesc);
+	ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
+	content.WriteBlob(ctx, provider, ref, bytes.NewReader(p), newDesc);
 
-	return encDesc, nil
+	return newDesc, nil
 }
 
 // Encrypt all the Children of a given descriptor
-func encryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, ec *EncryptConfig) (ocispec.Descriptor, bool, error) {
+func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, bool, error) {
 	//fmt.Printf("metadata/image.go EncryptChildren(): Getting Children of %s [%s]\n", desc.MediaType, desc.Digest)
 	children, err := Children(ctx, cs, desc)
 	if err != nil {
@@ -383,19 +393,36 @@ func encryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descrip
 		case MediaTypeDockerSchema2Config:
 			config = child
 		case MediaTypeDockerSchema2LayerGzip,MediaTypeDockerSchema2Layer:
-			//fmt.Printf("   ... a layer to encrypt\n")
-			nl, err := encryptLayer(ctx, cs, child, ec)
-			if err != nil {
-				return ocispec.Descriptor{}, false, err
+			// this one we can only encrypt
+			if encrypt {
+				//fmt.Printf("   ... a layer to encrypt\n")
+				nl, err := cryptLayer(ctx, cs, child, cc, true)
+				if err != nil {
+					return ocispec.Descriptor{}, false, err
+				}
+				modified = true
+				newLayers = append(newLayers, nl)
+			} else {
+				newLayers = append(newLayers, child)
+			}
+		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
+			// this one we can only decrypt
+			if !encrypt {
+				nl, err := cryptLayer(ctx, cs, child, cc, false)
+				if err != nil {
+					return ocispec.Descriptor{}, false, err
+				}
+				modified = true
+				newLayers = append(newLayers, nl)
+			} else {
+				newLayers = append(newLayers, child)
 			}
-			modified = true
-			newLayers = append(newLayers, nl)
 		default:
 			return ocispec.Descriptor{}, false, fmt.Errorf("Bad/unhandled MediaType %s in encryptChildren\n", child.MediaType)
 		}
 	}
 
-	if len(newLayers) > 0 {
+	if modified && len(newLayers) > 0 {
 		nM := ocispec.Manifest {
 			Versioned: specs.Versioned{
 				SchemaVersion: 2,
@@ -434,8 +461,8 @@ func encryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descrip
 	return ocispec.Descriptor{}, modified, nil
 }
 
-// EncryptChildren encrypts the children of a top level manifest list
-func EncryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, ec *EncryptConfig) (ocispec.Descriptor, bool, error) {
+// cryptManifestList encrypts or decrypts the children of a top level manifest list
+func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, bool, error) {
 	if desc.MediaType != MediaTypeDockerSchema2ManifestList {
 		return ocispec.Descriptor{}, false, fmt.Errorf("Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
 	}
@@ -453,7 +480,7 @@ func EncryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descrip
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
-		newManifest, m, err := encryptChildren(ctx, cs, manifest, ec)
+		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, encrypt)
 		if err != nil {
 			return ocispec.Descriptor{}, false, err
 		}
@@ -496,7 +523,6 @@ func EncryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descrip
 	return desc, false, nil
 }
 
-
 // Children returns the immediate children of content described by the descriptor.
 func Children(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
 	var descs []ocispec.Descriptor
diff --git a/metadata/images.go b/metadata/images.go
index 0687ba9..7e52fd9 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -77,7 +77,9 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 	return image, nil
 }
 
-func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec *images.EncryptConfig) (images.Image, error) {
+// cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
+// or updates the existing one
+func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, encrypt bool) (images.Image, error) {
 	fmt.Printf("metadata/images.go: EncryptImage() name=%s\n", name)
 	var image images.Image
 
@@ -110,7 +112,8 @@ func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec
 	cs := s.db.ContentStore()
 	fmt.Printf("metadata/images.go: cs = %v\n",cs)
 	fmt.Printf("  high level image.Target is of MediaType %s\n", image.Target.MediaType)
-	newSpec, modified, err := images.EncryptChildren(ctx, cs, image.Target, ec)
+	
+	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, encrypt)
 	if err != nil {
 		return image, err
 	}
@@ -184,7 +187,14 @@ func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, ec
 	fmt.Printf("updated spec: %v, modified: %v\n", newSpec, modified)
 
 	return image, nil
+}
+
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, true)
+}
 
+func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, false)
 }
 
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
diff --git a/services/images/local.go b/services/images/local.go
index 2de54c8..85d00f0 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -186,9 +186,32 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 
 	var resp       imagesapi.EncryptImageResponse
 
-	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.EncryptConfig{
-		Recipients: req.Ec.Recipients,
-		GPGPubRingFile: req.Ec.Gpgpubkeyring,
+	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
+		Recipients: req.Cc.Recipients,
+		GPGPubRingFile: req.Cc.Gpgpubkeyring,
+	})
+	if err != nil {
+		return nil, errdefs.ToGRPC(err)
+	}
+	resp.Image = imageToProto(&encrypted)
+
+	if err := l.publisher.Publish(ctx, "/images/update", &eventstypes.ImageUpdate{
+		Name:   resp.Image.Name,
+		Labels: resp.Image.Labels,
+	}); err != nil {
+		return nil, err
+	}
+
+	return &resp, nil
+}
+
+func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest, _ ...grpc.CallOption) (*imagesapi.DecryptImageResponse, error) {
+	log.G(ctx).WithField("name", req.Name).Debugf("decrypt image")
+
+	var resp       imagesapi.DecryptImageResponse
+
+	encrypted, err := l.store.DecryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
+		// FIXME: missing parameters here
 	})
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
diff --git a/services/images/service.go b/services/images/service.go
index 5e071cc..5c40e0a 100644
--- a/services/images/service.go
+++ b/services/images/service.go
@@ -86,3 +86,7 @@ func (s *service) Delete(ctx context.Context, req *imagesapi.DeleteImageRequest)
 func (s *service) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageRequest) (*imagesapi.EncryptImageResponse, error) {
 	return s.local.EncryptImage(ctx, req)
 }
+
+func (s *service) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest) (*imagesapi.DecryptImageResponse, error) {
+	return s.local.DecryptImage(ctx, req)
+}
-- 
2.7.4


From c39b9ade02ef2c207a33f15836f79792ffad7404 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 14:30:26 -0400
Subject: [PATCH 08/79] Add API call GetImageKeyIds() to get the key Ids of an
 image

---
 api/next.pb.txt                     |  25 ++
 api/services/images/v1/images.pb.go | 455 +++++++++++++++++++++++++++++++-----
 api/services/images/v1/images.proto |  10 +
 image_store.go                      |  12 +
 images/encryption.go                |   8 +-
 images/image.go                     |  31 +++
 metadata/images.go                  |  36 ++-
 services/images/local.go            |  16 ++
 services/images/service.go          |   4 +
 9 files changed, 543 insertions(+), 54 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 69bf042..ab58d3a 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2313,6 +2313,26 @@ file {
       json_name: "image"
     }
   }
+  message_type {
+    name: "GetImageKeyIdsRequest"
+    field {
+      name: "name"
+      number: 1
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "name"
+    }
+  }
+  message_type {
+    name: "GetImageKeyIdsResponse"
+    field {
+      name: "keyids"
+      number: 1
+      label: LABEL_REPEATED
+      type: TYPE_UINT64
+      json_name: "keyids"
+    }
+  }
   service {
     name: "Images"
     method {
@@ -2350,6 +2370,11 @@ file {
       input_type: ".containerd.services.images.v1.DecryptImageRequest"
       output_type: ".containerd.services.images.v1.DecryptImageResponse"
     }
+    method {
+      name: "GetImageKeyIds"
+      input_type: ".containerd.services.images.v1.GetImageKeyIdsRequest"
+      output_type: ".containerd.services.images.v1.GetImageKeyIdsResponse"
+    }
   }
   options {
     go_package: "github.com/containerd/containerd/api/services/images/v1;images"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index d51f0f4..f73aa37 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -23,6 +23,8 @@
 		EncryptImageResponse
 		DecryptImageRequest
 		DecryptImageResponse
+		GetImageKeyIdsRequest
+		GetImageKeyIdsResponse
 */
 package images
 
@@ -223,6 +225,22 @@ func (m *DecryptImageResponse) Reset()                    { *m = DecryptImageRes
 func (*DecryptImageResponse) ProtoMessage()               {}
 func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
 
+type GetImageKeyIdsRequest struct {
+	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+}
+
+func (m *GetImageKeyIdsRequest) Reset()                    { *m = GetImageKeyIdsRequest{} }
+func (*GetImageKeyIdsRequest) ProtoMessage()               {}
+func (*GetImageKeyIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
+
+type GetImageKeyIdsResponse struct {
+	Keyids []uint64 `protobuf:"varint,1,rep,packed,name=keyids" json:"keyids,omitempty"`
+}
+
+func (m *GetImageKeyIdsResponse) Reset()                    { *m = GetImageKeyIdsResponse{} }
+func (*GetImageKeyIdsResponse) ProtoMessage()               {}
+func (*GetImageKeyIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
+
 func init() {
 	proto.RegisterType((*Image)(nil), "containerd.services.images.v1.Image")
 	proto.RegisterType((*GetImageRequest)(nil), "containerd.services.images.v1.GetImageRequest")
@@ -239,6 +257,8 @@ func init() {
 	proto.RegisterType((*EncryptImageResponse)(nil), "containerd.services.images.v1.EncryptImageResponse")
 	proto.RegisterType((*DecryptImageRequest)(nil), "containerd.services.images.v1.DecryptImageRequest")
 	proto.RegisterType((*DecryptImageResponse)(nil), "containerd.services.images.v1.DecryptImageResponse")
+	proto.RegisterType((*GetImageKeyIdsRequest)(nil), "containerd.services.images.v1.GetImageKeyIdsRequest")
+	proto.RegisterType((*GetImageKeyIdsResponse)(nil), "containerd.services.images.v1.GetImageKeyIdsResponse")
 }
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -269,6 +289,8 @@ type ImagesClient interface {
 	EncryptImage(ctx context.Context, in *EncryptImageRequest, opts ...grpc.CallOption) (*EncryptImageResponse, error)
 	// Decyrpt an image given its name
 	DecryptImage(ctx context.Context, in *DecryptImageRequest, opts ...grpc.CallOption) (*DecryptImageResponse, error)
+	// Get the KeyIds of keys the image is encrypted with
+	GetImageKeyIds(ctx context.Context, in *GetImageKeyIdsRequest, opts ...grpc.CallOption) (*GetImageKeyIdsResponse, error)
 }
 
 type imagesClient struct {
@@ -342,6 +364,15 @@ func (c *imagesClient) DecryptImage(ctx context.Context, in *DecryptImageRequest
 	return out, nil
 }
 
+func (c *imagesClient) GetImageKeyIds(ctx context.Context, in *GetImageKeyIdsRequest, opts ...grpc.CallOption) (*GetImageKeyIdsResponse, error) {
+	out := new(GetImageKeyIdsResponse)
+	err := grpc.Invoke(ctx, "/containerd.services.images.v1.Images/GetImageKeyIds", in, out, c.cc, opts...)
+	if err != nil {
+		return nil, err
+	}
+	return out, nil
+}
+
 // Server API for Images service
 
 type ImagesServer interface {
@@ -362,6 +393,8 @@ type ImagesServer interface {
 	EncryptImage(context.Context, *EncryptImageRequest) (*EncryptImageResponse, error)
 	// Decyrpt an image given its name
 	DecryptImage(context.Context, *DecryptImageRequest) (*DecryptImageResponse, error)
+	// Get the KeyIds of keys the image is encrypted with
+	GetImageKeyIds(context.Context, *GetImageKeyIdsRequest) (*GetImageKeyIdsResponse, error)
 }
 
 func RegisterImagesServer(s *grpc.Server, srv ImagesServer) {
@@ -494,6 +527,24 @@ func _Images_DecryptImage_Handler(srv interface{}, ctx context.Context, dec func
 	return interceptor(ctx, in, info, handler)
 }
 
+func _Images_GetImageKeyIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(GetImageKeyIdsRequest)
+	if err := dec(in); err != nil {
+		return nil, err
+	}
+	if interceptor == nil {
+		return srv.(ImagesServer).GetImageKeyIds(ctx, in)
+	}
+	info := &grpc.UnaryServerInfo{
+		Server:     srv,
+		FullMethod: "/containerd.services.images.v1.Images/GetImageKeyIds",
+	}
+	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
+		return srv.(ImagesServer).GetImageKeyIds(ctx, req.(*GetImageKeyIdsRequest))
+	}
+	return interceptor(ctx, in, info, handler)
+}
+
 var _Images_serviceDesc = grpc.ServiceDesc{
 	ServiceName: "containerd.services.images.v1.Images",
 	HandlerType: (*ImagesServer)(nil),
@@ -526,6 +577,10 @@ var _Images_serviceDesc = grpc.ServiceDesc{
 			MethodName: "DecryptImage",
 			Handler:    _Images_DecryptImage_Handler,
 		},
+		{
+			MethodName: "GetImageKeyIds",
+			Handler:    _Images_GetImageKeyIds_Handler,
+		},
 	},
 	Streams:  []grpc.StreamDesc{},
 	Metadata: "github.com/containerd/containerd/api/services/images/v1/images.proto",
@@ -1030,6 +1085,65 @@ func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
+func (m *GetImageKeyIdsRequest) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *GetImageKeyIdsRequest) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Name) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Name)))
+		i += copy(dAtA[i:], m.Name)
+	}
+	return i, nil
+}
+
+func (m *GetImageKeyIdsResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *GetImageKeyIdsResponse) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.Keyids) > 0 {
+		dAtA15 := make([]byte, len(m.Keyids)*10)
+		var j14 int
+		for _, num := range m.Keyids {
+			for num >= 1<<7 {
+				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j14++
+			}
+			dAtA15[j14] = uint8(num)
+			j14++
+		}
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(j14))
+		i += copy(dAtA[i:], dAtA15[:j14])
+	}
+	return i, nil
+}
+
 func encodeVarintImages(dAtA []byte, offset int, v uint64) int {
 	for v >= 1<<7 {
 		dAtA[offset] = uint8(v&0x7f | 0x80)
@@ -1224,6 +1338,29 @@ func (m *DecryptImageResponse) Size() (n int) {
 	return n
 }
 
+func (m *GetImageKeyIdsRequest) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.Name)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	return n
+}
+
+func (m *GetImageKeyIdsResponse) Size() (n int) {
+	var l int
+	_ = l
+	if len(m.Keyids) > 0 {
+		l = 0
+		for _, e := range m.Keyids {
+			l += sovImages(uint64(e))
+		}
+		n += 1 + sovImages(uint64(l)) + l
+	}
+	return n
+}
+
 func sovImages(x uint64) (n int) {
 	for {
 		n++
@@ -1408,6 +1545,26 @@ func (this *DecryptImageResponse) String() string {
 	}, "")
 	return s
 }
+func (this *GetImageKeyIdsRequest) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&GetImageKeyIdsRequest{`,
+		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
+		`}`,
+	}, "")
+	return s
+}
+func (this *GetImageKeyIdsResponse) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&GetImageKeyIdsResponse{`,
+		`Keyids:` + fmt.Sprintf("%v", this.Keyids) + `,`,
+		`}`,
+	}, "")
+	return s
+}
 func valueToStringImages(v interface{}) string {
 	rv := reflect.ValueOf(v)
 	if rv.IsNil() {
@@ -3029,6 +3186,197 @@ func (m *DecryptImageResponse) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *GetImageKeyIdsRequest) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: GetImageKeyIdsRequest: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: GetImageKeyIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Name = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *GetImageKeyIdsResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: GetImageKeyIdsResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: GetImageKeyIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType == 0 {
+				var v uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				m.Keyids = append(m.Keyids, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= (int(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthImages
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				for iNdEx < postIndex {
+					var v uint64
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= (uint64(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Keyids = append(m.Keyids, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Keyids", wireType)
+			}
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func skipImages(dAtA []byte) (n int, err error) {
 	l := len(dAtA)
 	iNdEx := 0
@@ -3139,56 +3487,59 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 804 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcf, 0x6f, 0xd3, 0x4a,
-	0x10, 0x8e, 0x93, 0xd4, 0x6d, 0x27, 0x79, 0x7a, 0x7d, 0xdb, 0xea, 0xc9, 0xf2, 0x7b, 0xa4, 0x91,
-	0x55, 0xa4, 0x48, 0x08, 0x9b, 0xa4, 0x17, 0x68, 0x10, 0xa2, 0x49, 0x4a, 0x41, 0x2a, 0x3d, 0x98,
-	0x02, 0x11, 0x97, 0xca, 0x71, 0x36, 0xc6, 0x4a, 0x62, 0x1b, 0xef, 0x26, 0x55, 0x6e, 0x3d, 0x71,
-	0x46, 0xe2, 0x9f, 0xea, 0x91, 0x23, 0x27, 0xa0, 0x39, 0xf0, 0x77, 0x20, 0xaf, 0xd7, 0xd4, 0xf9,
-	0x21, 0xdc, 0x94, 0x48, 0xdc, 0x66, 0x37, 0xf3, 0xcd, 0xcc, 0xf7, 0xcd, 0xce, 0xc4, 0xd0, 0xb0,
-	0x6c, 0xfa, 0x76, 0xd0, 0x52, 0x4d, 0xb7, 0xaf, 0x99, 0xae, 0x43, 0x0d, 0xdb, 0xc1, 0x7e, 0x3b,
-	0x6e, 0x1a, 0x9e, 0xad, 0x11, 0xec, 0x0f, 0x6d, 0x13, 0x13, 0xcd, 0xee, 0x1b, 0x16, 0x26, 0xda,
-	0xb0, 0xcc, 0x2d, 0xd5, 0xf3, 0x5d, 0xea, 0xa2, 0x5b, 0x57, 0xfe, 0x6a, 0xe4, 0xab, 0x72, 0x8f,
-	0x61, 0x59, 0xde, 0xb2, 0x5c, 0xcb, 0x65, 0x9e, 0x5a, 0x60, 0x85, 0x20, 0xf9, 0x3f, 0xcb, 0x75,
-	0xad, 0x1e, 0xd6, 0xd8, 0xa9, 0x35, 0xe8, 0x68, 0xb8, 0xef, 0xd1, 0x11, 0xff, 0xb1, 0x38, 0xfd,
-	0x63, 0xc7, 0xc6, 0xbd, 0xf6, 0x69, 0xdf, 0x20, 0x5d, 0xee, 0xb1, 0x3d, 0xed, 0x41, 0xed, 0x3e,
-	0x26, 0xd4, 0xe8, 0x7b, 0xdc, 0xa1, 0x7a, 0x2d, 0x6a, 0x74, 0xe4, 0x61, 0xa2, 0xb5, 0x31, 0x31,
-	0x7d, 0xdb, 0xa3, 0xae, 0x1f, 0x82, 0x95, 0xef, 0x69, 0x58, 0x79, 0x16, 0x10, 0x40, 0x08, 0xb2,
-	0x8e, 0xd1, 0xc7, 0x92, 0x50, 0x14, 0x4a, 0xeb, 0x3a, 0xb3, 0xd1, 0x53, 0x10, 0x7b, 0x46, 0x0b,
-	0xf7, 0x88, 0x94, 0x2e, 0x66, 0x4a, 0xb9, 0xca, 0x3d, 0xf5, 0x97, 0x02, 0xa8, 0x2c, 0x92, 0x7a,
-	0xc4, 0x20, 0x07, 0x0e, 0xf5, 0x47, 0x3a, 0xc7, 0xa3, 0x3d, 0x10, 0xa9, 0xe1, 0x5b, 0x98, 0x4a,
-	0x99, 0xa2, 0x50, 0xca, 0x55, 0xfe, 0x8f, 0x47, 0x62, 0xb5, 0xa9, 0x8d, 0x9f, 0xb5, 0xd5, 0xb2,
-	0x17, 0x5f, 0xb6, 0x53, 0x3a, 0x47, 0xa0, 0x3a, 0x80, 0xe9, 0x63, 0x83, 0xe2, 0xf6, 0xa9, 0x41,
-	0xa5, 0x55, 0x86, 0x97, 0xd5, 0x50, 0x16, 0x35, 0x92, 0x45, 0x3d, 0x89, 0x64, 0xa9, 0xad, 0x05,
-	0xe8, 0x0f, 0x5f, 0xb7, 0x05, 0x7d, 0x9d, 0xe3, 0xf6, 0x59, 0x90, 0x81, 0xd7, 0x8e, 0x82, 0xac,
-	0x2d, 0x12, 0x84, 0xe3, 0xf6, 0xa9, 0xfc, 0x00, 0x72, 0x31, 0x72, 0x68, 0x03, 0x32, 0x5d, 0x3c,
-	0xe2, 0x8a, 0x05, 0x26, 0xda, 0x82, 0x95, 0xa1, 0xd1, 0x1b, 0x60, 0x29, 0xcd, 0xee, 0xc2, 0xc3,
-	0x5e, 0xfa, 0xbe, 0xa0, 0xdc, 0x86, 0xbf, 0x0f, 0x31, 0x65, 0x02, 0xe9, 0xf8, 0xdd, 0x00, 0x13,
-	0x3a, 0x4f, 0x71, 0xe5, 0x18, 0x36, 0xae, 0xdc, 0x88, 0xe7, 0x3a, 0x04, 0xa3, 0x3d, 0x58, 0x61,
-	0x12, 0x33, 0xc7, 0x5c, 0x65, 0xe7, 0x3a, 0x4d, 0xd0, 0x43, 0x88, 0xf2, 0x0a, 0x50, 0x9d, 0x69,
-	0x30, 0x91, 0xf9, 0xf1, 0x0d, 0x22, 0xf2, 0xa6, 0xf0, 0xb8, 0xaf, 0x61, 0x73, 0x22, 0x2e, 0x2f,
-	0xf5, 0xf7, 0x03, 0x7f, 0x14, 0x00, 0xbd, 0x64, 0x82, 0x2f, 0xb7, 0x62, 0x54, 0x85, 0x5c, 0xd8,
-	0x48, 0x36, 0x5c, 0xac, 0x41, 0xf3, 0x5e, 0xc0, 0x93, 0x60, 0xfe, 0x9e, 0x1b, 0xa4, 0xab, 0xf3,
-	0xf7, 0x12, 0xd8, 0x01, 0xdd, 0x89, 0xa2, 0x96, 0x46, 0xf7, 0x2e, 0xfc, 0x73, 0x64, 0x93, 0xb0,
-	0xe1, 0x24, 0x22, 0x2b, 0xc1, 0x6a, 0xc7, 0xee, 0x51, 0xec, 0x13, 0x49, 0x28, 0x66, 0x4a, 0xeb,
-	0x7a, 0x74, 0x54, 0x9a, 0x80, 0xe2, 0xee, 0xbc, 0x8c, 0x1a, 0x88, 0x61, 0x12, 0xe6, 0xbe, 0x58,
-	0x1d, 0x1c, 0xa9, 0x3c, 0x04, 0xd4, 0xc0, 0x3d, 0x3c, 0x25, 0xfb, 0xbc, 0xa5, 0x80, 0x20, 0x4b,
-	0x46, 0x8e, 0xc9, 0x14, 0x5c, 0xd3, 0x99, 0xad, 0x9c, 0x40, 0xbe, 0xee, 0x8f, 0x3c, 0xea, 0xd6,
-	0x5d, 0xa7, 0x63, 0x5b, 0xa8, 0x00, 0xe0, 0x63, 0xd3, 0xf6, 0x6c, 0xec, 0xd0, 0x88, 0x44, 0xec,
-	0x06, 0xed, 0xc0, 0x5f, 0x96, 0x67, 0x79, 0x83, 0x56, 0x17, 0x8f, 0x7c, 0xdb, 0xb1, 0x58, 0xb0,
-	0xbc, 0x3e, 0x79, 0xa9, 0x9c, 0x0b, 0xb0, 0x79, 0xe0, 0x98, 0x41, 0xe0, 0xc4, 0xaa, 0x24, 0x58,
-	0x75, 0xf0, 0xd9, 0x71, 0x70, 0x1d, 0xce, 0x5e, 0x74, 0x44, 0x55, 0x48, 0x9b, 0x26, 0x5f, 0x3b,
-	0x77, 0x12, 0x94, 0x89, 0x93, 0xd0, 0xd3, 0xa6, 0xa9, 0x34, 0x61, 0x6b, 0xb2, 0x82, 0xa5, 0x75,
-	0x3e, 0x20, 0xd7, 0xc0, 0x7f, 0x9a, 0xdc, 0x64, 0x05, 0xcb, 0x22, 0x57, 0x79, 0x2f, 0x82, 0x18,
-	0x3e, 0x52, 0xd4, 0x81, 0xcc, 0x21, 0xa6, 0x48, 0x4d, 0x08, 0x32, 0xb5, 0x1c, 0x65, 0xed, 0xda,
-	0xfe, 0xbc, 0xe8, 0x2e, 0x64, 0x83, 0xd1, 0x40, 0x49, 0xff, 0x51, 0x33, 0xe3, 0x26, 0x97, 0x17,
-	0x40, 0xf0, 0x64, 0x2e, 0x88, 0xe1, 0xfa, 0x43, 0xe5, 0x44, 0xd1, 0xa7, 0xb7, 0xaf, 0x5c, 0x59,
-	0x04, 0x72, 0x95, 0x30, 0x5c, 0x40, 0x89, 0x09, 0x67, 0x97, 0x67, 0x62, 0xc2, 0x79, 0xab, 0xed,
-	0x05, 0x88, 0xe1, 0x3e, 0x48, 0x4c, 0x38, 0xbb, 0x36, 0xe4, 0x7f, 0x67, 0xd6, 0xea, 0x41, 0xf0,
-	0xcd, 0x83, 0xce, 0x20, 0x1f, 0x9f, 0x26, 0x94, 0x54, 0xd8, 0x9c, 0xe1, 0x97, 0x77, 0x17, 0xc2,
-	0x70, 0x36, 0x67, 0x90, 0x8f, 0xbf, 0xf4, 0xc4, 0xc4, 0x73, 0x06, 0x33, 0x31, 0xf1, 0xbc, 0x51,
-	0xaa, 0x35, 0x2f, 0x2e, 0x0b, 0xa9, 0xcf, 0x97, 0x85, 0xd4, 0xf9, 0xb8, 0x20, 0x5c, 0x8c, 0x0b,
-	0xc2, 0xa7, 0x71, 0x41, 0xf8, 0x36, 0x2e, 0x08, 0x6f, 0x1e, 0xdd, 0xf0, 0x8b, 0xb4, 0x1a, 0x5a,
-	0xcd, 0x54, 0x4b, 0x64, 0xea, 0xee, 0xfe, 0x08, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x31, 0x33, 0xc6,
-	0xdc, 0x0a, 0x00, 0x00,
+	// 858 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x41, 0x8f, 0xdb, 0x54,
+	0x10, 0x5e, 0x27, 0x59, 0xef, 0xee, 0x64, 0x81, 0xf2, 0xba, 0xac, 0x2c, 0x03, 0xd9, 0xc8, 0x2a,
+	0xd2, 0x4a, 0x15, 0x76, 0x37, 0x05, 0x09, 0x76, 0x11, 0xa2, 0x49, 0x96, 0x52, 0x51, 0x7a, 0x30,
+	0x05, 0x22, 0x2e, 0x95, 0xe3, 0x4c, 0x8c, 0x95, 0xc4, 0x36, 0x7e, 0x2f, 0x59, 0xf9, 0x80, 0xd4,
+	0x0b, 0x77, 0x24, 0xfe, 0xd4, 0x1e, 0x39, 0x72, 0x02, 0x9a, 0x03, 0xbf, 0x03, 0xf9, 0xbd, 0x67,
+	0xd6, 0x4e, 0xa2, 0x3a, 0x29, 0x91, 0xb8, 0xcd, 0x7b, 0x99, 0x6f, 0xe6, 0x9b, 0x99, 0x37, 0x5f,
+	0x0c, 0x5d, 0xcf, 0x67, 0x3f, 0x4c, 0xfb, 0xa6, 0x1b, 0x4e, 0x2c, 0x37, 0x0c, 0x98, 0xe3, 0x07,
+	0x18, 0x0f, 0xf2, 0xa6, 0x13, 0xf9, 0x16, 0xc5, 0x78, 0xe6, 0xbb, 0x48, 0x2d, 0x7f, 0xe2, 0x78,
+	0x48, 0xad, 0xd9, 0x99, 0xb4, 0xcc, 0x28, 0x0e, 0x59, 0x48, 0xde, 0xbd, 0xf1, 0x37, 0x33, 0x5f,
+	0x53, 0x7a, 0xcc, 0xce, 0xf4, 0x23, 0x2f, 0xf4, 0x42, 0xee, 0x69, 0xa5, 0x96, 0x00, 0xe9, 0x6f,
+	0x7b, 0x61, 0xe8, 0x8d, 0xd1, 0xe2, 0xa7, 0xfe, 0x74, 0x68, 0xe1, 0x24, 0x62, 0x89, 0xfc, 0xb1,
+	0xb9, 0xf8, 0xe3, 0xd0, 0xc7, 0xf1, 0xe0, 0xd9, 0xc4, 0xa1, 0x23, 0xe9, 0x71, 0xb2, 0xe8, 0xc1,
+	0xfc, 0x09, 0x52, 0xe6, 0x4c, 0x22, 0xe9, 0x70, 0xb1, 0x56, 0x69, 0x2c, 0x89, 0x90, 0x5a, 0x03,
+	0xa4, 0x6e, 0xec, 0x47, 0x2c, 0x8c, 0x05, 0xd8, 0xf8, 0xbb, 0x02, 0xbb, 0x8f, 0xd2, 0x02, 0x08,
+	0x81, 0x5a, 0xe0, 0x4c, 0x50, 0x53, 0x9a, 0xca, 0xe9, 0x81, 0xcd, 0x6d, 0xf2, 0x05, 0xa8, 0x63,
+	0xa7, 0x8f, 0x63, 0xaa, 0x55, 0x9a, 0xd5, 0xd3, 0x7a, 0xeb, 0x9e, 0xf9, 0xd2, 0x06, 0x98, 0x3c,
+	0x92, 0xf9, 0x98, 0x43, 0x2e, 0x03, 0x16, 0x27, 0xb6, 0xc4, 0x93, 0x73, 0x50, 0x99, 0x13, 0x7b,
+	0xc8, 0xb4, 0x6a, 0x53, 0x39, 0xad, 0xb7, 0xde, 0xc9, 0x47, 0xe2, 0xdc, 0xcc, 0xee, 0xbf, 0xdc,
+	0xda, 0xb5, 0xeb, 0x3f, 0x4e, 0x76, 0x6c, 0x89, 0x20, 0x1d, 0x00, 0x37, 0x46, 0x87, 0xe1, 0xe0,
+	0x99, 0xc3, 0xb4, 0x3d, 0x8e, 0xd7, 0x4d, 0xd1, 0x16, 0x33, 0x6b, 0x8b, 0xf9, 0x34, 0x6b, 0x4b,
+	0x7b, 0x3f, 0x45, 0xff, 0xf2, 0xe7, 0x89, 0x62, 0x1f, 0x48, 0xdc, 0x03, 0x1e, 0x64, 0x1a, 0x0d,
+	0xb2, 0x20, 0xfb, 0x9b, 0x04, 0x91, 0xb8, 0x07, 0x4c, 0xff, 0x18, 0xea, 0xb9, 0xe2, 0xc8, 0x2d,
+	0xa8, 0x8e, 0x30, 0x91, 0x1d, 0x4b, 0x4d, 0x72, 0x04, 0xbb, 0x33, 0x67, 0x3c, 0x45, 0xad, 0xc2,
+	0xef, 0xc4, 0xe1, 0xbc, 0xf2, 0x91, 0x62, 0xbc, 0x07, 0x6f, 0x3c, 0x44, 0xc6, 0x1b, 0x64, 0xe3,
+	0x8f, 0x53, 0xa4, 0x6c, 0x55, 0xc7, 0x8d, 0x27, 0x70, 0xeb, 0xc6, 0x8d, 0x46, 0x61, 0x40, 0x91,
+	0x9c, 0xc3, 0x2e, 0x6f, 0x31, 0x77, 0xac, 0xb7, 0xee, 0xac, 0x33, 0x04, 0x5b, 0x40, 0x8c, 0x6f,
+	0x81, 0x74, 0x78, 0x0f, 0x0a, 0x99, 0x3f, 0x7b, 0x85, 0x88, 0x72, 0x28, 0x32, 0xee, 0x77, 0x70,
+	0xbb, 0x10, 0x57, 0x52, 0xfd, 0xef, 0x81, 0x7f, 0x55, 0x80, 0x7c, 0xc3, 0x1b, 0xbe, 0x5d, 0xc6,
+	0xe4, 0x02, 0xea, 0x62, 0x90, 0x7c, 0xb9, 0xf8, 0x80, 0x56, 0xbd, 0x80, 0xcf, 0xd3, 0xfd, 0xfb,
+	0xca, 0xa1, 0x23, 0x5b, 0xbe, 0x97, 0xd4, 0x4e, 0xcb, 0x2d, 0x90, 0xda, 0x5a, 0xb9, 0xef, 0xc3,
+	0x9b, 0x8f, 0x7d, 0x2a, 0x06, 0x4e, 0xb3, 0x62, 0x35, 0xd8, 0x1b, 0xfa, 0x63, 0x86, 0x31, 0xd5,
+	0x94, 0x66, 0xf5, 0xf4, 0xc0, 0xce, 0x8e, 0x46, 0x0f, 0x48, 0xde, 0x5d, 0xd2, 0x68, 0x83, 0x2a,
+	0x92, 0x70, 0xf7, 0xcd, 0x78, 0x48, 0xa4, 0xf1, 0x09, 0x90, 0x2e, 0x8e, 0x71, 0xa1, 0xed, 0xab,
+	0x44, 0x81, 0x40, 0x8d, 0x26, 0x81, 0xcb, 0x3b, 0xb8, 0x6f, 0x73, 0xdb, 0x78, 0x0a, 0x87, 0x9d,
+	0x38, 0x89, 0x58, 0xd8, 0x09, 0x83, 0xa1, 0xef, 0x91, 0x06, 0x40, 0x8c, 0xae, 0x1f, 0xf9, 0x18,
+	0xb0, 0xac, 0x88, 0xdc, 0x0d, 0xb9, 0x03, 0xaf, 0x79, 0x91, 0x17, 0x4d, 0xfb, 0x23, 0x4c, 0x62,
+	0x3f, 0xf0, 0x78, 0xb0, 0x43, 0xbb, 0x78, 0x69, 0x3c, 0x57, 0xe0, 0xf6, 0x65, 0xe0, 0xa6, 0x81,
+	0x4b, 0x59, 0x69, 0xb0, 0x17, 0xe0, 0xd5, 0x93, 0xf4, 0x5a, 0xec, 0x5e, 0x76, 0x24, 0x17, 0x50,
+	0x71, 0x5d, 0x29, 0x3b, 0x77, 0x4b, 0x3a, 0x93, 0x2f, 0xc2, 0xae, 0xb8, 0xae, 0xd1, 0x83, 0xa3,
+	0x22, 0x83, 0xad, 0x4d, 0x3e, 0x2d, 0xae, 0x8b, 0xff, 0x77, 0x71, 0x45, 0x06, 0x5b, 0x2b, 0xee,
+	0x2e, 0xbc, 0x95, 0xc9, 0xd8, 0x97, 0x98, 0x3c, 0x1a, 0xd0, 0x97, 0x69, 0xde, 0x3d, 0x38, 0x5e,
+	0x74, 0x96, 0x44, 0x8e, 0x41, 0x1d, 0x61, 0xe2, 0x0f, 0xc4, 0x13, 0xaa, 0xd9, 0xf2, 0xd4, 0xfa,
+	0x79, 0x0f, 0x54, 0xb1, 0x03, 0x64, 0x08, 0xd5, 0x87, 0xc8, 0x88, 0x59, 0xc2, 0x71, 0x41, 0x7b,
+	0x75, 0x6b, 0x6d, 0x7f, 0x49, 0x65, 0x04, 0xb5, 0x74, 0xf3, 0x48, 0xd9, 0x5f, 0xe0, 0xd2, 0x36,
+	0xeb, 0x67, 0x1b, 0x20, 0x64, 0xb2, 0x10, 0x54, 0xa1, 0xae, 0xe4, 0xac, 0x74, 0xa6, 0x8b, 0xe2,
+	0xae, 0xb7, 0x36, 0x81, 0xdc, 0x24, 0x14, 0xfa, 0x56, 0x9a, 0x70, 0x59, 0x9b, 0x4b, 0x13, 0xae,
+	0x52, 0xce, 0xaf, 0x41, 0x15, 0x72, 0x53, 0x9a, 0x70, 0x59, 0x95, 0xf4, 0xe3, 0x25, 0xd5, 0xbe,
+	0x4c, 0x3f, 0xa9, 0xc8, 0x15, 0x1c, 0xe6, 0x97, 0x95, 0x94, 0x11, 0x5b, 0xa1, 0x2d, 0xfa, 0xfd,
+	0x8d, 0x30, 0xb2, 0x9a, 0x2b, 0x38, 0xcc, 0x2f, 0x52, 0x69, 0xe2, 0x15, 0x7b, 0x5f, 0x9a, 0x78,
+	0xe5, 0xa6, 0xfe, 0x04, 0xaf, 0x17, 0x57, 0x87, 0x7c, 0xb0, 0xe6, 0xc3, 0x2e, 0xac, 0xa5, 0xfe,
+	0xe1, 0x86, 0x28, 0x91, 0xbe, 0xdd, 0xbb, 0x7e, 0xd1, 0xd8, 0xf9, 0xfd, 0x45, 0x63, 0xe7, 0xf9,
+	0xbc, 0xa1, 0x5c, 0xcf, 0x1b, 0xca, 0x6f, 0xf3, 0x86, 0xf2, 0xd7, 0xbc, 0xa1, 0x7c, 0xff, 0xe9,
+	0x2b, 0x7e, 0x6f, 0x5f, 0x08, 0xab, 0xb7, 0xd3, 0x57, 0xf9, 0x70, 0xef, 0xff, 0x13, 0x00, 0x00,
+	0xff, 0xff, 0x71, 0x2f, 0x2f, 0x99, 0xba, 0x0b, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index e8f7fd6..c0a0431 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -44,6 +44,8 @@ service Images {
 	rpc EncryptImage(EncryptImageRequest) returns (EncryptImageResponse);
 	// Decyrpt an image given its name
 	rpc DecryptImage(DecryptImageRequest) returns (DecryptImageResponse);
+	// Get the KeyIds of keys the image is encrypted with
+	rpc GetImageKeyIds(GetImageKeyIdsRequest) returns (GetImageKeyIdsResponse);
 }
 
 message Image {
@@ -156,3 +158,11 @@ message DecryptImageResponse {
 	Image image = 1 [(gogoproto.nullable) = false];
 }
 
+message GetImageKeyIdsRequest {
+	string name = 1;
+}
+
+message GetImageKeyIdsResponse {
+	repeated uint64 keyids = 1;
+}
+
diff --git a/image_store.go b/image_store.go
index 1920714..d6c9623 100644
--- a/image_store.go
+++ b/image_store.go
@@ -83,6 +83,18 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, e
 	return imageFromProto(&resp.Image), nil
 }
 
+func (s *remoteImages) GetImageKeyIds(ctx context.Context, name string) ([]uint64, error) {
+	fmt.Printf("image_store.go: GetImageKeyIds() name=%s\n", name);
+	resp, err := s.client.GetImageKeyIds(ctx, &imagesapi.GetImageKeyIdsRequest{
+		Name:    name,
+	});
+	if err != nil {
+		return []uint64{}, errdefs.FromGRPC(err)
+	}
+
+	return resp.Keyids, nil
+}
+
 func (s *remoteImages) List(ctx context.Context, filters ...string) ([]images.Image, error) {
 	resp, err := s.client.List(ctx, &imagesapi.ListImagesRequest{
 		Filters: filters,
diff --git a/images/encryption.go b/images/encryption.go
index d32a81a..88975d7 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -22,6 +22,7 @@ import (
 	"net/mail"
 	"strings"
 
+	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/mitchellh/go-homedir"
 	"golang.org/x/crypto/openpgp"
 )
@@ -134,6 +135,11 @@ func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 // Decrypt decrypts a byte array using data from the EncryptConfig
 func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 	// nothing here for now...
-	return data, nil
+	return data, fmt.Errorf("Missing implementation")
+}
+
+// GetKeyIds 
+func GetKeyIds(desc ocispec.Descriptor) ([]uint64, error) {
+	return []uint64{}, fmt.Errorf("Missing implementation")
 }
 
diff --git a/images/image.go b/images/image.go
index 6462040..2ad29e1 100644
--- a/images/image.go
+++ b/images/image.go
@@ -90,6 +90,7 @@ type Store interface {
 
 	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
 	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
+	GetImageKeyIds(ctx context.Context, name string) ([]uint64, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -523,6 +524,36 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	return desc, false, nil
 }
 
+// Get the image key Ids necessary for decrypting an image
+// We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
+// until we get them from the layer descriptors
+func GetImageKeyIds(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]uint64, error) {
+	var keyids []uint64;
+
+	switch (desc.MediaType) {
+	case MediaTypeDockerSchema2ManifestList,
+		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
+		children, err := Children(ctx, provider, desc)
+		if err != nil {
+			return []uint64{}, err
+		}
+		for _, child := range children {
+			kids, err := GetImageKeyIds(ctx, provider, child)
+			if err != nil {
+				return []uint64{}, err
+			}
+			keyids = append(keyids, kids...)
+		}
+	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip:
+		// nothing to do
+	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
+		return GetKeyIds(desc)
+	default:
+		return []uint64{}, fmt.Errorf("GetImageKeyIds: Unhandled media type %s")
+	}
+	return keyids, nil
+}
+
 // Children returns the immediate children of content described by the descriptor.
 func Children(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
 	var descs []ocispec.Descriptor
diff --git a/metadata/images.go b/metadata/images.go
index 7e52fd9..6a3c641 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -80,7 +80,7 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 // cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
 // or updates the existing one
 func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, encrypt bool) (images.Image, error) {
-	fmt.Printf("metadata/images.go: EncryptImage() name=%s\n", name)
+	fmt.Printf("metadata/images.go: cryptImage() name=%s\n", name)
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -197,6 +197,40 @@ func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc
 	return s.cryptImage(ctx, name, newName, cc, false)
 }
 
+func (s *imageStore) GetImageKeyIds(ctx context.Context, name string) ([]uint64, error) {
+	fmt.Printf("metadata/images.go: cryptImage() name=%s\n", name)
+	var image images.Image
+
+	namespace, err := namespaces.NamespaceRequired(ctx)
+	if err != nil {
+		return []uint64{}, err
+	}
+
+	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
+		bkt := getImagesBucket(tx, namespace)
+		if bkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		ibkt := bkt.Bucket([]byte(name))
+		if ibkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		image.Name = name
+		if err := readImage(&image, ibkt); err != nil {
+			return errors.Wrapf(err, "image %q", name)
+		}
+
+		return nil
+	}); err != nil {
+		return []uint64{}, err
+	}
+
+	cs := s.db.ContentStore()
+	return images.GetImageKeyIds(ctx, cs, image.Target)
+}
+
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
 	namespace, err := namespaces.NamespaceRequired(ctx)
 	if err != nil {
diff --git a/services/images/local.go b/services/images/local.go
index 85d00f0..9388f19 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -227,3 +227,19 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 
 	return &resp, nil
 }
+
+func (l *local) GetImageKeyIds(ctx context.Context, req *imagesapi.GetImageKeyIdsRequest, _ ...grpc.CallOption) (*imagesapi.GetImageKeyIdsResponse, error) {
+	log.G(ctx).WithField("name", req.Name).Debugf("GetImageKeyIds")
+
+	var resp       imagesapi.GetImageKeyIdsResponse
+
+	keyids, err := l.store.GetImageKeyIds(ctx, req.Name)
+	if err != nil {
+		return nil, errdefs.ToGRPC(err)
+	}
+
+	resp.Keyids = keyids
+	return &resp, nil
+}
+
+
diff --git a/services/images/service.go b/services/images/service.go
index 5c40e0a..582f601 100644
--- a/services/images/service.go
+++ b/services/images/service.go
@@ -90,3 +90,7 @@ func (s *service) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageR
 func (s *service) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest) (*imagesapi.DecryptImageResponse, error) {
 	return s.local.DecryptImage(ctx, req)
 }
+
+func (s *service) GetImageKeyIds(ctx context.Context, req *imagesapi.GetImageKeyIdsRequest) (*imagesapi.GetImageKeyIdsResponse, error) {
+	return s.local.GetImageKeyIds(ctx, req)
+}
-- 
2.7.4


From 270ef2a42503ac39e8ebb560e89a70961f88a50c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 17:21:47 -0400
Subject: [PATCH 09/79] Add images decrypt command and display keyids for now
 only

---
 cmd/ctr/commands/images/decrypt.go | 74 ++++++++++++++++++++++++++++++++++++++
 cmd/ctr/commands/images/images.go  |  1 +
 images/encryption.go               | 29 +++++++++++++--
 images/image.go                    | 46 ++++++++++++++++--------
 metadata/images.go                 |  4 +--
 5 files changed, 134 insertions(+), 20 deletions(-)
 create mode 100644 cmd/ctr/commands/images/decrypt.go

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
new file mode 100644
index 0000000..5496afe
--- /dev/null
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -0,0 +1,74 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package images
+
+import (
+	"fmt"
+
+	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/pkg/errors"
+	"github.com/urfave/cli"
+)
+
+var decryptCommand = cli.Command{
+	Name:      "decrypt",
+	Usage:     "decrypt an image locally",
+	ArgsUsage: "[flags] <local> <new name>",
+	Description: `Encrypt and image.
+
+	XYZ
+`,
+	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
+		Name:  "foo",
+		Usage: "foo",
+	}),
+	Action: func(context *cli.Context) error {
+		var (
+			local = context.Args().First()
+			newName = context.Args().Get(1)
+		)
+		if local == "" {
+			return errors.New("please provide the name of an image to decrypt")
+		}
+		if newName != "" {
+			fmt.Printf("Decrypting %s to %s\n", local, newName)
+		} else {
+			fmt.Printf("Decrypting %s and replacing it with the decrypted image\n", local);
+		}
+		client, ctx, cancel, err := commands.NewClient(context)
+		if err != nil {
+			return err
+		}
+		defer cancel()
+
+		keyIds, err := client.ImageService().GetImageKeyIds(ctx, local)
+		if err != nil {
+			return err
+		}
+		if len(keyIds) == 0 {
+			fmt.Printf("Image is not encrypted.\n")
+		} else {
+			fmt.Printf("Image is encrypted to the following keys: ")
+			for _, keyid := range keyIds {
+				fmt.Printf("0x%x ", keyid)
+			}
+			fmt.Printf("\n")
+		}
+		return nil
+	},
+}
+
diff --git a/cmd/ctr/commands/images/images.go b/cmd/ctr/commands/images/images.go
index 58f83b0..739a26a 100644
--- a/cmd/ctr/commands/images/images.go
+++ b/cmd/ctr/commands/images/images.go
@@ -48,6 +48,7 @@ var Command = cli.Command{
 		removeCommand,
 		setLabelsCommand,
 		encryptCommand,
+		decryptCommand,
 	},
 }
 
diff --git a/images/encryption.go b/images/encryption.go
index 88975d7..d4b019c 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -25,6 +25,8 @@ import (
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/mitchellh/go-homedir"
 	"golang.org/x/crypto/openpgp"
+	"golang.org/x/crypto/openpgp/packet"
+
 )
 
 // EncryptConfig is the container image PGP encryption configuration holding
@@ -122,12 +124,15 @@ func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 	if err != nil {
 		return nil, err
 	}
-	defer w.Close()
 
 	_, err = w.Write(data)
 	if err != nil {
 		return nil, err
 	}
+	err = w.Close();
+	if err != nil {
+		return nil, err
+	}
 
 	return ioutil.ReadAll(buf)
 }
@@ -139,7 +144,25 @@ func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 }
 
 // GetKeyIds 
-func GetKeyIds(desc ocispec.Descriptor) ([]uint64, error) {
-	return []uint64{}, fmt.Errorf("Missing implementation")
+func GetKeyIds(encData []byte, desc ocispec.Descriptor) ([]uint64, error) {
+	var keyids []uint64
+
+	r := bytes.NewReader(encData)
+
+	packets := packet.NewReader(r)
+ParsePackets:
+	for {
+		p, err := packets.Next()
+		if err != nil {
+			return []uint64{}, fmt.Errorf("yeek: %v\n", err)
+		}
+		switch p := p.(type) {
+		case *packet.EncryptedKey:
+			keyids = append(keyids, p.KeyId)
+		case *packet.SymmetricallyEncrypted:
+			break ParsePackets
+		}
+	}
+	return keyids, nil
 }
 
diff --git a/images/image.go b/images/image.go
index 2ad29e1..760f685 100644
--- a/images/image.go
+++ b/images/image.go
@@ -326,8 +326,8 @@ func Check(ctx context.Context, provider content.Provider, image ocispec.Descrip
 }
 
 // encryptLayer encryts a single layer and writes the encrypted layer back into storage
-func cryptLayer(ctx context.Context, provider content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
-	data, err := content.ReadBlob(ctx, provider, desc);
+func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
+	data, err := content.ReadBlob(ctx, cs, desc);
 	if err != nil {
 		return ocispec.Descriptor{}, err
 	}
@@ -365,12 +365,12 @@ func cryptLayer(ctx context.Context, provider content.Store, desc ocispec.Descri
 	case MediaTypeDockerSchema2LayerPGP:
 		newDesc.MediaType = MediaTypeDockerSchema2Layer
 	default:
-		return ocispec.Descriptor{}, fmt.Errorf("Unsupporter layer MediaType: %s\n", desc.MediaType)
+		return ocispec.Descriptor{}, errors.Wrapf(err, "Unsupporter layer MediaType: %s\n", desc.MediaType)
 	}
 
 	fmt.Printf("   ... writing layer %s in encrypted form as %s\n", desc.Digest, d)
 	ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
-	content.WriteBlob(ctx, provider, ref, bytes.NewReader(p), newDesc);
+	content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc);
 
 	return newDesc, nil
 }
@@ -419,7 +419,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 				newLayers = append(newLayers, child)
 			}
 		default:
-			return ocispec.Descriptor{}, false, fmt.Errorf("Bad/unhandled MediaType %s in encryptChildren\n", child.MediaType)
+			return ocispec.Descriptor{}, false, errors.Wrapf(err, "Bad/unhandled MediaType %s in encryptChildren\n", child.MediaType)
 		}
 	}
 
@@ -465,7 +465,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 // cryptManifestList encrypts or decrypts the children of a top level manifest list
 func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, bool, error) {
 	if desc.MediaType != MediaTypeDockerSchema2ManifestList {
-		return ocispec.Descriptor{}, false, fmt.Errorf("Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
+		return ocispec.Descriptor{}, false, errors.Wrapf(nil, "Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
 	}
 	// read the index; if any layer is encrypted and any manifests change we will need to rewrite it
 	b, err := content.ReadBlob(ctx, cs, desc)
@@ -527,30 +527,46 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
-func GetImageKeyIds(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]uint64, error) {
-	var keyids []uint64;
+func GetImageKeyIds(ctx context.Context, cs content.Store, desc ocispec.Descriptor) ([]uint64, error) {
+	var keyids []uint64
 
 	switch (desc.MediaType) {
 	case MediaTypeDockerSchema2ManifestList,
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
-		children, err := Children(ctx, provider, desc)
+		children, err := Children(ctx, cs, desc)
 		if err != nil {
 			return []uint64{}, err
 		}
 		for _, child := range children {
-			kids, err := GetImageKeyIds(ctx, provider, child)
+			kids, err := GetImageKeyIds(ctx, cs, child)
 			if err != nil {
 				return []uint64{}, err
 			}
-			keyids = append(keyids, kids...)
+			for i := 0; i < len(kids); i++ {
+				f := false
+				for j := 0; j < len(keyids); j++ {
+					if kids[i] == keyids[j] {
+						f = true
+						break
+					}
+				}
+				if !f {
+					keyids = append(keyids, kids[i])
+				}
+			}
 		}
-	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip:
-		// nothing to do
+	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip,
+		MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
-		return GetKeyIds(desc)
+		encData, err := content.ReadBlob(ctx, cs, desc);
+		if err != nil {
+			return []uint64{}, err
+		}
+		return GetKeyIds(encData, desc)
 	default:
-		return []uint64{}, fmt.Errorf("GetImageKeyIds: Unhandled media type %s")
+		return []uint64{}, errors.Wrapf(nil, "GetImageKeyIds: Unhandled media type %s", desc.MediaType)
 	}
+
 	return keyids, nil
 }
 
diff --git a/metadata/images.go b/metadata/images.go
index 6a3c641..29d529d 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -112,7 +112,7 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	cs := s.db.ContentStore()
 	fmt.Printf("metadata/images.go: cs = %v\n",cs)
 	fmt.Printf("  high level image.Target is of MediaType %s\n", image.Target.MediaType)
-	
+
 	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, encrypt)
 	if err != nil {
 		return image, err
@@ -198,7 +198,7 @@ func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc
 }
 
 func (s *imageStore) GetImageKeyIds(ctx context.Context, name string) ([]uint64, error) {
-	fmt.Printf("metadata/images.go: cryptImage() name=%s\n", name)
+	fmt.Printf("metadata/images.go: GetImageKeyIds() name=%s\n", name)
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
-- 
2.7.4


From ca92679c2f8e7209caae5132f357a63dd5c51db8 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 21:12:08 -0400
Subject: [PATCH 10/79] More refactoring

---
 api/next.pb.txt                     |   9 +-
 api/services/images/v1/images.pb.go | 263 ++++++++++++++++++++++++------------
 api/services/images/v1/images.proto |   9 +-
 cmd/ctr/commands/images/encrypt.go  |   6 +-
 cmd/ctr/commands/images/push.go     |   6 +-
 image_store.go                      |  10 +-
 images/encryption.go                |  12 +-
 services/images/local.go            |   6 +-
 8 files changed, 215 insertions(+), 106 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index ab58d3a..eb2852c 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2219,7 +2219,7 @@ file {
     }
   }
   message_type {
-    name: "CryptoConfig"
+    name: "EncryptConfig"
     field {
       name: "recipients"
       number: 1
@@ -2236,6 +2236,9 @@ file {
     }
   }
   message_type {
+    name: "DecryptConfig"
+  }
+  message_type {
     name: "EncryptImageRequest"
     field {
       name: "name"
@@ -2256,7 +2259,7 @@ file {
       number: 3
       label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
-      type_name: ".containerd.services.images.v1.CryptoConfig"
+      type_name: ".containerd.services.images.v1.EncryptConfig"
       json_name: "cc"
     }
   }
@@ -2295,7 +2298,7 @@ file {
       number: 3
       label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
-      type_name: ".containerd.services.images.v1.CryptoConfig"
+      type_name: ".containerd.services.images.v1.DecryptConfig"
       json_name: "cc"
     }
   }
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index f73aa37..28bd557 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -18,7 +18,8 @@
 		ListImagesRequest
 		ListImagesResponse
 		DeleteImageRequest
-		CryptoConfig
+		EncryptConfig
+		DecryptConfig
 		EncryptImageRequest
 		EncryptImageResponse
 		DecryptImageRequest
@@ -180,24 +181,31 @@ func (*DeleteImageRequest) ProtoMessage()               {}
 func (*DeleteImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{9} }
 
 // CryptConfig serves to pass keys used for encryption and decryption
-type CryptoConfig struct {
+type EncryptConfig struct {
 	Recipients    []string `protobuf:"bytes,1,rep,name=recipients" json:"recipients,omitempty"`
 	Gpgpubkeyring []byte   `protobuf:"bytes,2,opt,name=gpgpubkeyring,proto3" json:"gpgpubkeyring,omitempty"`
 }
 
-func (m *CryptoConfig) Reset()                    { *m = CryptoConfig{} }
-func (*CryptoConfig) ProtoMessage()               {}
-func (*CryptoConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
+func (m *EncryptConfig) Reset()                    { *m = EncryptConfig{} }
+func (*EncryptConfig) ProtoMessage()               {}
+func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
+
+type DecryptConfig struct {
+}
+
+func (m *DecryptConfig) Reset()                    { *m = DecryptConfig{} }
+func (*DecryptConfig) ProtoMessage()               {}
+func (*DecryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{11} }
 
 type EncryptImageRequest struct {
-	Name    string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	NewName string        `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Cc      *CryptoConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Cc      *EncryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
 }
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
 func (*EncryptImageRequest) ProtoMessage()               {}
-func (*EncryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{11} }
+func (*EncryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
 
 type EncryptImageResponse struct {
 	Image Image `protobuf:"bytes,1,opt,name=image" json:"image"`
@@ -205,17 +213,17 @@ type EncryptImageResponse struct {
 
 func (m *EncryptImageResponse) Reset()                    { *m = EncryptImageResponse{} }
 func (*EncryptImageResponse) ProtoMessage()               {}
-func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
+func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{13} }
 
 type DecryptImageRequest struct {
-	Name    string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	NewName string        `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Cc      *CryptoConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Cc      *DecryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
 }
 
 func (m *DecryptImageRequest) Reset()                    { *m = DecryptImageRequest{} }
 func (*DecryptImageRequest) ProtoMessage()               {}
-func (*DecryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{13} }
+func (*DecryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
 
 type DecryptImageResponse struct {
 	Image Image `protobuf:"bytes,1,opt,name=image" json:"image"`
@@ -223,7 +231,7 @@ type DecryptImageResponse struct {
 
 func (m *DecryptImageResponse) Reset()                    { *m = DecryptImageResponse{} }
 func (*DecryptImageResponse) ProtoMessage()               {}
-func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
+func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
 
 type GetImageKeyIdsRequest struct {
 	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
@@ -231,7 +239,7 @@ type GetImageKeyIdsRequest struct {
 
 func (m *GetImageKeyIdsRequest) Reset()                    { *m = GetImageKeyIdsRequest{} }
 func (*GetImageKeyIdsRequest) ProtoMessage()               {}
-func (*GetImageKeyIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
+func (*GetImageKeyIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type GetImageKeyIdsResponse struct {
 	Keyids []uint64 `protobuf:"varint,1,rep,packed,name=keyids" json:"keyids,omitempty"`
@@ -239,7 +247,7 @@ type GetImageKeyIdsResponse struct {
 
 func (m *GetImageKeyIdsResponse) Reset()                    { *m = GetImageKeyIdsResponse{} }
 func (*GetImageKeyIdsResponse) ProtoMessage()               {}
-func (*GetImageKeyIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
+func (*GetImageKeyIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
 
 func init() {
 	proto.RegisterType((*Image)(nil), "containerd.services.images.v1.Image")
@@ -252,7 +260,8 @@ func init() {
 	proto.RegisterType((*ListImagesRequest)(nil), "containerd.services.images.v1.ListImagesRequest")
 	proto.RegisterType((*ListImagesResponse)(nil), "containerd.services.images.v1.ListImagesResponse")
 	proto.RegisterType((*DeleteImageRequest)(nil), "containerd.services.images.v1.DeleteImageRequest")
-	proto.RegisterType((*CryptoConfig)(nil), "containerd.services.images.v1.CryptoConfig")
+	proto.RegisterType((*EncryptConfig)(nil), "containerd.services.images.v1.EncryptConfig")
+	proto.RegisterType((*DecryptConfig)(nil), "containerd.services.images.v1.DecryptConfig")
 	proto.RegisterType((*EncryptImageRequest)(nil), "containerd.services.images.v1.EncryptImageRequest")
 	proto.RegisterType((*EncryptImageResponse)(nil), "containerd.services.images.v1.EncryptImageResponse")
 	proto.RegisterType((*DecryptImageRequest)(nil), "containerd.services.images.v1.DecryptImageRequest")
@@ -914,7 +923,7 @@ func (m *DeleteImageRequest) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
-func (m *CryptoConfig) Marshal() (dAtA []byte, err error) {
+func (m *EncryptConfig) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalTo(dAtA)
@@ -924,7 +933,7 @@ func (m *CryptoConfig) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *CryptoConfig) MarshalTo(dAtA []byte) (int, error) {
+func (m *EncryptConfig) MarshalTo(dAtA []byte) (int, error) {
 	var i int
 	_ = i
 	var l int
@@ -953,6 +962,24 @@ func (m *CryptoConfig) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
+func (m *DecryptConfig) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *DecryptConfig) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	return i, nil
+}
+
 func (m *EncryptImageRequest) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -1270,7 +1297,7 @@ func (m *DeleteImageRequest) Size() (n int) {
 	return n
 }
 
-func (m *CryptoConfig) Size() (n int) {
+func (m *EncryptConfig) Size() (n int) {
 	var l int
 	_ = l
 	if len(m.Recipients) > 0 {
@@ -1286,6 +1313,12 @@ func (m *CryptoConfig) Size() (n int) {
 	return n
 }
 
+func (m *DecryptConfig) Size() (n int) {
+	var l int
+	_ = l
+	return n
+}
+
 func (m *EncryptImageRequest) Size() (n int) {
 	var l int
 	_ = l
@@ -1490,17 +1523,26 @@ func (this *DeleteImageRequest) String() string {
 	}, "")
 	return s
 }
-func (this *CryptoConfig) String() string {
+func (this *EncryptConfig) String() string {
 	if this == nil {
 		return "nil"
 	}
-	s := strings.Join([]string{`&CryptoConfig{`,
+	s := strings.Join([]string{`&EncryptConfig{`,
 		`Recipients:` + fmt.Sprintf("%v", this.Recipients) + `,`,
 		`Gpgpubkeyring:` + fmt.Sprintf("%v", this.Gpgpubkeyring) + `,`,
 		`}`,
 	}, "")
 	return s
 }
+func (this *DecryptConfig) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&DecryptConfig{`,
+		`}`,
+	}, "")
+	return s
+}
 func (this *EncryptImageRequest) String() string {
 	if this == nil {
 		return "nil"
@@ -1508,7 +1550,7 @@ func (this *EncryptImageRequest) String() string {
 	s := strings.Join([]string{`&EncryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
-		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "CryptoConfig", "CryptoConfig", 1) + `,`,
+		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "EncryptConfig", "EncryptConfig", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1530,7 +1572,7 @@ func (this *DecryptImageRequest) String() string {
 	s := strings.Join([]string{`&DecryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
-		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "CryptoConfig", "CryptoConfig", 1) + `,`,
+		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "DecryptConfig", "DecryptConfig", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -2634,7 +2676,7 @@ func (m *DeleteImageRequest) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
+func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -2657,10 +2699,10 @@ func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: CryptoConfig: wiretype end group for non-group")
+			return fmt.Errorf("proto: EncryptConfig: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: CryptoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: EncryptConfig: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
@@ -2744,6 +2786,56 @@ func (m *CryptoConfig) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DecryptConfig: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DecryptConfig: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
@@ -2858,7 +2950,7 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 				return io.ErrUnexpectedEOF
 			}
 			if m.Cc == nil {
-				m.Cc = &CryptoConfig{}
+				m.Cc = &EncryptConfig{}
 			}
 			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
@@ -3079,7 +3171,7 @@ func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
 				return io.ErrUnexpectedEOF
 			}
 			if m.Cc == nil {
-				m.Cc = &CryptoConfig{}
+				m.Cc = &DecryptConfig{}
 			}
 			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
@@ -3487,59 +3579,60 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 858 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x41, 0x8f, 0xdb, 0x54,
-	0x10, 0x5e, 0x27, 0x59, 0xef, 0xee, 0x64, 0x81, 0xf2, 0xba, 0xac, 0x2c, 0x03, 0xd9, 0xc8, 0x2a,
-	0xd2, 0x4a, 0x15, 0x76, 0x37, 0x05, 0x09, 0x76, 0x11, 0xa2, 0x49, 0x96, 0x52, 0x51, 0x7a, 0x30,
-	0x05, 0x22, 0x2e, 0x95, 0xe3, 0x4c, 0x8c, 0x95, 0xc4, 0x36, 0x7e, 0x2f, 0x59, 0xf9, 0x80, 0xd4,
-	0x0b, 0x77, 0x24, 0xfe, 0xd4, 0x1e, 0x39, 0x72, 0x02, 0x9a, 0x03, 0xbf, 0x03, 0xf9, 0xbd, 0x67,
-	0xd6, 0x4e, 0xa2, 0x3a, 0x29, 0x91, 0xb8, 0xcd, 0x7b, 0x99, 0x6f, 0xe6, 0x9b, 0x99, 0x37, 0x5f,
-	0x0c, 0x5d, 0xcf, 0x67, 0x3f, 0x4c, 0xfb, 0xa6, 0x1b, 0x4e, 0x2c, 0x37, 0x0c, 0x98, 0xe3, 0x07,
-	0x18, 0x0f, 0xf2, 0xa6, 0x13, 0xf9, 0x16, 0xc5, 0x78, 0xe6, 0xbb, 0x48, 0x2d, 0x7f, 0xe2, 0x78,
-	0x48, 0xad, 0xd9, 0x99, 0xb4, 0xcc, 0x28, 0x0e, 0x59, 0x48, 0xde, 0xbd, 0xf1, 0x37, 0x33, 0x5f,
-	0x53, 0x7a, 0xcc, 0xce, 0xf4, 0x23, 0x2f, 0xf4, 0x42, 0xee, 0x69, 0xa5, 0x96, 0x00, 0xe9, 0x6f,
-	0x7b, 0x61, 0xe8, 0x8d, 0xd1, 0xe2, 0xa7, 0xfe, 0x74, 0x68, 0xe1, 0x24, 0x62, 0x89, 0xfc, 0xb1,
-	0xb9, 0xf8, 0xe3, 0xd0, 0xc7, 0xf1, 0xe0, 0xd9, 0xc4, 0xa1, 0x23, 0xe9, 0x71, 0xb2, 0xe8, 0xc1,
-	0xfc, 0x09, 0x52, 0xe6, 0x4c, 0x22, 0xe9, 0x70, 0xb1, 0x56, 0x69, 0x2c, 0x89, 0x90, 0x5a, 0x03,
-	0xa4, 0x6e, 0xec, 0x47, 0x2c, 0x8c, 0x05, 0xd8, 0xf8, 0xbb, 0x02, 0xbb, 0x8f, 0xd2, 0x02, 0x08,
-	0x81, 0x5a, 0xe0, 0x4c, 0x50, 0x53, 0x9a, 0xca, 0xe9, 0x81, 0xcd, 0x6d, 0xf2, 0x05, 0xa8, 0x63,
-	0xa7, 0x8f, 0x63, 0xaa, 0x55, 0x9a, 0xd5, 0xd3, 0x7a, 0xeb, 0x9e, 0xf9, 0xd2, 0x06, 0x98, 0x3c,
-	0x92, 0xf9, 0x98, 0x43, 0x2e, 0x03, 0x16, 0x27, 0xb6, 0xc4, 0x93, 0x73, 0x50, 0x99, 0x13, 0x7b,
-	0xc8, 0xb4, 0x6a, 0x53, 0x39, 0xad, 0xb7, 0xde, 0xc9, 0x47, 0xe2, 0xdc, 0xcc, 0xee, 0xbf, 0xdc,
-	0xda, 0xb5, 0xeb, 0x3f, 0x4e, 0x76, 0x6c, 0x89, 0x20, 0x1d, 0x00, 0x37, 0x46, 0x87, 0xe1, 0xe0,
-	0x99, 0xc3, 0xb4, 0x3d, 0x8e, 0xd7, 0x4d, 0xd1, 0x16, 0x33, 0x6b, 0x8b, 0xf9, 0x34, 0x6b, 0x4b,
-	0x7b, 0x3f, 0x45, 0xff, 0xf2, 0xe7, 0x89, 0x62, 0x1f, 0x48, 0xdc, 0x03, 0x1e, 0x64, 0x1a, 0x0d,
-	0xb2, 0x20, 0xfb, 0x9b, 0x04, 0x91, 0xb8, 0x07, 0x4c, 0xff, 0x18, 0xea, 0xb9, 0xe2, 0xc8, 0x2d,
-	0xa8, 0x8e, 0x30, 0x91, 0x1d, 0x4b, 0x4d, 0x72, 0x04, 0xbb, 0x33, 0x67, 0x3c, 0x45, 0xad, 0xc2,
-	0xef, 0xc4, 0xe1, 0xbc, 0xf2, 0x91, 0x62, 0xbc, 0x07, 0x6f, 0x3c, 0x44, 0xc6, 0x1b, 0x64, 0xe3,
-	0x8f, 0x53, 0xa4, 0x6c, 0x55, 0xc7, 0x8d, 0x27, 0x70, 0xeb, 0xc6, 0x8d, 0x46, 0x61, 0x40, 0x91,
-	0x9c, 0xc3, 0x2e, 0x6f, 0x31, 0x77, 0xac, 0xb7, 0xee, 0xac, 0x33, 0x04, 0x5b, 0x40, 0x8c, 0x6f,
-	0x81, 0x74, 0x78, 0x0f, 0x0a, 0x99, 0x3f, 0x7b, 0x85, 0x88, 0x72, 0x28, 0x32, 0xee, 0x77, 0x70,
-	0xbb, 0x10, 0x57, 0x52, 0xfd, 0xef, 0x81, 0x7f, 0x55, 0x80, 0x7c, 0xc3, 0x1b, 0xbe, 0x5d, 0xc6,
-	0xe4, 0x02, 0xea, 0x62, 0x90, 0x7c, 0xb9, 0xf8, 0x80, 0x56, 0xbd, 0x80, 0xcf, 0xd3, 0xfd, 0xfb,
-	0xca, 0xa1, 0x23, 0x5b, 0xbe, 0x97, 0xd4, 0x4e, 0xcb, 0x2d, 0x90, 0xda, 0x5a, 0xb9, 0xef, 0xc3,
-	0x9b, 0x8f, 0x7d, 0x2a, 0x06, 0x4e, 0xb3, 0x62, 0x35, 0xd8, 0x1b, 0xfa, 0x63, 0x86, 0x31, 0xd5,
-	0x94, 0x66, 0xf5, 0xf4, 0xc0, 0xce, 0x8e, 0x46, 0x0f, 0x48, 0xde, 0x5d, 0xd2, 0x68, 0x83, 0x2a,
-	0x92, 0x70, 0xf7, 0xcd, 0x78, 0x48, 0xa4, 0xf1, 0x09, 0x90, 0x2e, 0x8e, 0x71, 0xa1, 0xed, 0xab,
-	0x44, 0x81, 0x40, 0x8d, 0x26, 0x81, 0xcb, 0x3b, 0xb8, 0x6f, 0x73, 0xdb, 0x78, 0x0a, 0x87, 0x9d,
-	0x38, 0x89, 0x58, 0xd8, 0x09, 0x83, 0xa1, 0xef, 0x91, 0x06, 0x40, 0x8c, 0xae, 0x1f, 0xf9, 0x18,
-	0xb0, 0xac, 0x88, 0xdc, 0x0d, 0xb9, 0x03, 0xaf, 0x79, 0x91, 0x17, 0x4d, 0xfb, 0x23, 0x4c, 0x62,
-	0x3f, 0xf0, 0x78, 0xb0, 0x43, 0xbb, 0x78, 0x69, 0x3c, 0x57, 0xe0, 0xf6, 0x65, 0xe0, 0xa6, 0x81,
-	0x4b, 0x59, 0x69, 0xb0, 0x17, 0xe0, 0xd5, 0x93, 0xf4, 0x5a, 0xec, 0x5e, 0x76, 0x24, 0x17, 0x50,
-	0x71, 0x5d, 0x29, 0x3b, 0x77, 0x4b, 0x3a, 0x93, 0x2f, 0xc2, 0xae, 0xb8, 0xae, 0xd1, 0x83, 0xa3,
-	0x22, 0x83, 0xad, 0x4d, 0x3e, 0x2d, 0xae, 0x8b, 0xff, 0x77, 0x71, 0x45, 0x06, 0x5b, 0x2b, 0xee,
-	0x2e, 0xbc, 0x95, 0xc9, 0xd8, 0x97, 0x98, 0x3c, 0x1a, 0xd0, 0x97, 0x69, 0xde, 0x3d, 0x38, 0x5e,
-	0x74, 0x96, 0x44, 0x8e, 0x41, 0x1d, 0x61, 0xe2, 0x0f, 0xc4, 0x13, 0xaa, 0xd9, 0xf2, 0xd4, 0xfa,
-	0x79, 0x0f, 0x54, 0xb1, 0x03, 0x64, 0x08, 0xd5, 0x87, 0xc8, 0x88, 0x59, 0xc2, 0x71, 0x41, 0x7b,
-	0x75, 0x6b, 0x6d, 0x7f, 0x49, 0x65, 0x04, 0xb5, 0x74, 0xf3, 0x48, 0xd9, 0x5f, 0xe0, 0xd2, 0x36,
-	0xeb, 0x67, 0x1b, 0x20, 0x64, 0xb2, 0x10, 0x54, 0xa1, 0xae, 0xe4, 0xac, 0x74, 0xa6, 0x8b, 0xe2,
-	0xae, 0xb7, 0x36, 0x81, 0xdc, 0x24, 0x14, 0xfa, 0x56, 0x9a, 0x70, 0x59, 0x9b, 0x4b, 0x13, 0xae,
-	0x52, 0xce, 0xaf, 0x41, 0x15, 0x72, 0x53, 0x9a, 0x70, 0x59, 0x95, 0xf4, 0xe3, 0x25, 0xd5, 0xbe,
-	0x4c, 0x3f, 0xa9, 0xc8, 0x15, 0x1c, 0xe6, 0x97, 0x95, 0x94, 0x11, 0x5b, 0xa1, 0x2d, 0xfa, 0xfd,
-	0x8d, 0x30, 0xb2, 0x9a, 0x2b, 0x38, 0xcc, 0x2f, 0x52, 0x69, 0xe2, 0x15, 0x7b, 0x5f, 0x9a, 0x78,
-	0xe5, 0xa6, 0xfe, 0x04, 0xaf, 0x17, 0x57, 0x87, 0x7c, 0xb0, 0xe6, 0xc3, 0x2e, 0xac, 0xa5, 0xfe,
-	0xe1, 0x86, 0x28, 0x91, 0xbe, 0xdd, 0xbb, 0x7e, 0xd1, 0xd8, 0xf9, 0xfd, 0x45, 0x63, 0xe7, 0xf9,
-	0xbc, 0xa1, 0x5c, 0xcf, 0x1b, 0xca, 0x6f, 0xf3, 0x86, 0xf2, 0xd7, 0xbc, 0xa1, 0x7c, 0xff, 0xe9,
-	0x2b, 0x7e, 0x6f, 0x5f, 0x08, 0xab, 0xb7, 0xd3, 0x57, 0xf9, 0x70, 0xef, 0xff, 0x13, 0x00, 0x00,
-	0xff, 0xff, 0x71, 0x2f, 0x2f, 0x99, 0xba, 0x0b, 0x00, 0x00,
+	// 867 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x41, 0x6f, 0xe3, 0x54,
+	0x10, 0xae, 0x93, 0xd4, 0x6d, 0x27, 0x2d, 0xbb, 0xbc, 0x2d, 0x95, 0x65, 0x20, 0x8d, 0xac, 0x45,
+	0xaa, 0x04, 0xd8, 0xdb, 0x2c, 0x48, 0xd0, 0xae, 0x10, 0xdb, 0xa6, 0x2c, 0x2b, 0x96, 0x3d, 0x18,
+	0x16, 0x22, 0x2e, 0x2b, 0xc7, 0x99, 0x18, 0x2b, 0x89, 0x6d, 0xfc, 0x5e, 0x52, 0xf9, 0x80, 0x04,
+	0x07, 0xee, 0x48, 0xfc, 0xa9, 0x1e, 0x39, 0x72, 0x02, 0x36, 0x07, 0x7e, 0x07, 0xf2, 0x7b, 0xcf,
+	0xd4, 0x4e, 0xa2, 0x75, 0x52, 0xa2, 0xbd, 0xcd, 0x7b, 0x99, 0x6f, 0x66, 0xbe, 0x6f, 0xde, 0x4c,
+	0x0c, 0x6d, 0xcf, 0x67, 0xdf, 0x8f, 0xbb, 0xa6, 0x1b, 0x8e, 0x2c, 0x37, 0x0c, 0x98, 0xe3, 0x07,
+	0x18, 0xf7, 0xf2, 0xa6, 0x13, 0xf9, 0x16, 0xc5, 0x78, 0xe2, 0xbb, 0x48, 0x2d, 0x7f, 0xe4, 0x78,
+	0x48, 0xad, 0xc9, 0xb1, 0xb4, 0xcc, 0x28, 0x0e, 0x59, 0x48, 0xde, 0xbe, 0xf6, 0x37, 0x33, 0x5f,
+	0x53, 0x7a, 0x4c, 0x8e, 0xf5, 0x7d, 0x2f, 0xf4, 0x42, 0xee, 0x69, 0xa5, 0x96, 0x00, 0xe9, 0x6f,
+	0x7a, 0x61, 0xe8, 0x0d, 0xd1, 0xe2, 0xa7, 0xee, 0xb8, 0x6f, 0xe1, 0x28, 0x62, 0x89, 0xfc, 0xb1,
+	0x39, 0xfb, 0x63, 0xdf, 0xc7, 0x61, 0xef, 0xf9, 0xc8, 0xa1, 0x03, 0xe9, 0x71, 0x38, 0xeb, 0xc1,
+	0xfc, 0x11, 0x52, 0xe6, 0x8c, 0x22, 0xe9, 0x70, 0xba, 0x14, 0x35, 0x96, 0x44, 0x48, 0xad, 0x1e,
+	0x52, 0x37, 0xf6, 0x23, 0x16, 0xc6, 0x02, 0x6c, 0xfc, 0x53, 0x81, 0xcd, 0xc7, 0x29, 0x01, 0x42,
+	0xa0, 0x16, 0x38, 0x23, 0xd4, 0x94, 0xa6, 0x72, 0xb4, 0x63, 0x73, 0x9b, 0x7c, 0x0e, 0xea, 0xd0,
+	0xe9, 0xe2, 0x90, 0x6a, 0x95, 0x66, 0xf5, 0xa8, 0xde, 0xba, 0x67, 0xbe, 0x54, 0x00, 0x93, 0x47,
+	0x32, 0x9f, 0x70, 0xc8, 0x45, 0xc0, 0xe2, 0xc4, 0x96, 0x78, 0x72, 0x02, 0x2a, 0x73, 0x62, 0x0f,
+	0x99, 0x56, 0x6d, 0x2a, 0x47, 0xf5, 0xd6, 0x5b, 0xf9, 0x48, 0xbc, 0x36, 0xb3, 0xfd, 0x5f, 0x6d,
+	0x67, 0xb5, 0xab, 0x3f, 0x0f, 0x37, 0x6c, 0x89, 0x20, 0xe7, 0x00, 0x6e, 0x8c, 0x0e, 0xc3, 0xde,
+	0x73, 0x87, 0x69, 0x5b, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33, 0x93, 0xc5, 0xfc, 0x3a, 0x93, 0xe5,
+	0x6c, 0x3b, 0x45, 0xff, 0xfa, 0xd7, 0xa1, 0x62, 0xef, 0x48, 0xdc, 0x43, 0x1e, 0x64, 0x1c, 0xf5,
+	0xb2, 0x20, 0xdb, 0xab, 0x04, 0x91, 0xb8, 0x87, 0x4c, 0xff, 0x18, 0xea, 0x39, 0x72, 0xe4, 0x36,
+	0x54, 0x07, 0x98, 0x48, 0xc5, 0x52, 0x93, 0xec, 0xc3, 0xe6, 0xc4, 0x19, 0x8e, 0x51, 0xab, 0xf0,
+	0x3b, 0x71, 0x38, 0xa9, 0x7c, 0xa4, 0x18, 0xef, 0xc0, 0xad, 0x47, 0xc8, 0xb8, 0x40, 0x36, 0xfe,
+	0x30, 0x46, 0xca, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0xd7, 0x6e, 0x34, 0x0a, 0x03, 0x8a, 0xe4,
+	0x04, 0x36, 0xb9, 0xc4, 0xdc, 0xb1, 0xde, 0xba, 0xbb, 0x4c, 0x13, 0x6c, 0x01, 0x31, 0xbe, 0x01,
+	0x72, 0xce, 0x35, 0x28, 0x64, 0xfe, 0xf4, 0x06, 0x11, 0x65, 0x53, 0x64, 0xdc, 0x6f, 0xe1, 0x4e,
+	0x21, 0xae, 0x2c, 0xf5, 0xff, 0x07, 0xfe, 0x4d, 0x01, 0xf2, 0x8c, 0x0b, 0xbe, 0xde, 0x8a, 0xc9,
+	0x29, 0xd4, 0x45, 0x23, 0xf9, 0x70, 0xf1, 0x06, 0x2d, 0x7a, 0x01, 0x9f, 0xa5, 0xf3, 0xf7, 0xa5,
+	0x43, 0x07, 0xb6, 0x7c, 0x2f, 0xa9, 0x9d, 0xd2, 0x2d, 0x14, 0xb5, 0x36, 0xba, 0xef, 0xc3, 0xeb,
+	0x4f, 0x7c, 0x2a, 0x1a, 0x4e, 0x33, 0xb2, 0x1a, 0x6c, 0xf5, 0xfd, 0x21, 0xc3, 0x98, 0x6a, 0x4a,
+	0xb3, 0x7a, 0xb4, 0x63, 0x67, 0x47, 0xa3, 0x03, 0x24, 0xef, 0x2e, 0xcb, 0x38, 0x03, 0x55, 0x24,
+	0xe1, 0xee, 0xab, 0xd5, 0x21, 0x91, 0xc6, 0x03, 0x20, 0x6d, 0x1c, 0xe2, 0x8c, 0xec, 0x8b, 0x96,
+	0x02, 0x81, 0x1a, 0x4d, 0x02, 0x97, 0x2b, 0xb8, 0x6d, 0x73, 0xdb, 0x78, 0x06, 0x7b, 0x17, 0x81,
+	0x1b, 0x27, 0x11, 0x3b, 0x0f, 0x83, 0xbe, 0xef, 0x91, 0x06, 0x40, 0x8c, 0xae, 0x1f, 0xf9, 0x18,
+	0xb0, 0x8c, 0x45, 0xee, 0x86, 0xdc, 0x85, 0x3d, 0x2f, 0xf2, 0xa2, 0x71, 0x77, 0x80, 0x49, 0xec,
+	0x07, 0x1e, 0x8f, 0xb6, 0x6b, 0x17, 0x2f, 0x8d, 0x5b, 0xb0, 0xd7, 0xc6, 0x5c, 0x58, 0xe3, 0x67,
+	0x05, 0xee, 0xc8, 0x44, 0xa5, 0x75, 0x6a, 0xb0, 0x15, 0xe0, 0xe5, 0xd3, 0xf4, 0x5a, 0x4c, 0x63,
+	0x76, 0x24, 0x0f, 0xa0, 0xe2, 0xba, 0x72, 0x11, 0xbd, 0x57, 0xa2, 0x55, 0x81, 0x96, 0x5d, 0x71,
+	0x5d, 0xa3, 0x03, 0xfb, 0xc5, 0x12, 0xd6, 0xf6, 0x18, 0x52, 0x76, 0x92, 0xef, 0x2b, 0x62, 0x57,
+	0x50, 0x37, 0x63, 0x57, 0x2c, 0x61, 0x6d, 0xec, 0xde, 0x85, 0x37, 0xb2, 0xd5, 0xf6, 0x05, 0x26,
+	0x8f, 0x7b, 0xf4, 0x65, 0x7b, 0xf0, 0x1e, 0x1c, 0xcc, 0x3a, 0xcb, 0x42, 0x0e, 0x40, 0x1d, 0x60,
+	0xe2, 0xf7, 0xc4, 0xab, 0xaa, 0xd9, 0xf2, 0xd4, 0xfa, 0x65, 0x0b, 0x54, 0x31, 0x17, 0xa4, 0x0f,
+	0xd5, 0x47, 0xc8, 0x88, 0x59, 0x52, 0xe3, 0xcc, 0x3e, 0xd6, 0xad, 0xa5, 0xfd, 0x65, 0x29, 0x03,
+	0xa8, 0xa5, 0xd3, 0x48, 0xca, 0xfe, 0x16, 0xe7, 0x26, 0x5c, 0x3f, 0x5e, 0x01, 0x21, 0x93, 0x85,
+	0xa0, 0x8a, 0x8d, 0x4b, 0xca, 0xc0, 0xf3, 0x0b, 0x5f, 0x6f, 0xad, 0x02, 0xb9, 0x4e, 0x28, 0x76,
+	0x5e, 0x69, 0xc2, 0xf9, 0x7d, 0x5d, 0x9a, 0x70, 0xd1, 0x36, 0xfd, 0x0a, 0x54, 0xb1, 0x82, 0x4a,
+	0x13, 0xce, 0x6f, 0x2a, 0xfd, 0x60, 0x6e, 0x93, 0x5f, 0xa4, 0x9f, 0x59, 0xe4, 0x12, 0x76, 0xf3,
+	0xd3, 0x4a, 0x5a, 0xcb, 0xcd, 0x7b, 0x21, 0xf6, 0xfd, 0x95, 0x30, 0x92, 0xcd, 0x25, 0xec, 0xe6,
+	0x07, 0xa9, 0x34, 0xf1, 0x82, 0xc1, 0x2f, 0x4d, 0xbc, 0x70, 0x52, 0x7f, 0x84, 0xd7, 0x8a, 0xa3,
+	0x43, 0x3e, 0x58, 0xf2, 0x61, 0x17, 0xc6, 0x52, 0xff, 0x70, 0x45, 0x94, 0x48, 0x7f, 0xd6, 0xb9,
+	0x7a, 0xd1, 0xd8, 0xf8, 0xe3, 0x45, 0x63, 0xe3, 0xa7, 0x69, 0x43, 0xb9, 0x9a, 0x36, 0x94, 0xdf,
+	0xa7, 0x0d, 0xe5, 0xef, 0x69, 0x43, 0xf9, 0xee, 0x93, 0x1b, 0x7e, 0x83, 0x9f, 0x0a, 0xab, 0xb3,
+	0xd1, 0x55, 0x79, 0x73, 0xef, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xd6, 0xf5, 0x39, 0x31, 0xce,
+	0x0b, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index c0a0431..fee1432 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -131,16 +131,19 @@ message DeleteImageRequest {
 }
 
 // CryptConfig serves to pass keys used for encryption and decryption
-message CryptoConfig {
+message EncryptConfig {
 	repeated string recipients = 1;
 	bytes gpgpubkeyring = 2;
 }
 
+message DecryptConfig {
+}
+
 message EncryptImageRequest {
 	string name = 1;
 	string newName = 2;
 
-	CryptoConfig cc = 3;
+	EncryptConfig cc = 3;
 }
 
 message EncryptImageResponse {
@@ -151,7 +154,7 @@ message DecryptImageRequest {
 	string name = 1;
 	string newName = 2;
 
-	CryptoConfig cc = 3;
+	DecryptConfig cc = 3;
 }
 
 message DecryptImageResponse {
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 8c2bcbb..389226c 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -70,8 +70,10 @@ var encryptCommand = cli.Command{
 			return err
 		}
 		cc := &images.CryptoConfig{
-			GPGPubRingFile: gpgPubRingFile,
-			Recipients:     recipients,
+			Ec:	&images.EncryptConfig{
+				GPGPubRingFile: gpgPubRingFile,
+				Recipients:     recipients,
+			},
 		}
 		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc)
 		if err != nil {
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index 396ad81..6f142f4 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -100,8 +100,10 @@ var pushCommand = cli.Command{
 				return err
 			}
 			cc := &images.CryptoConfig{
-				GPGPubRingFile: gpgPubRingFile,
-				Recipients:     recipients,
+				Ec:	&images.EncryptConfig{
+					GPGPubRingFile: gpgPubRingFile,
+					Recipients:     recipients,
+				},
 			}
 			img, err := client.ImageService().EncryptImage(ctx, local, local, cc)
 			if err != nil {
diff --git a/image_store.go b/image_store.go
index d6c9623..d2d76dd 100644
--- a/image_store.go
+++ b/image_store.go
@@ -50,14 +50,14 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, ec *images.CryptoConfig) (images.Image, error) {
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
 	fmt.Printf("image_store.go: EncryptImage() name=%s\n", name);
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
-		Cc:      &imagesapi.CryptoConfig{
-			Recipients   : ec.Recipients,
-			Gpgpubkeyring: ec.GPGPubRingFile,
+		Cc:      &imagesapi.EncryptConfig{
+			Recipients   : cc.Ec.Recipients,
+			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 		},
 	});
 	if err != nil {
@@ -72,7 +72,7 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, e
 	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
 		Name:    name,
 		NewName: newName,
-		Cc:      &imagesapi.CryptoConfig{
+		Cc:      &imagesapi.DecryptConfig{
 			// FIXME: missing parameters here
 		},
 	});
diff --git a/images/encryption.go b/images/encryption.go
index d4b019c..302a09f 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -32,11 +32,15 @@ import (
 // EncryptConfig is the container image PGP encryption configuration holding
 // the identifiers of those that will be able to decrypt the container and
 // the PGP public keyring file data that contains their public keys.
-type CryptoConfig struct {
+type EncryptConfig struct {
        Recipients     []string
        GPGPubRingFile []byte
 }
 
+type CryptoConfig struct {
+	Ec *EncryptConfig
+}
+
 type Encryptor interface {
 }
 
@@ -56,7 +60,7 @@ func ReadGPGPubRingFile() ([]byte, error) {
 // createEntityList creates the opengpg EntityList by reading the KeyRing
 // first and then filtering out recipients' keys
 func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
-	r := bytes.NewReader(cc.GPGPubRingFile)
+	r := bytes.NewReader(cc.Ec.GPGPubRingFile)
 
 	entityList, err := openpgp.ReadKeyRing(r)
 	if err != nil {
@@ -64,7 +68,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 	}
 
 	rSet := make(map[string]int)
-	for _, r := range cc.Recipients {
+	for _, r := range cc.Ec.Recipients {
 		rSet[r] = 0
 	}
 
@@ -76,7 +80,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 			if err != nil {
 				return nil, err
 			}
-			for _, r := range cc.Recipients {
+			for _, r := range cc.Ec.Recipients {
 				if strings.Compare(addr.Name, r) == 0 || strings.Compare(addr.Address, r) == 0 {
 					fmt.Printf(" TAKING key of %s\n", k)
 					filteredList = append(filteredList, entity)
diff --git a/services/images/local.go b/services/images/local.go
index 9388f19..c0cfd7f 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -187,8 +187,10 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 	var resp       imagesapi.EncryptImageResponse
 
 	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
-		Recipients: req.Cc.Recipients,
-		GPGPubRingFile: req.Cc.Gpgpubkeyring,
+		Ec:	&images.EncryptConfig{
+			Recipients    : req.Cc.Recipients,
+			GPGPubRingFile: req.Cc.Gpgpubkeyring,
+		},
 	})
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
-- 
2.7.4


From 91f23eeff1ef6dd213a81ddbdb4d2c02708a6880 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 20 Jul 2018 22:23:27 -0400
Subject: [PATCH 11/79] Convert GetImageKeyIds to more general
 GetImageLayerInfo

---
 api/next.pb.txt                     |  53 +++-
 api/services/images/v1/images.pb.go | 512 ++++++++++++++++++++++++++++--------
 api/services/images/v1/images.proto |  17 +-
 cmd/ctr/commands/images/decrypt.go  |  23 +-
 cmd/ctr/commands/images/encrypt.go  |   4 -
 image_store.go                      |  17 +-
 images/image.go                     |  69 +++--
 metadata/images.go                  |  10 +-
 services/images/local.go            |  20 +-
 services/images/service.go          |   4 +-
 10 files changed, 568 insertions(+), 161 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index eb2852c..fc65c5d 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2317,7 +2317,7 @@ file {
     }
   }
   message_type {
-    name: "GetImageKeyIdsRequest"
+    name: "GetImageLayerInfoRequest"
     field {
       name: "name"
       number: 1
@@ -2327,13 +2327,52 @@ file {
     }
   }
   message_type {
-    name: "GetImageKeyIdsResponse"
+    name: "LayerInfo"
     field {
-      name: "keyids"
+      name: "keyIds"
       number: 1
       label: LABEL_REPEATED
       type: TYPE_UINT64
-      json_name: "keyids"
+      json_name: "keyIds"
+    }
+    field {
+      name: "digest"
+      number: 2
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "digest"
+    }
+    field {
+      name: "encryption"
+      number: 3
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "encryption"
+    }
+    field {
+      name: "fileSize"
+      number: 4
+      label: LABEL_OPTIONAL
+      type: TYPE_INT64
+      json_name: "fileSize"
+    }
+    field {
+      name: "architecture"
+      number: 5
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "architecture"
+    }
+  }
+  message_type {
+    name: "GetImageLayerInfoResponse"
+    field {
+      name: "layerInfo"
+      number: 1
+      label: LABEL_REPEATED
+      type: TYPE_MESSAGE
+      type_name: ".containerd.services.images.v1.LayerInfo"
+      json_name: "layerInfo"
     }
   }
   service {
@@ -2374,9 +2413,9 @@ file {
       output_type: ".containerd.services.images.v1.DecryptImageResponse"
     }
     method {
-      name: "GetImageKeyIds"
-      input_type: ".containerd.services.images.v1.GetImageKeyIdsRequest"
-      output_type: ".containerd.services.images.v1.GetImageKeyIdsResponse"
+      name: "GetImageLayerInfo"
+      input_type: ".containerd.services.images.v1.GetImageLayerInfoRequest"
+      output_type: ".containerd.services.images.v1.GetImageLayerInfoResponse"
     }
   }
   options {
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 28bd557..6da3656 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -24,8 +24,9 @@
 		EncryptImageResponse
 		DecryptImageRequest
 		DecryptImageResponse
-		GetImageKeyIdsRequest
-		GetImageKeyIdsResponse
+		GetImageLayerInfoRequest
+		LayerInfo
+		GetImageLayerInfoResponse
 */
 package images
 
@@ -233,21 +234,33 @@ func (m *DecryptImageResponse) Reset()                    { *m = DecryptImageRes
 func (*DecryptImageResponse) ProtoMessage()               {}
 func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
 
-type GetImageKeyIdsRequest struct {
+type GetImageLayerInfoRequest struct {
 	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
 }
 
-func (m *GetImageKeyIdsRequest) Reset()                    { *m = GetImageKeyIdsRequest{} }
-func (*GetImageKeyIdsRequest) ProtoMessage()               {}
-func (*GetImageKeyIdsRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
+func (m *GetImageLayerInfoRequest) Reset()                    { *m = GetImageLayerInfoRequest{} }
+func (*GetImageLayerInfoRequest) ProtoMessage()               {}
+func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
-type GetImageKeyIdsResponse struct {
-	Keyids []uint64 `protobuf:"varint,1,rep,packed,name=keyids" json:"keyids,omitempty"`
+type LayerInfo struct {
+	KeyIds       []uint64 `protobuf:"varint,1,rep,packed,name=keyIds" json:"keyIds,omitempty"`
+	Digest       string   `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
+	Encryption   string   `protobuf:"bytes,3,opt,name=encryption,proto3" json:"encryption,omitempty"`
+	FileSize     int64    `protobuf:"varint,4,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
+	Architecture string   `protobuf:"bytes,5,opt,name=architecture,proto3" json:"architecture,omitempty"`
 }
 
-func (m *GetImageKeyIdsResponse) Reset()                    { *m = GetImageKeyIdsResponse{} }
-func (*GetImageKeyIdsResponse) ProtoMessage()               {}
-func (*GetImageKeyIdsResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
+func (m *LayerInfo) Reset()                    { *m = LayerInfo{} }
+func (*LayerInfo) ProtoMessage()               {}
+func (*LayerInfo) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
+
+type GetImageLayerInfoResponse struct {
+	LayerInfo []*LayerInfo `protobuf:"bytes,1,rep,name=layerInfo" json:"layerInfo,omitempty"`
+}
+
+func (m *GetImageLayerInfoResponse) Reset()                    { *m = GetImageLayerInfoResponse{} }
+func (*GetImageLayerInfoResponse) ProtoMessage()               {}
+func (*GetImageLayerInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{18} }
 
 func init() {
 	proto.RegisterType((*Image)(nil), "containerd.services.images.v1.Image")
@@ -266,8 +279,9 @@ func init() {
 	proto.RegisterType((*EncryptImageResponse)(nil), "containerd.services.images.v1.EncryptImageResponse")
 	proto.RegisterType((*DecryptImageRequest)(nil), "containerd.services.images.v1.DecryptImageRequest")
 	proto.RegisterType((*DecryptImageResponse)(nil), "containerd.services.images.v1.DecryptImageResponse")
-	proto.RegisterType((*GetImageKeyIdsRequest)(nil), "containerd.services.images.v1.GetImageKeyIdsRequest")
-	proto.RegisterType((*GetImageKeyIdsResponse)(nil), "containerd.services.images.v1.GetImageKeyIdsResponse")
+	proto.RegisterType((*GetImageLayerInfoRequest)(nil), "containerd.services.images.v1.GetImageLayerInfoRequest")
+	proto.RegisterType((*LayerInfo)(nil), "containerd.services.images.v1.LayerInfo")
+	proto.RegisterType((*GetImageLayerInfoResponse)(nil), "containerd.services.images.v1.GetImageLayerInfoResponse")
 }
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -299,7 +313,7 @@ type ImagesClient interface {
 	// Decyrpt an image given its name
 	DecryptImage(ctx context.Context, in *DecryptImageRequest, opts ...grpc.CallOption) (*DecryptImageResponse, error)
 	// Get the KeyIds of keys the image is encrypted with
-	GetImageKeyIds(ctx context.Context, in *GetImageKeyIdsRequest, opts ...grpc.CallOption) (*GetImageKeyIdsResponse, error)
+	GetImageLayerInfo(ctx context.Context, in *GetImageLayerInfoRequest, opts ...grpc.CallOption) (*GetImageLayerInfoResponse, error)
 }
 
 type imagesClient struct {
@@ -373,9 +387,9 @@ func (c *imagesClient) DecryptImage(ctx context.Context, in *DecryptImageRequest
 	return out, nil
 }
 
-func (c *imagesClient) GetImageKeyIds(ctx context.Context, in *GetImageKeyIdsRequest, opts ...grpc.CallOption) (*GetImageKeyIdsResponse, error) {
-	out := new(GetImageKeyIdsResponse)
-	err := grpc.Invoke(ctx, "/containerd.services.images.v1.Images/GetImageKeyIds", in, out, c.cc, opts...)
+func (c *imagesClient) GetImageLayerInfo(ctx context.Context, in *GetImageLayerInfoRequest, opts ...grpc.CallOption) (*GetImageLayerInfoResponse, error) {
+	out := new(GetImageLayerInfoResponse)
+	err := grpc.Invoke(ctx, "/containerd.services.images.v1.Images/GetImageLayerInfo", in, out, c.cc, opts...)
 	if err != nil {
 		return nil, err
 	}
@@ -403,7 +417,7 @@ type ImagesServer interface {
 	// Decyrpt an image given its name
 	DecryptImage(context.Context, *DecryptImageRequest) (*DecryptImageResponse, error)
 	// Get the KeyIds of keys the image is encrypted with
-	GetImageKeyIds(context.Context, *GetImageKeyIdsRequest) (*GetImageKeyIdsResponse, error)
+	GetImageLayerInfo(context.Context, *GetImageLayerInfoRequest) (*GetImageLayerInfoResponse, error)
 }
 
 func RegisterImagesServer(s *grpc.Server, srv ImagesServer) {
@@ -536,20 +550,20 @@ func _Images_DecryptImage_Handler(srv interface{}, ctx context.Context, dec func
 	return interceptor(ctx, in, info, handler)
 }
 
-func _Images_GetImageKeyIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
-	in := new(GetImageKeyIdsRequest)
+func _Images_GetImageLayerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	in := new(GetImageLayerInfoRequest)
 	if err := dec(in); err != nil {
 		return nil, err
 	}
 	if interceptor == nil {
-		return srv.(ImagesServer).GetImageKeyIds(ctx, in)
+		return srv.(ImagesServer).GetImageLayerInfo(ctx, in)
 	}
 	info := &grpc.UnaryServerInfo{
 		Server:     srv,
-		FullMethod: "/containerd.services.images.v1.Images/GetImageKeyIds",
+		FullMethod: "/containerd.services.images.v1.Images/GetImageLayerInfo",
 	}
 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
-		return srv.(ImagesServer).GetImageKeyIds(ctx, req.(*GetImageKeyIdsRequest))
+		return srv.(ImagesServer).GetImageLayerInfo(ctx, req.(*GetImageLayerInfoRequest))
 	}
 	return interceptor(ctx, in, info, handler)
 }
@@ -587,8 +601,8 @@ var _Images_serviceDesc = grpc.ServiceDesc{
 			Handler:    _Images_DecryptImage_Handler,
 		},
 		{
-			MethodName: "GetImageKeyIds",
-			Handler:    _Images_GetImageKeyIds_Handler,
+			MethodName: "GetImageLayerInfo",
+			Handler:    _Images_GetImageLayerInfo_Handler,
 		},
 	},
 	Streams:  []grpc.StreamDesc{},
@@ -1112,7 +1126,7 @@ func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
-func (m *GetImageKeyIdsRequest) Marshal() (dAtA []byte, err error) {
+func (m *GetImageLayerInfoRequest) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalTo(dAtA)
@@ -1122,7 +1136,7 @@ func (m *GetImageKeyIdsRequest) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *GetImageKeyIdsRequest) MarshalTo(dAtA []byte) (int, error) {
+func (m *GetImageLayerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
 	var i int
 	_ = i
 	var l int
@@ -1136,7 +1150,7 @@ func (m *GetImageKeyIdsRequest) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
-func (m *GetImageKeyIdsResponse) Marshal() (dAtA []byte, err error) {
+func (m *LayerInfo) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
 	n, err := m.MarshalTo(dAtA)
@@ -1146,15 +1160,15 @@ func (m *GetImageKeyIdsResponse) Marshal() (dAtA []byte, err error) {
 	return dAtA[:n], nil
 }
 
-func (m *GetImageKeyIdsResponse) MarshalTo(dAtA []byte) (int, error) {
+func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 	var i int
 	_ = i
 	var l int
 	_ = l
-	if len(m.Keyids) > 0 {
-		dAtA15 := make([]byte, len(m.Keyids)*10)
+	if len(m.KeyIds) > 0 {
+		dAtA15 := make([]byte, len(m.KeyIds)*10)
 		var j14 int
-		for _, num := range m.Keyids {
+		for _, num := range m.KeyIds {
 			for num >= 1<<7 {
 				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
@@ -1168,6 +1182,59 @@ func (m *GetImageKeyIdsResponse) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(j14))
 		i += copy(dAtA[i:], dAtA15[:j14])
 	}
+	if len(m.Digest) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Digest)))
+		i += copy(dAtA[i:], m.Digest)
+	}
+	if len(m.Encryption) > 0 {
+		dAtA[i] = 0x1a
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Encryption)))
+		i += copy(dAtA[i:], m.Encryption)
+	}
+	if m.FileSize != 0 {
+		dAtA[i] = 0x20
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(m.FileSize))
+	}
+	if len(m.Architecture) > 0 {
+		dAtA[i] = 0x2a
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Architecture)))
+		i += copy(dAtA[i:], m.Architecture)
+	}
+	return i, nil
+}
+
+func (m *GetImageLayerInfoResponse) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *GetImageLayerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.LayerInfo) > 0 {
+		for _, msg := range m.LayerInfo {
+			dAtA[i] = 0xa
+			i++
+			i = encodeVarintImages(dAtA, i, uint64(msg.Size()))
+			n, err := msg.MarshalTo(dAtA[i:])
+			if err != nil {
+				return 0, err
+			}
+			i += n
+		}
+	}
 	return i, nil
 }
 
@@ -1371,7 +1438,7 @@ func (m *DecryptImageResponse) Size() (n int) {
 	return n
 }
 
-func (m *GetImageKeyIdsRequest) Size() (n int) {
+func (m *GetImageLayerInfoRequest) Size() (n int) {
 	var l int
 	_ = l
 	l = len(m.Name)
@@ -1381,16 +1448,43 @@ func (m *GetImageKeyIdsRequest) Size() (n int) {
 	return n
 }
 
-func (m *GetImageKeyIdsResponse) Size() (n int) {
+func (m *LayerInfo) Size() (n int) {
 	var l int
 	_ = l
-	if len(m.Keyids) > 0 {
+	if len(m.KeyIds) > 0 {
 		l = 0
-		for _, e := range m.Keyids {
+		for _, e := range m.KeyIds {
 			l += sovImages(uint64(e))
 		}
 		n += 1 + sovImages(uint64(l)) + l
 	}
+	l = len(m.Digest)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	l = len(m.Encryption)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	if m.FileSize != 0 {
+		n += 1 + sovImages(uint64(m.FileSize))
+	}
+	l = len(m.Architecture)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	return n
+}
+
+func (m *GetImageLayerInfoResponse) Size() (n int) {
+	var l int
+	_ = l
+	if len(m.LayerInfo) > 0 {
+		for _, e := range m.LayerInfo {
+			l = e.Size()
+			n += 1 + l + sovImages(uint64(l))
+		}
+	}
 	return n
 }
 
@@ -1587,22 +1681,36 @@ func (this *DecryptImageResponse) String() string {
 	}, "")
 	return s
 }
-func (this *GetImageKeyIdsRequest) String() string {
+func (this *GetImageLayerInfoRequest) String() string {
 	if this == nil {
 		return "nil"
 	}
-	s := strings.Join([]string{`&GetImageKeyIdsRequest{`,
+	s := strings.Join([]string{`&GetImageLayerInfoRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`}`,
 	}, "")
 	return s
 }
-func (this *GetImageKeyIdsResponse) String() string {
+func (this *LayerInfo) String() string {
 	if this == nil {
 		return "nil"
 	}
-	s := strings.Join([]string{`&GetImageKeyIdsResponse{`,
-		`Keyids:` + fmt.Sprintf("%v", this.Keyids) + `,`,
+	s := strings.Join([]string{`&LayerInfo{`,
+		`KeyIds:` + fmt.Sprintf("%v", this.KeyIds) + `,`,
+		`Digest:` + fmt.Sprintf("%v", this.Digest) + `,`,
+		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
+		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
+		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
+		`}`,
+	}, "")
+	return s
+}
+func (this *GetImageLayerInfoResponse) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&GetImageLayerInfoResponse{`,
+		`LayerInfo:` + strings.Replace(fmt.Sprintf("%v", this.LayerInfo), "LayerInfo", "LayerInfo", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -3278,7 +3386,7 @@ func (m *DecryptImageResponse) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *GetImageKeyIdsRequest) Unmarshal(dAtA []byte) error {
+func (m *GetImageLayerInfoRequest) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -3301,10 +3409,10 @@ func (m *GetImageKeyIdsRequest) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: GetImageKeyIdsRequest: wiretype end group for non-group")
+			return fmt.Errorf("proto: GetImageLayerInfoRequest: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: GetImageKeyIdsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: GetImageLayerInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
@@ -3357,7 +3465,7 @@ func (m *GetImageKeyIdsRequest) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
-func (m *GetImageKeyIdsResponse) Unmarshal(dAtA []byte) error {
+func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
 	for iNdEx < l {
@@ -3380,10 +3488,10 @@ func (m *GetImageKeyIdsResponse) Unmarshal(dAtA []byte) error {
 		fieldNum := int32(wire >> 3)
 		wireType := int(wire & 0x7)
 		if wireType == 4 {
-			return fmt.Errorf("proto: GetImageKeyIdsResponse: wiretype end group for non-group")
+			return fmt.Errorf("proto: LayerInfo: wiretype end group for non-group")
 		}
 		if fieldNum <= 0 {
-			return fmt.Errorf("proto: GetImageKeyIdsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+			return fmt.Errorf("proto: LayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
 		case 1:
@@ -3403,7 +3511,7 @@ func (m *GetImageKeyIdsResponse) Unmarshal(dAtA []byte) error {
 						break
 					}
 				}
-				m.Keyids = append(m.Keyids, v)
+				m.KeyIds = append(m.KeyIds, v)
 			} else if wireType == 2 {
 				var packedLen int
 				for shift := uint(0); ; shift += 7 {
@@ -3443,11 +3551,198 @@ func (m *GetImageKeyIdsResponse) Unmarshal(dAtA []byte) error {
 							break
 						}
 					}
-					m.Keyids = append(m.Keyids, v)
+					m.KeyIds = append(m.KeyIds, v)
 				}
 			} else {
-				return fmt.Errorf("proto: wrong wireType = %d for field Keyids", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
+			}
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
 			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Digest = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Encryption = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		case 4:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
+			}
+			m.FileSize = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.FileSize |= (int64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Architecture = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
+func (m *GetImageLayerInfoResponse) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: GetImageLayerInfoResponse: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: GetImageLayerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field LayerInfo", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.LayerInfo = append(m.LayerInfo, &LayerInfo{})
+			if err := m.LayerInfo[len(m.LayerInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3579,60 +3874,65 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 867 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x41, 0x6f, 0xe3, 0x54,
-	0x10, 0xae, 0x93, 0xd4, 0x6d, 0x27, 0x2d, 0xbb, 0xbc, 0x2d, 0x95, 0x65, 0x20, 0x8d, 0xac, 0x45,
-	0xaa, 0x04, 0xd8, 0xdb, 0x2c, 0x48, 0xd0, 0xae, 0x10, 0xdb, 0xa6, 0x2c, 0x2b, 0x96, 0x3d, 0x18,
-	0x16, 0x22, 0x2e, 0x2b, 0xc7, 0x99, 0x18, 0x2b, 0x89, 0x6d, 0xfc, 0x5e, 0x52, 0xf9, 0x80, 0x04,
-	0x07, 0xee, 0x48, 0xfc, 0xa9, 0x1e, 0x39, 0x72, 0x02, 0x36, 0x07, 0x7e, 0x07, 0xf2, 0x7b, 0xcf,
-	0xd4, 0x4e, 0xa2, 0x75, 0x52, 0xa2, 0xbd, 0xcd, 0x7b, 0x99, 0x6f, 0x66, 0xbe, 0x6f, 0xde, 0x4c,
-	0x0c, 0x6d, 0xcf, 0x67, 0xdf, 0x8f, 0xbb, 0xa6, 0x1b, 0x8e, 0x2c, 0x37, 0x0c, 0x98, 0xe3, 0x07,
-	0x18, 0xf7, 0xf2, 0xa6, 0x13, 0xf9, 0x16, 0xc5, 0x78, 0xe2, 0xbb, 0x48, 0x2d, 0x7f, 0xe4, 0x78,
-	0x48, 0xad, 0xc9, 0xb1, 0xb4, 0xcc, 0x28, 0x0e, 0x59, 0x48, 0xde, 0xbe, 0xf6, 0x37, 0x33, 0x5f,
-	0x53, 0x7a, 0x4c, 0x8e, 0xf5, 0x7d, 0x2f, 0xf4, 0x42, 0xee, 0x69, 0xa5, 0x96, 0x00, 0xe9, 0x6f,
-	0x7a, 0x61, 0xe8, 0x0d, 0xd1, 0xe2, 0xa7, 0xee, 0xb8, 0x6f, 0xe1, 0x28, 0x62, 0x89, 0xfc, 0xb1,
-	0x39, 0xfb, 0x63, 0xdf, 0xc7, 0x61, 0xef, 0xf9, 0xc8, 0xa1, 0x03, 0xe9, 0x71, 0x38, 0xeb, 0xc1,
-	0xfc, 0x11, 0x52, 0xe6, 0x8c, 0x22, 0xe9, 0x70, 0xba, 0x14, 0x35, 0x96, 0x44, 0x48, 0xad, 0x1e,
-	0x52, 0x37, 0xf6, 0x23, 0x16, 0xc6, 0x02, 0x6c, 0xfc, 0x53, 0x81, 0xcd, 0xc7, 0x29, 0x01, 0x42,
-	0xa0, 0x16, 0x38, 0x23, 0xd4, 0x94, 0xa6, 0x72, 0xb4, 0x63, 0x73, 0x9b, 0x7c, 0x0e, 0xea, 0xd0,
-	0xe9, 0xe2, 0x90, 0x6a, 0x95, 0x66, 0xf5, 0xa8, 0xde, 0xba, 0x67, 0xbe, 0x54, 0x00, 0x93, 0x47,
-	0x32, 0x9f, 0x70, 0xc8, 0x45, 0xc0, 0xe2, 0xc4, 0x96, 0x78, 0x72, 0x02, 0x2a, 0x73, 0x62, 0x0f,
-	0x99, 0x56, 0x6d, 0x2a, 0x47, 0xf5, 0xd6, 0x5b, 0xf9, 0x48, 0xbc, 0x36, 0xb3, 0xfd, 0x5f, 0x6d,
-	0x67, 0xb5, 0xab, 0x3f, 0x0f, 0x37, 0x6c, 0x89, 0x20, 0xe7, 0x00, 0x6e, 0x8c, 0x0e, 0xc3, 0xde,
-	0x73, 0x87, 0x69, 0x5b, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33, 0x93, 0xc5, 0xfc, 0x3a, 0x93, 0xe5,
-	0x6c, 0x3b, 0x45, 0xff, 0xfa, 0xd7, 0xa1, 0x62, 0xef, 0x48, 0xdc, 0x43, 0x1e, 0x64, 0x1c, 0xf5,
-	0xb2, 0x20, 0xdb, 0xab, 0x04, 0x91, 0xb8, 0x87, 0x4c, 0xff, 0x18, 0xea, 0x39, 0x72, 0xe4, 0x36,
-	0x54, 0x07, 0x98, 0x48, 0xc5, 0x52, 0x93, 0xec, 0xc3, 0xe6, 0xc4, 0x19, 0x8e, 0x51, 0xab, 0xf0,
-	0x3b, 0x71, 0x38, 0xa9, 0x7c, 0xa4, 0x18, 0xef, 0xc0, 0xad, 0x47, 0xc8, 0xb8, 0x40, 0x36, 0xfe,
-	0x30, 0x46, 0xca, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0xd7, 0x6e, 0x34, 0x0a, 0x03, 0x8a, 0xe4,
-	0x04, 0x36, 0xb9, 0xc4, 0xdc, 0xb1, 0xde, 0xba, 0xbb, 0x4c, 0x13, 0x6c, 0x01, 0x31, 0xbe, 0x01,
-	0x72, 0xce, 0x35, 0x28, 0x64, 0xfe, 0xf4, 0x06, 0x11, 0x65, 0x53, 0x64, 0xdc, 0x6f, 0xe1, 0x4e,
-	0x21, 0xae, 0x2c, 0xf5, 0xff, 0x07, 0xfe, 0x4d, 0x01, 0xf2, 0x8c, 0x0b, 0xbe, 0xde, 0x8a, 0xc9,
-	0x29, 0xd4, 0x45, 0x23, 0xf9, 0x70, 0xf1, 0x06, 0x2d, 0x7a, 0x01, 0x9f, 0xa5, 0xf3, 0xf7, 0xa5,
-	0x43, 0x07, 0xb6, 0x7c, 0x2f, 0xa9, 0x9d, 0xd2, 0x2d, 0x14, 0xb5, 0x36, 0xba, 0xef, 0xc3, 0xeb,
-	0x4f, 0x7c, 0x2a, 0x1a, 0x4e, 0x33, 0xb2, 0x1a, 0x6c, 0xf5, 0xfd, 0x21, 0xc3, 0x98, 0x6a, 0x4a,
-	0xb3, 0x7a, 0xb4, 0x63, 0x67, 0x47, 0xa3, 0x03, 0x24, 0xef, 0x2e, 0xcb, 0x38, 0x03, 0x55, 0x24,
-	0xe1, 0xee, 0xab, 0xd5, 0x21, 0x91, 0xc6, 0x03, 0x20, 0x6d, 0x1c, 0xe2, 0x8c, 0xec, 0x8b, 0x96,
-	0x02, 0x81, 0x1a, 0x4d, 0x02, 0x97, 0x2b, 0xb8, 0x6d, 0x73, 0xdb, 0x78, 0x06, 0x7b, 0x17, 0x81,
-	0x1b, 0x27, 0x11, 0x3b, 0x0f, 0x83, 0xbe, 0xef, 0x91, 0x06, 0x40, 0x8c, 0xae, 0x1f, 0xf9, 0x18,
-	0xb0, 0x8c, 0x45, 0xee, 0x86, 0xdc, 0x85, 0x3d, 0x2f, 0xf2, 0xa2, 0x71, 0x77, 0x80, 0x49, 0xec,
-	0x07, 0x1e, 0x8f, 0xb6, 0x6b, 0x17, 0x2f, 0x8d, 0x5b, 0xb0, 0xd7, 0xc6, 0x5c, 0x58, 0xe3, 0x67,
-	0x05, 0xee, 0xc8, 0x44, 0xa5, 0x75, 0x6a, 0xb0, 0x15, 0xe0, 0xe5, 0xd3, 0xf4, 0x5a, 0x4c, 0x63,
-	0x76, 0x24, 0x0f, 0xa0, 0xe2, 0xba, 0x72, 0x11, 0xbd, 0x57, 0xa2, 0x55, 0x81, 0x96, 0x5d, 0x71,
-	0x5d, 0xa3, 0x03, 0xfb, 0xc5, 0x12, 0xd6, 0xf6, 0x18, 0x52, 0x76, 0x92, 0xef, 0x2b, 0x62, 0x57,
-	0x50, 0x37, 0x63, 0x57, 0x2c, 0x61, 0x6d, 0xec, 0xde, 0x85, 0x37, 0xb2, 0xd5, 0xf6, 0x05, 0x26,
-	0x8f, 0x7b, 0xf4, 0x65, 0x7b, 0xf0, 0x1e, 0x1c, 0xcc, 0x3a, 0xcb, 0x42, 0x0e, 0x40, 0x1d, 0x60,
-	0xe2, 0xf7, 0xc4, 0xab, 0xaa, 0xd9, 0xf2, 0xd4, 0xfa, 0x65, 0x0b, 0x54, 0x31, 0x17, 0xa4, 0x0f,
-	0xd5, 0x47, 0xc8, 0x88, 0x59, 0x52, 0xe3, 0xcc, 0x3e, 0xd6, 0xad, 0xa5, 0xfd, 0x65, 0x29, 0x03,
-	0xa8, 0xa5, 0xd3, 0x48, 0xca, 0xfe, 0x16, 0xe7, 0x26, 0x5c, 0x3f, 0x5e, 0x01, 0x21, 0x93, 0x85,
-	0xa0, 0x8a, 0x8d, 0x4b, 0xca, 0xc0, 0xf3, 0x0b, 0x5f, 0x6f, 0xad, 0x02, 0xb9, 0x4e, 0x28, 0x76,
-	0x5e, 0x69, 0xc2, 0xf9, 0x7d, 0x5d, 0x9a, 0x70, 0xd1, 0x36, 0xfd, 0x0a, 0x54, 0xb1, 0x82, 0x4a,
-	0x13, 0xce, 0x6f, 0x2a, 0xfd, 0x60, 0x6e, 0x93, 0x5f, 0xa4, 0x9f, 0x59, 0xe4, 0x12, 0x76, 0xf3,
-	0xd3, 0x4a, 0x5a, 0xcb, 0xcd, 0x7b, 0x21, 0xf6, 0xfd, 0x95, 0x30, 0x92, 0xcd, 0x25, 0xec, 0xe6,
-	0x07, 0xa9, 0x34, 0xf1, 0x82, 0xc1, 0x2f, 0x4d, 0xbc, 0x70, 0x52, 0x7f, 0x84, 0xd7, 0x8a, 0xa3,
-	0x43, 0x3e, 0x58, 0xf2, 0x61, 0x17, 0xc6, 0x52, 0xff, 0x70, 0x45, 0x94, 0x48, 0x7f, 0xd6, 0xb9,
-	0x7a, 0xd1, 0xd8, 0xf8, 0xe3, 0x45, 0x63, 0xe3, 0xa7, 0x69, 0x43, 0xb9, 0x9a, 0x36, 0x94, 0xdf,
-	0xa7, 0x0d, 0xe5, 0xef, 0x69, 0x43, 0xf9, 0xee, 0x93, 0x1b, 0x7e, 0x83, 0x9f, 0x0a, 0xab, 0xb3,
-	0xd1, 0x55, 0x79, 0x73, 0xef, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xd6, 0xf5, 0x39, 0x31, 0xce,
-	0x0b, 0x00, 0x00,
+	// 949 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcf, 0x73, 0xdb, 0x44,
+	0x14, 0x8e, 0x6c, 0xc7, 0x89, 0x9f, 0x93, 0x69, 0xbb, 0xcd, 0x74, 0x84, 0x00, 0xc7, 0xa3, 0x29,
+	0x33, 0x3e, 0x80, 0x44, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0x34, 0x3f, 0x5a, 0x32, 0x13, 0x7a, 0x50,
+	0x29, 0x64, 0xb8, 0x74, 0x64, 0xf9, 0x59, 0xdd, 0xb1, 0x2c, 0x09, 0x69, 0x9d, 0x8c, 0x38, 0xc1,
+	0x85, 0x2b, 0xcc, 0x70, 0xe4, 0x1f, 0xca, 0x91, 0x23, 0x27, 0xa0, 0x39, 0xf0, 0x77, 0x30, 0xda,
+	0x5d, 0xc5, 0x92, 0xed, 0xa9, 0xec, 0xe2, 0xe1, 0xf6, 0xf6, 0xe9, 0x7d, 0xef, 0xc7, 0xb7, 0xbb,
+	0xdf, 0xda, 0x70, 0xec, 0x52, 0xf6, 0x6a, 0xdc, 0x33, 0x9c, 0x60, 0x64, 0x3a, 0x81, 0xcf, 0x6c,
+	0xea, 0x63, 0xd4, 0xcf, 0x9b, 0x76, 0x48, 0xcd, 0x18, 0xa3, 0x0b, 0xea, 0x60, 0x6c, 0xd2, 0x91,
+	0xed, 0x62, 0x6c, 0x5e, 0xec, 0x49, 0xcb, 0x08, 0xa3, 0x80, 0x05, 0xe4, 0xfd, 0x49, 0xbc, 0x91,
+	0xc5, 0x1a, 0x32, 0xe2, 0x62, 0x4f, 0xdb, 0x71, 0x03, 0x37, 0xe0, 0x91, 0x66, 0x6a, 0x09, 0x90,
+	0xf6, 0xae, 0x1b, 0x04, 0xae, 0x87, 0x26, 0x5f, 0xf5, 0xc6, 0x03, 0x13, 0x47, 0x21, 0x4b, 0xe4,
+	0xc7, 0xf6, 0xf4, 0xc7, 0x01, 0x45, 0xaf, 0xff, 0x72, 0x64, 0xc7, 0x43, 0x19, 0xb1, 0x3b, 0x1d,
+	0xc1, 0xe8, 0x08, 0x63, 0x66, 0x8f, 0x42, 0x19, 0x70, 0xb0, 0xd0, 0x68, 0x2c, 0x09, 0x31, 0x36,
+	0xfb, 0x18, 0x3b, 0x11, 0x0d, 0x59, 0x10, 0x09, 0xb0, 0xfe, 0x4f, 0x05, 0xd6, 0x4f, 0xd3, 0x01,
+	0x08, 0x81, 0x9a, 0x6f, 0x8f, 0x50, 0x55, 0xda, 0x4a, 0xa7, 0x61, 0x71, 0x9b, 0x7c, 0x01, 0x75,
+	0xcf, 0xee, 0xa1, 0x17, 0xab, 0x95, 0x76, 0xb5, 0xd3, 0xec, 0x7e, 0x6c, 0xbc, 0x91, 0x00, 0x83,
+	0x67, 0x32, 0xce, 0x38, 0xe4, 0xc4, 0x67, 0x51, 0x62, 0x49, 0x3c, 0xd9, 0x87, 0x3a, 0xb3, 0x23,
+	0x17, 0x99, 0x5a, 0x6d, 0x2b, 0x9d, 0x66, 0xf7, 0xbd, 0x7c, 0x26, 0xde, 0x9b, 0x71, 0x7c, 0xd3,
+	0xdb, 0x61, 0xed, 0xea, 0xcf, 0xdd, 0x35, 0x4b, 0x22, 0xc8, 0x11, 0x80, 0x13, 0xa1, 0xcd, 0xb0,
+	0xff, 0xd2, 0x66, 0xea, 0x06, 0xc7, 0x6b, 0x86, 0xa0, 0xc5, 0xc8, 0x68, 0x31, 0xbe, 0xca, 0x68,
+	0x39, 0xdc, 0x4c, 0xd1, 0xbf, 0xfc, 0xb5, 0xab, 0x58, 0x0d, 0x89, 0x7b, 0xcc, 0x93, 0x8c, 0xc3,
+	0x7e, 0x96, 0x64, 0x73, 0x99, 0x24, 0x12, 0xf7, 0x98, 0x69, 0x9f, 0x42, 0x33, 0x37, 0x1c, 0xb9,
+	0x0d, 0xd5, 0x21, 0x26, 0x92, 0xb1, 0xd4, 0x24, 0x3b, 0xb0, 0x7e, 0x61, 0x7b, 0x63, 0x54, 0x2b,
+	0xdc, 0x27, 0x16, 0xfb, 0x95, 0x87, 0x8a, 0xfe, 0x01, 0xdc, 0x7a, 0x8a, 0x8c, 0x13, 0x64, 0xe1,
+	0x77, 0x63, 0x8c, 0xd9, 0x3c, 0xc6, 0xf5, 0x67, 0x70, 0x7b, 0x12, 0x16, 0x87, 0x81, 0x1f, 0x23,
+	0xd9, 0x87, 0x75, 0x4e, 0x31, 0x0f, 0x6c, 0x76, 0xef, 0x2f, 0xb2, 0x09, 0x96, 0x80, 0xe8, 0x5f,
+	0x03, 0x39, 0xe2, 0x1c, 0x14, 0x2a, 0x7f, 0xfe, 0x16, 0x19, 0xe5, 0xa6, 0xc8, 0xbc, 0xdf, 0xc0,
+	0xdd, 0x42, 0x5e, 0xd9, 0xea, 0x7f, 0x4f, 0xfc, 0xab, 0x02, 0xe4, 0x05, 0x27, 0x7c, 0xb5, 0x1d,
+	0x93, 0x03, 0x68, 0x8a, 0x8d, 0xe4, 0x97, 0x8b, 0x6f, 0xd0, 0xbc, 0x13, 0xf0, 0x24, 0xbd, 0x7f,
+	0x5f, 0xda, 0xf1, 0xd0, 0x92, 0xe7, 0x25, 0xb5, 0xd3, 0x71, 0x0b, 0x4d, 0xad, 0x6c, 0xdc, 0x8f,
+	0xe0, 0xce, 0x19, 0x8d, 0xc5, 0x86, 0xc7, 0xd9, 0xb0, 0x2a, 0x6c, 0x0c, 0xa8, 0xc7, 0x30, 0x8a,
+	0x55, 0xa5, 0x5d, 0xed, 0x34, 0xac, 0x6c, 0xa9, 0x9f, 0x03, 0xc9, 0x87, 0xcb, 0x36, 0x0e, 0xa1,
+	0x2e, 0x8a, 0xf0, 0xf0, 0xe5, 0xfa, 0x90, 0x48, 0xfd, 0x11, 0x90, 0x63, 0xf4, 0x70, 0x8a, 0xf6,
+	0x79, 0xa2, 0x40, 0xa0, 0x16, 0x27, 0xbe, 0xc3, 0x19, 0xdc, 0xb4, 0xb8, 0xad, 0xbf, 0x80, 0xed,
+	0x13, 0xdf, 0x89, 0x92, 0x90, 0x1d, 0x05, 0xfe, 0x80, 0xba, 0xa4, 0x05, 0x10, 0xa1, 0x43, 0x43,
+	0x8a, 0x3e, 0xcb, 0xa6, 0xc8, 0x79, 0xc8, 0x7d, 0xd8, 0x76, 0x43, 0x37, 0x1c, 0xf7, 0x86, 0x98,
+	0x44, 0xd4, 0x77, 0x79, 0xb6, 0x2d, 0xab, 0xe8, 0xd4, 0x6f, 0xc1, 0xf6, 0x31, 0xe6, 0xd2, 0xea,
+	0x3f, 0x2a, 0x70, 0x57, 0x16, 0x2a, 0xed, 0x53, 0x85, 0x0d, 0x1f, 0x2f, 0x9f, 0xa5, 0x6e, 0x71,
+	0x1b, 0xb3, 0x25, 0x79, 0x04, 0x15, 0xc7, 0x91, 0x42, 0xf4, 0x61, 0x09, 0x57, 0x85, 0xb1, 0xac,
+	0x8a, 0xe3, 0xe8, 0xe7, 0xb0, 0x53, 0x6c, 0x61, 0x65, 0x87, 0x21, 0x9d, 0x4e, 0xce, 0xfb, 0x3f,
+	0x4d, 0x57, 0x60, 0x37, 0x9b, 0xae, 0xd8, 0xc2, 0xca, 0xa6, 0x33, 0x40, 0xcd, 0xa4, 0xed, 0xcc,
+	0x4e, 0x30, 0x3a, 0xf5, 0x07, 0xc1, 0x9b, 0xa4, 0xf0, 0x37, 0x05, 0x1a, 0x37, 0x81, 0xe4, 0x1e,
+	0xd4, 0x87, 0x98, 0x9c, 0xf6, 0xc5, 0x61, 0xaa, 0x59, 0x72, 0x95, 0xfa, 0xfb, 0xd4, 0xc5, 0x98,
+	0x49, 0x1a, 0xe4, 0x2a, 0x3d, 0x80, 0x28, 0x76, 0x89, 0x06, 0x3e, 0x67, 0xa3, 0x61, 0xe5, 0x3c,
+	0x44, 0x83, 0xcd, 0x01, 0xf5, 0xf0, 0x39, 0xfd, 0x1e, 0xd5, 0x5a, 0x5b, 0xe9, 0x54, 0xad, 0x9b,
+	0x35, 0xd1, 0x61, 0xcb, 0x8e, 0x9c, 0x57, 0x94, 0xa1, 0xc3, 0xc6, 0x11, 0xaa, 0xeb, 0x1c, 0x5d,
+	0xf0, 0xe9, 0x0e, 0xbc, 0x33, 0x67, 0x1a, 0x49, 0xd6, 0x13, 0x68, 0x78, 0x99, 0x53, 0xde, 0xc9,
+	0x4e, 0x09, 0x61, 0x93, 0x24, 0x13, 0x68, 0xf7, 0xe7, 0x0d, 0xa8, 0x8b, 0xbb, 0x4e, 0x06, 0x50,
+	0x7d, 0x8a, 0x8c, 0x18, 0x25, 0x69, 0xa6, 0xde, 0x18, 0xcd, 0x5c, 0x38, 0x5e, 0xb6, 0x3e, 0x84,
+	0x5a, 0xaa, 0x30, 0xa4, 0xec, 0xa9, 0x9f, 0x51, 0x2d, 0x6d, 0x6f, 0x09, 0x84, 0x2c, 0x16, 0x40,
+	0x5d, 0xbc, 0x22, 0xa4, 0x0c, 0x3c, 0xfb, 0x88, 0x69, 0xdd, 0x65, 0x20, 0x93, 0x82, 0x42, 0xc7,
+	0x4b, 0x0b, 0xce, 0xbe, 0x41, 0xa5, 0x05, 0xe7, 0xbd, 0x10, 0xcf, 0xa1, 0x2e, 0x64, 0xb5, 0xb4,
+	0xe0, 0xac, 0xfa, 0x6a, 0xf7, 0x66, 0x5e, 0xa7, 0x93, 0xf4, 0xa7, 0x23, 0xb9, 0x84, 0xad, 0xbc,
+	0x02, 0x91, 0xee, 0x62, 0x1a, 0x56, 0xc8, 0xfd, 0x60, 0x29, 0x8c, 0x9c, 0xe6, 0x12, 0xb6, 0xf2,
+	0xe2, 0x50, 0x5a, 0x78, 0x8e, 0x98, 0x95, 0x16, 0x9e, 0xab, 0x3e, 0x3f, 0x29, 0x70, 0x67, 0xe6,
+	0xba, 0x91, 0x4f, 0x16, 0x3c, 0xdc, 0xd3, 0x72, 0xa3, 0x3d, 0x5c, 0x1e, 0x28, 0x1a, 0x39, 0x3c,
+	0xbf, 0x7a, 0xdd, 0x5a, 0xfb, 0xe3, 0x75, 0x6b, 0xed, 0x87, 0xeb, 0x96, 0x72, 0x75, 0xdd, 0x52,
+	0x7e, 0xbf, 0x6e, 0x29, 0x7f, 0x5f, 0xb7, 0x94, 0x6f, 0x3f, 0x7b, 0xcb, 0x7f, 0x18, 0x07, 0xc2,
+	0x3a, 0x5f, 0xeb, 0xd5, 0xf9, 0x36, 0x3f, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xdb, 0x6e,
+	0xab, 0xac, 0x0c, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index fee1432..72fc8b1 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -45,7 +45,7 @@ service Images {
 	// Decyrpt an image given its name
 	rpc DecryptImage(DecryptImageRequest) returns (DecryptImageResponse);
 	// Get the KeyIds of keys the image is encrypted with
-	rpc GetImageKeyIds(GetImageKeyIdsRequest) returns (GetImageKeyIdsResponse);
+	rpc GetImageLayerInfo(GetImageLayerInfoRequest) returns (GetImageLayerInfoResponse);
 }
 
 message Image {
@@ -161,11 +161,20 @@ message DecryptImageResponse {
 	Image image = 1 [(gogoproto.nullable) = false];
 }
 
-message GetImageKeyIdsRequest {
+message GetImageLayerInfoRequest {
 	string name = 1;
+	string platform = 2;
 }
 
-message GetImageKeyIdsResponse {
-	repeated uint64 keyids = 1;
+message LayerInfo {
+	repeated uint64 keyIds = 1;
+	string digest = 2;
+	string encryption = 3;
+	int64 fileSize = 4;
+	string architecture = 5;
+}
+
+message GetImageLayerInfoResponse {
+	repeated LayerInfo layerInfo = 1;
 }
 
diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 5496afe..c7814df 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -55,10 +55,15 @@ var decryptCommand = cli.Command{
 		}
 		defer cancel()
 
-		keyIds, err := client.ImageService().GetImageKeyIds(ctx, local)
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local)
 		if err != nil {
 			return err
 		}
+		var keyIds []uint64
+		for i := 0; i < len(LayerInfos); i++ {
+			keyIds = addToSet(keyIds, LayerInfos[i].KeyIds)
+		}
+
 		if len(keyIds) == 0 {
 			fmt.Printf("Image is not encrypted.\n")
 		} else {
@@ -72,3 +77,19 @@ var decryptCommand = cli.Command{
 	},
 }
 
+func addToSet(set, add []uint64) []uint64 {
+	for i := 0; i < len(add); i++ {
+		found := false
+		for j := 0; j < len(set); j++ {
+			if set[j] == add[i] {
+				found = true
+				break;
+			}
+		}
+		if !found {
+			set = append(set, add[i])
+		}
+	}
+	return set
+}
+
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 389226c..e133d6e 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -55,10 +55,6 @@ var encryptCommand = cli.Command{
 			return err
 		}
 		defer cancel()
-		//img, err := client.ImageService().Get(ctx, local)
-		//if err != nil {
-		//	return errors.Wrap(err, "unable to resolve image to manifest")
-		//}
 
 		recipients := context.StringSlice("recipient")
 		if len(recipients) == 0 {
diff --git a/image_store.go b/image_store.go
index d2d76dd..1777013 100644
--- a/image_store.go
+++ b/image_store.go
@@ -83,16 +83,25 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, e
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) GetImageKeyIds(ctx context.Context, name string) ([]uint64, error) {
+func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string) ([]images.LayerInfo, error) {
 	fmt.Printf("image_store.go: GetImageKeyIds() name=%s\n", name);
-	resp, err := s.client.GetImageKeyIds(ctx, &imagesapi.GetImageKeyIdsRequest{
+	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
 		Name:    name,
 	});
 	if err != nil {
-		return []uint64{}, errdefs.FromGRPC(err)
+		return []images.LayerInfo{}, errdefs.FromGRPC(err)
 	}
 
-	return resp.Keyids, nil
+	li := make([]images.LayerInfo, len(resp.LayerInfo))
+	for i := 0; i < len(resp.LayerInfo); i++ {
+		li[i].KeyIds = resp.LayerInfo[i].KeyIds
+		li[i].Digest = resp.LayerInfo[i].Digest
+		li[i].Encryption = resp.LayerInfo[i].Encryption
+		li[i].FileSize = resp.LayerInfo[i].FileSize
+		li[i].Architecture = resp.LayerInfo[i].Architecture
+	}
+
+	return li, nil
 }
 
 func (s *remoteImages) List(ctx context.Context, filters ...string) ([]images.Image, error) {
diff --git a/images/image.go b/images/image.go
index 760f685..07407b0 100644
--- a/images/image.go
+++ b/images/image.go
@@ -59,6 +59,14 @@ type Image struct {
 	CreatedAt, UpdatedAt time.Time
 }
 
+type LayerInfo struct {
+	KeyIds []uint64
+	Digest string
+	Encryption string
+	FileSize int64
+	Architecture string
+}
+
 // DeleteOptions provide options on image delete
 type DeleteOptions struct {
 	Synchronous bool
@@ -90,7 +98,7 @@ type Store interface {
 
 	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
 	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
-	GetImageKeyIds(ctx context.Context, name string) ([]uint64, error)
+	GetImageLayerInfo(ctx context.Context, name string) ([]LayerInfo, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -527,47 +535,62 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
-func GetImageKeyIds(ctx context.Context, cs content.Store, desc ocispec.Descriptor) ([]uint64, error) {
-	var keyids []uint64
+func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor) ([]LayerInfo, error) {
+	var (
+		lis []LayerInfo
+		Architecture string
+	)
 
 	switch (desc.MediaType) {
 	case MediaTypeDockerSchema2ManifestList,
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
+		if desc.Platform != nil {
+			Architecture = desc.Platform.Architecture
+		}
 		if err != nil {
-			return []uint64{}, err
+			return []LayerInfo{}, err
 		}
 		for _, child := range children {
-			kids, err := GetImageKeyIds(ctx, cs, child)
+			tmp, err := GetImageLayerInfo(ctx, cs, child)
 			if err != nil {
-				return []uint64{}, err
+				return []LayerInfo{}, err
 			}
-			for i := 0; i < len(kids); i++ {
-				f := false
-				for j := 0; j < len(keyids); j++ {
-					if kids[i] == keyids[j] {
-						f = true
-						break
-					}
-				}
-				if !f {
-					keyids = append(keyids, kids[i])
-				}
+			for i := 0; i < len(tmp); i++ {
+				tmp[i].Architecture = Architecture
 			}
+			lis = append(lis, tmp...)
+		}
+	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip:
+		li := LayerInfo{
+			KeyIds:       []uint64{},
+			Digest:       desc.Digest.String(),
+			Encryption:   "",
+			FileSize:     desc.Size,
 		}
-	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip,
-		MediaTypeDockerSchema2Config:
+		lis = append(lis, li)
+	case MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
 		encData, err := content.ReadBlob(ctx, cs, desc);
 		if err != nil {
-			return []uint64{}, err
+			return []LayerInfo{}, err
+		}
+		kids, err := GetKeyIds(encData, desc)
+		if err != nil {
+			return []LayerInfo{}, err
+		}
+		li := LayerInfo{
+			KeyIds:       kids,
+			Digest:       desc.Digest.String(),
+			Encryption:   "gpg",
+			FileSize:     desc.Size,
 		}
-		return GetKeyIds(encData, desc)
+		lis = append(lis, li)
 	default:
-		return []uint64{}, errors.Wrapf(nil, "GetImageKeyIds: Unhandled media type %s", desc.MediaType)
+		return []LayerInfo{}, errors.Wrapf(nil, "GetImageLayerInfo: Unhandled media type %s", desc.MediaType)
 	}
 
-	return keyids, nil
+	return lis, nil
 }
 
 // Children returns the immediate children of content described by the descriptor.
diff --git a/metadata/images.go b/metadata/images.go
index 29d529d..d89b95e 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -197,13 +197,13 @@ func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc
 	return s.cryptImage(ctx, name, newName, cc, false)
 }
 
-func (s *imageStore) GetImageKeyIds(ctx context.Context, name string) ([]uint64, error) {
-	fmt.Printf("metadata/images.go: GetImageKeyIds() name=%s\n", name)
+func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string) ([]images.LayerInfo, error) {
+	fmt.Printf("metadata/images.go: GetImageLayerInfo() name=%s\n", name)
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
 	if err != nil {
-		return []uint64{}, err
+		return []images.LayerInfo{}, err
 	}
 
 	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
@@ -224,11 +224,11 @@ func (s *imageStore) GetImageKeyIds(ctx context.Context, name string) ([]uint64,
 
 		return nil
 	}); err != nil {
-		return []uint64{}, err
+		return []images.LayerInfo{}, err
 	}
 
 	cs := s.db.ContentStore()
-	return images.GetImageKeyIds(ctx, cs, image.Target)
+	return images.GetImageLayerInfo(ctx, cs, image.Target)
 }
 
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
diff --git a/services/images/local.go b/services/images/local.go
index c0cfd7f..69a1c92 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -230,17 +230,27 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 	return &resp, nil
 }
 
-func (l *local) GetImageKeyIds(ctx context.Context, req *imagesapi.GetImageKeyIdsRequest, _ ...grpc.CallOption) (*imagesapi.GetImageKeyIdsResponse, error) {
-	log.G(ctx).WithField("name", req.Name).Debugf("GetImageKeyIds")
+func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLayerInfoRequest, _ ...grpc.CallOption) (*imagesapi.GetImageLayerInfoResponse, error) {
+	log.G(ctx).WithField("name", req.Name).Debugf("GetImageLayerInfo")
 
-	var resp       imagesapi.GetImageKeyIdsResponse
+	var resp imagesapi.GetImageLayerInfoResponse
 
-	keyids, err := l.store.GetImageKeyIds(ctx, req.Name)
+	lis, err := l.store.GetImageLayerInfo(ctx, req.Name)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
 
-	resp.Keyids = keyids
+	resp.LayerInfo = make([]*imagesapi.LayerInfo, len(lis))
+	for i := 0; i < len(lis); i++ {
+		resp.LayerInfo[i] = &imagesapi.LayerInfo{
+			KeyIds:       lis[i].KeyIds,
+			Digest:       lis[i].Digest,
+			Encryption:   lis[i].Encryption,
+			FileSize:     lis[i].FileSize,
+			Architecture: lis[i].Architecture,
+		}
+	}
+
 	return &resp, nil
 }
 
diff --git a/services/images/service.go b/services/images/service.go
index 582f601..0ed16f1 100644
--- a/services/images/service.go
+++ b/services/images/service.go
@@ -91,6 +91,6 @@ func (s *service) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageR
 	return s.local.DecryptImage(ctx, req)
 }
 
-func (s *service) GetImageKeyIds(ctx context.Context, req *imagesapi.GetImageKeyIdsRequest) (*imagesapi.GetImageKeyIdsResponse, error) {
-	return s.local.GetImageKeyIds(ctx, req)
+func (s *service) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLayerInfoRequest) (*imagesapi.GetImageLayerInfoResponse, error) {
+	return s.local.GetImageLayerInfo(ctx, req)
 }
-- 
2.7.4


From 0f0858279192fb3b9cbbdbf489afc78493de7ec2 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 23 Jul 2018 09:39:52 -0400
Subject: [PATCH 12/79] Add an Id to each layer and fix architecture string
 assignment

---
 api/next.pb.txt                     |  24 +++-
 api/services/images/v1/images.pb.go | 224 ++++++++++++++++++++++++------------
 api/services/images/v1/images.proto |  11 +-
 image_store.go                      |   1 +
 images/image.go                     |  12 +-
 services/images/local.go            |   1 +
 6 files changed, 186 insertions(+), 87 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index fc65c5d..fbe16ea 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2325,40 +2325,54 @@ file {
       type: TYPE_STRING
       json_name: "name"
     }
+    field {
+      name: "platform"
+      number: 2
+      label: LABEL_OPTIONAL
+      type: TYPE_STRING
+      json_name: "platform"
+    }
   }
   message_type {
     name: "LayerInfo"
     field {
-      name: "keyIds"
+      name: "id"
       number: 1
+      label: LABEL_OPTIONAL
+      type: TYPE_UINT32
+      json_name: "id"
+    }
+    field {
+      name: "keyIds"
+      number: 2
       label: LABEL_REPEATED
       type: TYPE_UINT64
       json_name: "keyIds"
     }
     field {
       name: "digest"
-      number: 2
+      number: 3
       label: LABEL_OPTIONAL
       type: TYPE_STRING
       json_name: "digest"
     }
     field {
       name: "encryption"
-      number: 3
+      number: 4
       label: LABEL_OPTIONAL
       type: TYPE_STRING
       json_name: "encryption"
     }
     field {
       name: "fileSize"
-      number: 4
+      number: 5
       label: LABEL_OPTIONAL
       type: TYPE_INT64
       json_name: "fileSize"
     }
     field {
       name: "architecture"
-      number: 5
+      number: 6
       label: LABEL_OPTIONAL
       type: TYPE_STRING
       json_name: "architecture"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 6da3656..50febea 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -235,7 +235,8 @@ func (*DecryptImageResponse) ProtoMessage()               {}
 func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
 
 type GetImageLayerInfoRequest struct {
-	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Platform string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
 }
 
 func (m *GetImageLayerInfoRequest) Reset()                    { *m = GetImageLayerInfoRequest{} }
@@ -243,11 +244,12 @@ func (*GetImageLayerInfoRequest) ProtoMessage()               {}
 func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type LayerInfo struct {
-	KeyIds       []uint64 `protobuf:"varint,1,rep,packed,name=keyIds" json:"keyIds,omitempty"`
-	Digest       string   `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
-	Encryption   string   `protobuf:"bytes,3,opt,name=encryption,proto3" json:"encryption,omitempty"`
-	FileSize     int64    `protobuf:"varint,4,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
-	Architecture string   `protobuf:"bytes,5,opt,name=architecture,proto3" json:"architecture,omitempty"`
+	ID           uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
+	KeyIds       []uint64 `protobuf:"varint,2,rep,packed,name=keyIds" json:"keyIds,omitempty"`
+	Digest       string   `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
+	Encryption   string   `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
+	FileSize     int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
+	Architecture string   `protobuf:"bytes,6,opt,name=architecture,proto3" json:"architecture,omitempty"`
 }
 
 func (m *LayerInfo) Reset()                    { *m = LayerInfo{} }
@@ -1147,6 +1149,12 @@ func (m *GetImageLayerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Name)))
 		i += copy(dAtA[i:], m.Name)
 	}
+	if len(m.Platform) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Platform)))
+		i += copy(dAtA[i:], m.Platform)
+	}
 	return i, nil
 }
 
@@ -1165,6 +1173,11 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 	_ = i
 	var l int
 	_ = l
+	if m.ID != 0 {
+		dAtA[i] = 0x8
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(m.ID))
+	}
 	if len(m.KeyIds) > 0 {
 		dAtA15 := make([]byte, len(m.KeyIds)*10)
 		var j14 int
@@ -1177,30 +1190,30 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 			dAtA15[j14] = uint8(num)
 			j14++
 		}
-		dAtA[i] = 0xa
+		dAtA[i] = 0x12
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(j14))
 		i += copy(dAtA[i:], dAtA15[:j14])
 	}
 	if len(m.Digest) > 0 {
-		dAtA[i] = 0x12
+		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Digest)))
 		i += copy(dAtA[i:], m.Digest)
 	}
 	if len(m.Encryption) > 0 {
-		dAtA[i] = 0x1a
+		dAtA[i] = 0x22
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Encryption)))
 		i += copy(dAtA[i:], m.Encryption)
 	}
 	if m.FileSize != 0 {
-		dAtA[i] = 0x20
+		dAtA[i] = 0x28
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.FileSize))
 	}
 	if len(m.Architecture) > 0 {
-		dAtA[i] = 0x2a
+		dAtA[i] = 0x32
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Architecture)))
 		i += copy(dAtA[i:], m.Architecture)
@@ -1445,12 +1458,19 @@ func (m *GetImageLayerInfoRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
+	l = len(m.Platform)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
 	return n
 }
 
 func (m *LayerInfo) Size() (n int) {
 	var l int
 	_ = l
+	if m.ID != 0 {
+		n += 1 + sovImages(uint64(m.ID))
+	}
 	if len(m.KeyIds) > 0 {
 		l = 0
 		for _, e := range m.KeyIds {
@@ -1687,6 +1707,7 @@ func (this *GetImageLayerInfoRequest) String() string {
 	}
 	s := strings.Join([]string{`&GetImageLayerInfoRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
+		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1696,6 +1717,7 @@ func (this *LayerInfo) String() string {
 		return "nil"
 	}
 	s := strings.Join([]string{`&LayerInfo{`,
+		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
 		`KeyIds:` + fmt.Sprintf("%v", this.KeyIds) + `,`,
 		`Digest:` + fmt.Sprintf("%v", this.Digest) + `,`,
 		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
@@ -3444,6 +3466,35 @@ func (m *GetImageLayerInfoRequest) Unmarshal(dAtA []byte) error {
 			}
 			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Platform = string(dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3495,6 +3546,25 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 		}
 		switch fieldNum {
 		case 1:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
+			}
+			m.ID = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.ID |= (uint32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+		case 2:
 			if wireType == 0 {
 				var v uint64
 				for shift := uint(0); ; shift += 7 {
@@ -3556,7 +3626,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 			} else {
 				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
 			}
-		case 2:
+		case 3:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
 			}
@@ -3585,7 +3655,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 			}
 			m.Digest = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 3:
+		case 4:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Encryption", wireType)
 			}
@@ -3614,7 +3684,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 			}
 			m.Encryption = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
-		case 4:
+		case 5:
 			if wireType != 0 {
 				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
 			}
@@ -3633,7 +3703,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 					break
 				}
 			}
-		case 5:
+		case 6:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
 			}
@@ -3874,65 +3944,67 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 949 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcf, 0x73, 0xdb, 0x44,
-	0x14, 0x8e, 0x6c, 0xc7, 0x89, 0x9f, 0x93, 0x69, 0xbb, 0xcd, 0x74, 0x84, 0x00, 0xc7, 0xa3, 0x29,
-	0x33, 0x3e, 0x80, 0x44, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0x34, 0x3f, 0x5a, 0x32, 0x13, 0x7a, 0x50,
-	0x29, 0x64, 0xb8, 0x74, 0x64, 0xf9, 0x59, 0xdd, 0xb1, 0x2c, 0x09, 0x69, 0x9d, 0x8c, 0x38, 0xc1,
-	0x85, 0x2b, 0xcc, 0x70, 0xe4, 0x1f, 0xca, 0x91, 0x23, 0x27, 0xa0, 0x39, 0xf0, 0x77, 0x30, 0xda,
-	0x5d, 0xc5, 0x92, 0xed, 0xa9, 0xec, 0xe2, 0xe1, 0xf6, 0xf6, 0xe9, 0x7d, 0xef, 0xc7, 0xb7, 0xbb,
-	0xdf, 0xda, 0x70, 0xec, 0x52, 0xf6, 0x6a, 0xdc, 0x33, 0x9c, 0x60, 0x64, 0x3a, 0x81, 0xcf, 0x6c,
-	0xea, 0x63, 0xd4, 0xcf, 0x9b, 0x76, 0x48, 0xcd, 0x18, 0xa3, 0x0b, 0xea, 0x60, 0x6c, 0xd2, 0x91,
-	0xed, 0x62, 0x6c, 0x5e, 0xec, 0x49, 0xcb, 0x08, 0xa3, 0x80, 0x05, 0xe4, 0xfd, 0x49, 0xbc, 0x91,
-	0xc5, 0x1a, 0x32, 0xe2, 0x62, 0x4f, 0xdb, 0x71, 0x03, 0x37, 0xe0, 0x91, 0x66, 0x6a, 0x09, 0x90,
-	0xf6, 0xae, 0x1b, 0x04, 0xae, 0x87, 0x26, 0x5f, 0xf5, 0xc6, 0x03, 0x13, 0x47, 0x21, 0x4b, 0xe4,
-	0xc7, 0xf6, 0xf4, 0xc7, 0x01, 0x45, 0xaf, 0xff, 0x72, 0x64, 0xc7, 0x43, 0x19, 0xb1, 0x3b, 0x1d,
-	0xc1, 0xe8, 0x08, 0x63, 0x66, 0x8f, 0x42, 0x19, 0x70, 0xb0, 0xd0, 0x68, 0x2c, 0x09, 0x31, 0x36,
-	0xfb, 0x18, 0x3b, 0x11, 0x0d, 0x59, 0x10, 0x09, 0xb0, 0xfe, 0x4f, 0x05, 0xd6, 0x4f, 0xd3, 0x01,
-	0x08, 0x81, 0x9a, 0x6f, 0x8f, 0x50, 0x55, 0xda, 0x4a, 0xa7, 0x61, 0x71, 0x9b, 0x7c, 0x01, 0x75,
-	0xcf, 0xee, 0xa1, 0x17, 0xab, 0x95, 0x76, 0xb5, 0xd3, 0xec, 0x7e, 0x6c, 0xbc, 0x91, 0x00, 0x83,
-	0x67, 0x32, 0xce, 0x38, 0xe4, 0xc4, 0x67, 0x51, 0x62, 0x49, 0x3c, 0xd9, 0x87, 0x3a, 0xb3, 0x23,
-	0x17, 0x99, 0x5a, 0x6d, 0x2b, 0x9d, 0x66, 0xf7, 0xbd, 0x7c, 0x26, 0xde, 0x9b, 0x71, 0x7c, 0xd3,
-	0xdb, 0x61, 0xed, 0xea, 0xcf, 0xdd, 0x35, 0x4b, 0x22, 0xc8, 0x11, 0x80, 0x13, 0xa1, 0xcd, 0xb0,
-	0xff, 0xd2, 0x66, 0xea, 0x06, 0xc7, 0x6b, 0x86, 0xa0, 0xc5, 0xc8, 0x68, 0x31, 0xbe, 0xca, 0x68,
-	0x39, 0xdc, 0x4c, 0xd1, 0xbf, 0xfc, 0xb5, 0xab, 0x58, 0x0d, 0x89, 0x7b, 0xcc, 0x93, 0x8c, 0xc3,
-	0x7e, 0x96, 0x64, 0x73, 0x99, 0x24, 0x12, 0xf7, 0x98, 0x69, 0x9f, 0x42, 0x33, 0x37, 0x1c, 0xb9,
-	0x0d, 0xd5, 0x21, 0x26, 0x92, 0xb1, 0xd4, 0x24, 0x3b, 0xb0, 0x7e, 0x61, 0x7b, 0x63, 0x54, 0x2b,
-	0xdc, 0x27, 0x16, 0xfb, 0x95, 0x87, 0x8a, 0xfe, 0x01, 0xdc, 0x7a, 0x8a, 0x8c, 0x13, 0x64, 0xe1,
-	0x77, 0x63, 0x8c, 0xd9, 0x3c, 0xc6, 0xf5, 0x67, 0x70, 0x7b, 0x12, 0x16, 0x87, 0x81, 0x1f, 0x23,
-	0xd9, 0x87, 0x75, 0x4e, 0x31, 0x0f, 0x6c, 0x76, 0xef, 0x2f, 0xb2, 0x09, 0x96, 0x80, 0xe8, 0x5f,
-	0x03, 0x39, 0xe2, 0x1c, 0x14, 0x2a, 0x7f, 0xfe, 0x16, 0x19, 0xe5, 0xa6, 0xc8, 0xbc, 0xdf, 0xc0,
-	0xdd, 0x42, 0x5e, 0xd9, 0xea, 0x7f, 0x4f, 0xfc, 0xab, 0x02, 0xe4, 0x05, 0x27, 0x7c, 0xb5, 0x1d,
-	0x93, 0x03, 0x68, 0x8a, 0x8d, 0xe4, 0x97, 0x8b, 0x6f, 0xd0, 0xbc, 0x13, 0xf0, 0x24, 0xbd, 0x7f,
-	0x5f, 0xda, 0xf1, 0xd0, 0x92, 0xe7, 0x25, 0xb5, 0xd3, 0x71, 0x0b, 0x4d, 0xad, 0x6c, 0xdc, 0x8f,
-	0xe0, 0xce, 0x19, 0x8d, 0xc5, 0x86, 0xc7, 0xd9, 0xb0, 0x2a, 0x6c, 0x0c, 0xa8, 0xc7, 0x30, 0x8a,
-	0x55, 0xa5, 0x5d, 0xed, 0x34, 0xac, 0x6c, 0xa9, 0x9f, 0x03, 0xc9, 0x87, 0xcb, 0x36, 0x0e, 0xa1,
-	0x2e, 0x8a, 0xf0, 0xf0, 0xe5, 0xfa, 0x90, 0x48, 0xfd, 0x11, 0x90, 0x63, 0xf4, 0x70, 0x8a, 0xf6,
-	0x79, 0xa2, 0x40, 0xa0, 0x16, 0x27, 0xbe, 0xc3, 0x19, 0xdc, 0xb4, 0xb8, 0xad, 0xbf, 0x80, 0xed,
-	0x13, 0xdf, 0x89, 0x92, 0x90, 0x1d, 0x05, 0xfe, 0x80, 0xba, 0xa4, 0x05, 0x10, 0xa1, 0x43, 0x43,
-	0x8a, 0x3e, 0xcb, 0xa6, 0xc8, 0x79, 0xc8, 0x7d, 0xd8, 0x76, 0x43, 0x37, 0x1c, 0xf7, 0x86, 0x98,
-	0x44, 0xd4, 0x77, 0x79, 0xb6, 0x2d, 0xab, 0xe8, 0xd4, 0x6f, 0xc1, 0xf6, 0x31, 0xe6, 0xd2, 0xea,
-	0x3f, 0x2a, 0x70, 0x57, 0x16, 0x2a, 0xed, 0x53, 0x85, 0x0d, 0x1f, 0x2f, 0x9f, 0xa5, 0x6e, 0x71,
-	0x1b, 0xb3, 0x25, 0x79, 0x04, 0x15, 0xc7, 0x91, 0x42, 0xf4, 0x61, 0x09, 0x57, 0x85, 0xb1, 0xac,
-	0x8a, 0xe3, 0xe8, 0xe7, 0xb0, 0x53, 0x6c, 0x61, 0x65, 0x87, 0x21, 0x9d, 0x4e, 0xce, 0xfb, 0x3f,
-	0x4d, 0x57, 0x60, 0x37, 0x9b, 0xae, 0xd8, 0xc2, 0xca, 0xa6, 0x33, 0x40, 0xcd, 0xa4, 0xed, 0xcc,
-	0x4e, 0x30, 0x3a, 0xf5, 0x07, 0xc1, 0x9b, 0xa4, 0xf0, 0x37, 0x05, 0x1a, 0x37, 0x81, 0xe4, 0x1e,
-	0xd4, 0x87, 0x98, 0x9c, 0xf6, 0xc5, 0x61, 0xaa, 0x59, 0x72, 0x95, 0xfa, 0xfb, 0xd4, 0xc5, 0x98,
-	0x49, 0x1a, 0xe4, 0x2a, 0x3d, 0x80, 0x28, 0x76, 0x89, 0x06, 0x3e, 0x67, 0xa3, 0x61, 0xe5, 0x3c,
-	0x44, 0x83, 0xcd, 0x01, 0xf5, 0xf0, 0x39, 0xfd, 0x1e, 0xd5, 0x5a, 0x5b, 0xe9, 0x54, 0xad, 0x9b,
-	0x35, 0xd1, 0x61, 0xcb, 0x8e, 0x9c, 0x57, 0x94, 0xa1, 0xc3, 0xc6, 0x11, 0xaa, 0xeb, 0x1c, 0x5d,
-	0xf0, 0xe9, 0x0e, 0xbc, 0x33, 0x67, 0x1a, 0x49, 0xd6, 0x13, 0x68, 0x78, 0x99, 0x53, 0xde, 0xc9,
-	0x4e, 0x09, 0x61, 0x93, 0x24, 0x13, 0x68, 0xf7, 0xe7, 0x0d, 0xa8, 0x8b, 0xbb, 0x4e, 0x06, 0x50,
-	0x7d, 0x8a, 0x8c, 0x18, 0x25, 0x69, 0xa6, 0xde, 0x18, 0xcd, 0x5c, 0x38, 0x5e, 0xb6, 0x3e, 0x84,
-	0x5a, 0xaa, 0x30, 0xa4, 0xec, 0xa9, 0x9f, 0x51, 0x2d, 0x6d, 0x6f, 0x09, 0x84, 0x2c, 0x16, 0x40,
-	0x5d, 0xbc, 0x22, 0xa4, 0x0c, 0x3c, 0xfb, 0x88, 0x69, 0xdd, 0x65, 0x20, 0x93, 0x82, 0x42, 0xc7,
-	0x4b, 0x0b, 0xce, 0xbe, 0x41, 0xa5, 0x05, 0xe7, 0xbd, 0x10, 0xcf, 0xa1, 0x2e, 0x64, 0xb5, 0xb4,
-	0xe0, 0xac, 0xfa, 0x6a, 0xf7, 0x66, 0x5e, 0xa7, 0x93, 0xf4, 0xa7, 0x23, 0xb9, 0x84, 0xad, 0xbc,
-	0x02, 0x91, 0xee, 0x62, 0x1a, 0x56, 0xc8, 0xfd, 0x60, 0x29, 0x8c, 0x9c, 0xe6, 0x12, 0xb6, 0xf2,
-	0xe2, 0x50, 0x5a, 0x78, 0x8e, 0x98, 0x95, 0x16, 0x9e, 0xab, 0x3e, 0x3f, 0x29, 0x70, 0x67, 0xe6,
-	0xba, 0x91, 0x4f, 0x16, 0x3c, 0xdc, 0xd3, 0x72, 0xa3, 0x3d, 0x5c, 0x1e, 0x28, 0x1a, 0x39, 0x3c,
-	0xbf, 0x7a, 0xdd, 0x5a, 0xfb, 0xe3, 0x75, 0x6b, 0xed, 0x87, 0xeb, 0x96, 0x72, 0x75, 0xdd, 0x52,
-	0x7e, 0xbf, 0x6e, 0x29, 0x7f, 0x5f, 0xb7, 0x94, 0x6f, 0x3f, 0x7b, 0xcb, 0x7f, 0x18, 0x07, 0xc2,
-	0x3a, 0x5f, 0xeb, 0xd5, 0xf9, 0x36, 0x3f, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xdb, 0x6e,
-	0xab, 0xac, 0x0c, 0x00, 0x00,
+	// 982 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x41, 0x73, 0xdb, 0x44,
+	0x14, 0x8e, 0x6c, 0x47, 0x89, 0x5f, 0x92, 0x69, 0xbb, 0xcd, 0x64, 0x84, 0x00, 0xc7, 0xa3, 0x29,
+	0x33, 0x3e, 0x80, 0x4c, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0xd4, 0x71, 0x5a, 0xc2, 0x84, 0x1e, 0x54,
+	0x0a, 0x19, 0x2e, 0x1d, 0x59, 0x7e, 0x56, 0x77, 0x2c, 0x4b, 0x42, 0x5a, 0x27, 0x63, 0x4e, 0x70,
+	0xe1, 0x0a, 0x33, 0xfc, 0x14, 0xfe, 0x44, 0x8e, 0x1c, 0x39, 0x15, 0xea, 0x03, 0xbf, 0x83, 0xd1,
+	0xee, 0x2a, 0x96, 0x6c, 0x4f, 0x65, 0x97, 0x0c, 0xb7, 0xdd, 0xa7, 0xf7, 0xbd, 0xf7, 0xbe, 0x6f,
+	0x77, 0xdf, 0xb3, 0xa1, 0xe3, 0x52, 0xf6, 0x72, 0xd4, 0x35, 0x9d, 0x60, 0xd8, 0x74, 0x02, 0x9f,
+	0xd9, 0xd4, 0xc7, 0xa8, 0x97, 0x5d, 0xda, 0x21, 0x6d, 0xc6, 0x18, 0x5d, 0x50, 0x07, 0xe3, 0x26,
+	0x1d, 0xda, 0x2e, 0xc6, 0xcd, 0x8b, 0x03, 0xb9, 0x32, 0xc3, 0x28, 0x60, 0x01, 0x79, 0x7f, 0xea,
+	0x6f, 0xa6, 0xbe, 0xa6, 0xf4, 0xb8, 0x38, 0xd0, 0x77, 0xdd, 0xc0, 0x0d, 0xb8, 0x67, 0x33, 0x59,
+	0x09, 0x90, 0xfe, 0xae, 0x1b, 0x04, 0xae, 0x87, 0x4d, 0xbe, 0xeb, 0x8e, 0xfa, 0x4d, 0x1c, 0x86,
+	0x6c, 0x2c, 0x3f, 0xd6, 0x67, 0x3f, 0xf6, 0x29, 0x7a, 0xbd, 0x17, 0x43, 0x3b, 0x1e, 0x48, 0x8f,
+	0xfd, 0x59, 0x0f, 0x46, 0x87, 0x18, 0x33, 0x7b, 0x18, 0x4a, 0x87, 0xa3, 0xa5, 0xa8, 0xb1, 0x71,
+	0x88, 0x71, 0xb3, 0x87, 0xb1, 0x13, 0xd1, 0x90, 0x05, 0x91, 0x00, 0x1b, 0xff, 0x94, 0x60, 0xfd,
+	0x34, 0x21, 0x40, 0x08, 0x54, 0x7c, 0x7b, 0x88, 0x9a, 0x52, 0x57, 0x1a, 0x55, 0x8b, 0xaf, 0xc9,
+	0x17, 0xa0, 0x7a, 0x76, 0x17, 0xbd, 0x58, 0x2b, 0xd5, 0xcb, 0x8d, 0xad, 0xd6, 0xc7, 0xe6, 0x1b,
+	0x05, 0x30, 0x79, 0x24, 0xf3, 0x8c, 0x43, 0x4e, 0x7c, 0x16, 0x8d, 0x2d, 0x89, 0x27, 0x87, 0xa0,
+	0x32, 0x3b, 0x72, 0x91, 0x69, 0xe5, 0xba, 0xd2, 0xd8, 0x6a, 0xbd, 0x97, 0x8d, 0xc4, 0x6b, 0x33,
+	0x3b, 0xd7, 0xb5, 0xb5, 0x2b, 0x57, 0xaf, 0xf6, 0xd7, 0x2c, 0x89, 0x20, 0xc7, 0x00, 0x4e, 0x84,
+	0x36, 0xc3, 0xde, 0x0b, 0x9b, 0x69, 0x1b, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33, 0x95, 0xc5, 0xfc,
+	0x3a, 0x95, 0xa5, 0xbd, 0x99, 0xa0, 0x7f, 0xfd, 0x6b, 0x5f, 0xb1, 0xaa, 0x12, 0xf7, 0x88, 0x07,
+	0x19, 0x85, 0xbd, 0x34, 0xc8, 0xe6, 0x2a, 0x41, 0x24, 0xee, 0x11, 0xd3, 0x3f, 0x85, 0xad, 0x0c,
+	0x39, 0x72, 0x1b, 0xca, 0x03, 0x1c, 0x4b, 0xc5, 0x92, 0x25, 0xd9, 0x85, 0xf5, 0x0b, 0xdb, 0x1b,
+	0xa1, 0x56, 0xe2, 0x36, 0xb1, 0x39, 0x2c, 0x3d, 0x50, 0x8c, 0x0f, 0xe0, 0xd6, 0x13, 0x64, 0x5c,
+	0x20, 0x0b, 0xbf, 0x1f, 0x61, 0xcc, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0x53, 0xb7, 0x38, 0x0c,
+	0xfc, 0x18, 0xc9, 0x21, 0xac, 0x73, 0x89, 0xb9, 0xe3, 0x56, 0xeb, 0xde, 0x32, 0x87, 0x60, 0x09,
+	0x88, 0xf1, 0x0d, 0x90, 0x63, 0xae, 0x41, 0x2e, 0xf3, 0xe7, 0x6f, 0x11, 0x51, 0x1e, 0x8a, 0x8c,
+	0xfb, 0x2d, 0xdc, 0xcd, 0xc5, 0x95, 0xa5, 0xfe, 0xf7, 0xc0, 0xbf, 0x29, 0x40, 0x9e, 0x73, 0xc1,
+	0x6f, 0xb6, 0x62, 0x72, 0x04, 0x5b, 0xe2, 0x20, 0xf9, 0xe3, 0xe2, 0x07, 0xb4, 0xe8, 0x06, 0x3c,
+	0x4e, 0xde, 0xdf, 0x57, 0x76, 0x3c, 0xb0, 0xe4, 0x7d, 0x49, 0xd6, 0x09, 0xdd, 0x5c, 0x51, 0x37,
+	0x46, 0xf7, 0x23, 0xb8, 0x73, 0x46, 0x63, 0x71, 0xe0, 0x71, 0x4a, 0x56, 0x83, 0x8d, 0x3e, 0xf5,
+	0x18, 0x46, 0xb1, 0xa6, 0xd4, 0xcb, 0x8d, 0xaa, 0x95, 0x6e, 0x8d, 0x73, 0x20, 0x59, 0x77, 0x59,
+	0x46, 0x1b, 0x54, 0x91, 0x84, 0xbb, 0xaf, 0x56, 0x87, 0x44, 0x1a, 0x0f, 0x81, 0x74, 0xd0, 0xc3,
+	0x19, 0xd9, 0x17, 0x35, 0x05, 0x02, 0x95, 0x78, 0xec, 0x3b, 0x5c, 0xc1, 0x4d, 0x8b, 0xaf, 0x8d,
+	0xe7, 0xb0, 0x73, 0xe2, 0x3b, 0xd1, 0x38, 0x64, 0xc7, 0x81, 0xdf, 0xa7, 0x2e, 0xa9, 0x01, 0x44,
+	0xe8, 0xd0, 0x90, 0xa2, 0xcf, 0x52, 0x16, 0x19, 0x0b, 0xb9, 0x07, 0x3b, 0x6e, 0xe8, 0x86, 0xa3,
+	0xee, 0x00, 0xc7, 0x11, 0xf5, 0x5d, 0x1e, 0x6d, 0xdb, 0xca, 0x1b, 0x8d, 0x5b, 0xb0, 0xd3, 0xc1,
+	0x4c, 0x58, 0xe3, 0x27, 0x05, 0xee, 0xca, 0x44, 0x85, 0x75, 0x6a, 0xb0, 0xe1, 0xe3, 0xe5, 0xd3,
+	0xc4, 0x2c, 0x5e, 0x63, 0xba, 0x25, 0x0f, 0xa1, 0xe4, 0x38, 0xb2, 0x11, 0x7d, 0x58, 0xa0, 0x55,
+	0x8e, 0x96, 0x55, 0x72, 0x1c, 0xe3, 0x1c, 0x76, 0xf3, 0x25, 0xdc, 0xd8, 0x65, 0x48, 0xd8, 0x49,
+	0xbe, 0xff, 0x13, 0xbb, 0x9c, 0xba, 0x29, 0xbb, 0x7c, 0x09, 0x37, 0xc6, 0xee, 0x4b, 0xd0, 0xd2,
+	0xd6, 0x76, 0x66, 0x8f, 0x31, 0x3a, 0xf5, 0xfb, 0xc1, 0x9b, 0x18, 0xea, 0xb0, 0x19, 0x7a, 0x36,
+	0xeb, 0x07, 0xd1, 0x50, 0x52, 0xbc, 0xde, 0x1b, 0xbf, 0x2b, 0x50, 0xbd, 0x0e, 0x42, 0xf6, 0xa0,
+	0x44, 0x7b, 0x1c, 0xbb, 0xd3, 0x56, 0x27, 0xaf, 0xf6, 0x4b, 0xa7, 0x1d, 0xab, 0x44, 0x7b, 0x64,
+	0x0f, 0xd4, 0x01, 0x8e, 0x4f, 0x7b, 0x62, 0x7c, 0x55, 0x2c, 0xb9, 0x4b, 0xec, 0x3d, 0xea, 0x62,
+	0x2c, 0x86, 0x51, 0xd5, 0x92, 0xbb, 0xe4, 0xd2, 0xa2, 0x38, 0x59, 0x1a, 0xf8, 0x5a, 0x85, 0x7f,
+	0xcb, 0x58, 0x92, 0x8a, 0xfa, 0xd4, 0xc3, 0x67, 0xf4, 0x07, 0xd4, 0xd6, 0xeb, 0x4a, 0xa3, 0x6c,
+	0x5d, 0xef, 0x89, 0x01, 0xdb, 0x76, 0xe4, 0xbc, 0xa4, 0x0c, 0x1d, 0x36, 0x8a, 0x50, 0x53, 0x39,
+	0x3a, 0x67, 0x33, 0x1c, 0x78, 0x67, 0x81, 0x02, 0x52, 0xe0, 0xc7, 0x50, 0xf5, 0x52, 0xa3, 0x7c,
+	0xc7, 0x8d, 0x02, 0x91, 0xa7, 0x41, 0xa6, 0xd0, 0xd6, 0x2f, 0x1b, 0xa0, 0x8a, 0xfe, 0x40, 0xfa,
+	0x50, 0x7e, 0x82, 0x8c, 0x98, 0x05, 0x61, 0x66, 0xe6, 0x92, 0xde, 0x5c, 0xda, 0x5f, 0x96, 0x3e,
+	0x80, 0x4a, 0xd2, 0x95, 0x48, 0xd1, 0xcf, 0x83, 0xb9, 0x4e, 0xa7, 0x1f, 0xac, 0x80, 0x90, 0xc9,
+	0x02, 0x50, 0xc5, 0xe4, 0x21, 0x45, 0xe0, 0xf9, 0xc1, 0xa7, 0xb7, 0x56, 0x81, 0x4c, 0x13, 0x8a,
+	0xde, 0x5f, 0x98, 0x70, 0x7e, 0x6e, 0x15, 0x26, 0x5c, 0x34, 0x55, 0x9e, 0x81, 0x2a, 0x5a, 0x71,
+	0x61, 0xc2, 0xf9, 0x8e, 0xad, 0xef, 0xcd, 0x4d, 0xb4, 0x93, 0xe4, 0xe7, 0x26, 0xb9, 0x84, 0xed,
+	0x6c, 0xd7, 0x22, 0xad, 0xe5, 0xfa, 0x5e, 0x2e, 0xf6, 0xfd, 0x95, 0x30, 0x92, 0xcd, 0x25, 0x6c,
+	0x67, 0x1b, 0x4a, 0x61, 0xe2, 0x05, 0x0d, 0xb0, 0x30, 0xf1, 0xc2, 0x8e, 0xf5, 0xb3, 0x02, 0x77,
+	0xe6, 0x9e, 0x1b, 0xf9, 0x64, 0xc9, 0xcb, 0x3d, 0xdb, 0xa2, 0xf4, 0x07, 0xab, 0x03, 0x45, 0x21,
+	0xed, 0xf3, 0xab, 0xd7, 0xb5, 0xb5, 0x3f, 0x5f, 0xd7, 0xd6, 0x7e, 0x9c, 0xd4, 0x94, 0xab, 0x49,
+	0x4d, 0xf9, 0x63, 0x52, 0x53, 0xfe, 0x9e, 0xd4, 0x94, 0xef, 0x3e, 0x7b, 0xcb, 0x7f, 0x25, 0x47,
+	0x62, 0x75, 0xbe, 0xd6, 0x55, 0xf9, 0x31, 0xdf, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x34, 0x82,
+	0xc7, 0x25, 0xe0, 0x0c, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 72fc8b1..b3abd07 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -167,11 +167,12 @@ message GetImageLayerInfoRequest {
 }
 
 message LayerInfo {
-	repeated uint64 keyIds = 1;
-	string digest = 2;
-	string encryption = 3;
-	int64 fileSize = 4;
-	string architecture = 5;
+	uint32 id = 1;
+	repeated uint64 keyIds = 2;
+	string digest = 3;
+	string encryption = 4;
+	int64 fileSize = 5;
+	string architecture = 6;
 }
 
 message GetImageLayerInfoResponse {
diff --git a/image_store.go b/image_store.go
index 1777013..615ae5d 100644
--- a/image_store.go
+++ b/image_store.go
@@ -94,6 +94,7 @@ func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string) ([]im
 
 	li := make([]images.LayerInfo, len(resp.LayerInfo))
 	for i := 0; i < len(resp.LayerInfo); i++ {
+		li[i].Id = resp.LayerInfo[i].ID
 		li[i].KeyIds = resp.LayerInfo[i].KeyIds
 		li[i].Digest = resp.LayerInfo[i].Digest
 		li[i].Encryption = resp.LayerInfo[i].Encryption
diff --git a/images/image.go b/images/image.go
index 07407b0..4f01b6a 100644
--- a/images/image.go
+++ b/images/image.go
@@ -60,10 +60,17 @@ type Image struct {
 }
 
 type LayerInfo struct {
+	// The Id of the layer starting at 0
+	Id uint32
+	// An array of KeyIds to which the layer is encrypted
 	KeyIds []uint64
+	// The Digest of the layer
 	Digest string
+	// The Encryption algorithm used for encrypting the layer
 	Encryption string
+	// The size of the layer file
 	FileSize int64
+	// The architecture for which this layer is
 	Architecture string
 }
 
@@ -557,7 +564,10 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 				return []LayerInfo{}, err
 			}
 			for i := 0; i < len(tmp); i++ {
-				tmp[i].Architecture = Architecture
+				tmp[i].Id = uint32(i)
+				if Architecture != "" {
+					tmp[i].Architecture = Architecture
+				}
 			}
 			lis = append(lis, tmp...)
 		}
diff --git a/services/images/local.go b/services/images/local.go
index 69a1c92..356c3de 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -243,6 +243,7 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	resp.LayerInfo = make([]*imagesapi.LayerInfo, len(lis))
 	for i := 0; i < len(lis); i++ {
 		resp.LayerInfo[i] = &imagesapi.LayerInfo{
+			ID:           lis[i].Id,
 			KeyIds:       lis[i].KeyIds,
 			Digest:       lis[i].Digest,
 			Encryption:   lis[i].Encryption,
-- 
2.7.4


From d0e686153d032cc4ef9da50fe31b1ee62095a59e Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 23 Jul 2018 09:40:35 -0400
Subject: [PATCH 13/79] Add 'image layerinfo <name> command

---
 cmd/ctr/commands/images/images.go    |  1 +
 cmd/ctr/commands/images/layerinfo.go | 72 ++++++++++++++++++++++++++++++++++++
 2 files changed, 73 insertions(+)
 create mode 100644 cmd/ctr/commands/images/layerinfo.go

diff --git a/cmd/ctr/commands/images/images.go b/cmd/ctr/commands/images/images.go
index 739a26a..ab4ad57 100644
--- a/cmd/ctr/commands/images/images.go
+++ b/cmd/ctr/commands/images/images.go
@@ -49,6 +49,7 @@ var Command = cli.Command{
 		setLabelsCommand,
 		encryptCommand,
 		decryptCommand,
+		layerinfoCommand,
 	},
 }
 
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
new file mode 100644
index 0000000..0ac0b0a
--- /dev/null
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -0,0 +1,72 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package images
+
+import (
+	"fmt"
+	"os"
+	"strconv"
+	"text/tabwriter"
+
+	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/pkg/errors"
+	"github.com/urfave/cli"
+)
+
+var layerinfoCommand = cli.Command{
+	Name:      "layerinfo",
+	Usage:     "get infomration about an image's layers",
+	ArgsUsage: "[flags] <local>",
+	Description: `Get encryption information about the layers of an image.
+
+	XYZ
+`,
+	Flags: commands.RegistryFlags,
+	Action: func(context *cli.Context) error {
+		var (
+			local = context.Args().First()
+		)
+		if local == "" {
+			return errors.New("please provide the name of an image to decrypt")
+		}
+		client, ctx, cancel, err := commands.NewClient(context)
+		if err != nil {
+			return err
+		}
+		defer cancel()
+
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local)
+		if err != nil {
+			return err
+		}
+		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', tabwriter.AlignRight)
+		for _, layer := range LayerInfos {
+			keyids := ""
+			for _, keyid := range layer.KeyIds {
+				if keyids != "" {
+					keyids = keyids + ", "
+				}
+				keyids = keyids + "0x" + strconv.FormatUint(keyid, 16)
+			}
+			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Architecture, layer.FileSize, layer.Encryption, keyids)
+		}
+		w.Flush()
+		return nil
+	},
+}
+
+
-- 
2.7.4


From 9c7a436b1655b2de2715648b11c161b65f5fcfdb Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 23 Jul 2018 09:52:04 -0400
Subject: [PATCH 14/79] Add a header to the table of layerinfo output

---
 cmd/ctr/commands/images/layerinfo.go | 1 +
 1 file changed, 1 insertion(+)

diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 0ac0b0a..51f03aa 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -54,6 +54,7 @@ var layerinfoCommand = cli.Command{
 			return err
 		}
 		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', tabwriter.AlignRight)
+		fmt.Fprintf(w, "Num\tDigest\tArchitecture\tSize\tEncryption\tKey IDs\t\n")
 		for _, layer := range LayerInfos {
 			keyids := ""
 			for _, keyid := range layer.KeyIds {
-- 
2.7.4


From 5d880ad17216b0c7e778991eb5fea7bf4b06804c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 23 Jul 2018 12:01:08 -0400
Subject: [PATCH 15/79] Change from Architecture to Platform

---
 api/next.pb.txt                     |   4 +-
 api/services/images/v1/images.pb.go | 121 ++++++++++++++++++------------------
 api/services/images/v1/images.proto |   2 +-
 image_store.go                      |   2 +-
 images/image.go                     |  12 ++--
 services/images/local.go            |  12 ++--
 6 files changed, 76 insertions(+), 77 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index fbe16ea..5e065c1 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2371,11 +2371,11 @@ file {
       json_name: "fileSize"
     }
     field {
-      name: "architecture"
+      name: "platform"
       number: 6
       label: LABEL_OPTIONAL
       type: TYPE_STRING
-      json_name: "architecture"
+      json_name: "platform"
     }
   }
   message_type {
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 50febea..5141eac 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -244,12 +244,12 @@ func (*GetImageLayerInfoRequest) ProtoMessage()               {}
 func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type LayerInfo struct {
-	ID           uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
-	KeyIds       []uint64 `protobuf:"varint,2,rep,packed,name=keyIds" json:"keyIds,omitempty"`
-	Digest       string   `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
-	Encryption   string   `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
-	FileSize     int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
-	Architecture string   `protobuf:"bytes,6,opt,name=architecture,proto3" json:"architecture,omitempty"`
+	ID         uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
+	KeyIds     []uint64 `protobuf:"varint,2,rep,packed,name=keyIds" json:"keyIds,omitempty"`
+	Digest     string   `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
+	Encryption string   `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
+	FileSize   int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
+	Platform   string   `protobuf:"bytes,6,opt,name=platform,proto3" json:"platform,omitempty"`
 }
 
 func (m *LayerInfo) Reset()                    { *m = LayerInfo{} }
@@ -1212,11 +1212,11 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.FileSize))
 	}
-	if len(m.Architecture) > 0 {
+	if len(m.Platform) > 0 {
 		dAtA[i] = 0x32
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(len(m.Architecture)))
-		i += copy(dAtA[i:], m.Architecture)
+		i = encodeVarintImages(dAtA, i, uint64(len(m.Platform)))
+		i += copy(dAtA[i:], m.Platform)
 	}
 	return i, nil
 }
@@ -1489,7 +1489,7 @@ func (m *LayerInfo) Size() (n int) {
 	if m.FileSize != 0 {
 		n += 1 + sovImages(uint64(m.FileSize))
 	}
-	l = len(m.Architecture)
+	l = len(m.Platform)
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
@@ -1722,7 +1722,7 @@ func (this *LayerInfo) String() string {
 		`Digest:` + fmt.Sprintf("%v", this.Digest) + `,`,
 		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
 		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
-		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
+		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -3705,7 +3705,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 			}
 		case 6:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
 			}
 			var stringLen uint64
 			for shift := uint(0); ; shift += 7 {
@@ -3730,7 +3730,7 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.Architecture = string(dAtA[iNdEx:postIndex])
+			m.Platform = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -3944,67 +3944,66 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 982 bytes of a gzipped FileDescriptorProto
+	// 970 bytes of a gzipped FileDescriptorProto
 	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x41, 0x73, 0xdb, 0x44,
 	0x14, 0x8e, 0x6c, 0x47, 0x89, 0x5f, 0x92, 0x69, 0xbb, 0xcd, 0x64, 0x84, 0x00, 0xc7, 0xa3, 0x29,
 	0x33, 0x3e, 0x80, 0x4c, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0xd4, 0x71, 0x5a, 0xc2, 0x84, 0x1e, 0x54,
-	0x0a, 0x19, 0x2e, 0x1d, 0x59, 0x7e, 0x56, 0x77, 0x2c, 0x4b, 0x42, 0x5a, 0x27, 0x63, 0x4e, 0x70,
-	0xe1, 0x0a, 0x33, 0xfc, 0x14, 0xfe, 0x44, 0x8e, 0x1c, 0x39, 0x15, 0xea, 0x03, 0xbf, 0x83, 0xd1,
-	0xee, 0x2a, 0x96, 0x6c, 0x4f, 0x65, 0x97, 0x0c, 0xb7, 0xdd, 0xa7, 0xf7, 0xbd, 0xf7, 0xbe, 0x6f,
-	0x77, 0xdf, 0xb3, 0xa1, 0xe3, 0x52, 0xf6, 0x72, 0xd4, 0x35, 0x9d, 0x60, 0xd8, 0x74, 0x02, 0x9f,
-	0xd9, 0xd4, 0xc7, 0xa8, 0x97, 0x5d, 0xda, 0x21, 0x6d, 0xc6, 0x18, 0x5d, 0x50, 0x07, 0xe3, 0x26,
-	0x1d, 0xda, 0x2e, 0xc6, 0xcd, 0x8b, 0x03, 0xb9, 0x32, 0xc3, 0x28, 0x60, 0x01, 0x79, 0x7f, 0xea,
-	0x6f, 0xa6, 0xbe, 0xa6, 0xf4, 0xb8, 0x38, 0xd0, 0x77, 0xdd, 0xc0, 0x0d, 0xb8, 0x67, 0x33, 0x59,
-	0x09, 0x90, 0xfe, 0xae, 0x1b, 0x04, 0xae, 0x87, 0x4d, 0xbe, 0xeb, 0x8e, 0xfa, 0x4d, 0x1c, 0x86,
+	0x0a, 0x19, 0x2e, 0x1d, 0x59, 0x7e, 0x16, 0x3b, 0x96, 0x25, 0x21, 0xad, 0x93, 0x31, 0x27, 0xb8,
+	0x70, 0x85, 0x19, 0x7e, 0x06, 0x7f, 0x24, 0x47, 0x8e, 0x9c, 0x0a, 0xf5, 0x81, 0xdf, 0xc1, 0x68,
+	0x77, 0x15, 0x4b, 0xb6, 0xa7, 0xb2, 0x4b, 0xa6, 0xb7, 0x7d, 0xab, 0xf7, 0xbd, 0xf7, 0xbe, 0x6f,
+	0x77, 0xdf, 0xb3, 0xa1, 0xe3, 0x52, 0xf6, 0xfd, 0xa8, 0x6b, 0x3a, 0xc1, 0xb0, 0xe9, 0x04, 0x3e,
+	0xb3, 0xa9, 0x8f, 0x51, 0x2f, 0xbb, 0xb4, 0x43, 0xda, 0x8c, 0x31, 0xba, 0xa0, 0x0e, 0xc6, 0x4d,
+	0x3a, 0xb4, 0x5d, 0x8c, 0x9b, 0x17, 0x07, 0x72, 0x65, 0x86, 0x51, 0xc0, 0x02, 0xf2, 0xfe, 0xd4,
+	0xdf, 0x4c, 0x7d, 0x4d, 0xe9, 0x71, 0x71, 0xa0, 0xef, 0xba, 0x81, 0x1b, 0x70, 0xcf, 0x66, 0xb2,
+	0x12, 0x20, 0xfd, 0x5d, 0x37, 0x08, 0x5c, 0x0f, 0x9b, 0xdc, 0xea, 0x8e, 0xfa, 0x4d, 0x1c, 0x86,
 	0x6c, 0x2c, 0x3f, 0xd6, 0x67, 0x3f, 0xf6, 0x29, 0x7a, 0xbd, 0x17, 0x43, 0x3b, 0x1e, 0x48, 0x8f,
 	0xfd, 0x59, 0x0f, 0x46, 0x87, 0x18, 0x33, 0x7b, 0x18, 0x4a, 0x87, 0xa3, 0xa5, 0xa8, 0xb1, 0x71,
-	0x88, 0x71, 0xb3, 0x87, 0xb1, 0x13, 0xd1, 0x90, 0x05, 0x91, 0x00, 0x1b, 0xff, 0x94, 0x60, 0xfd,
+	0x88, 0x71, 0xb3, 0x87, 0xb1, 0x13, 0xd1, 0x90, 0x05, 0x91, 0x00, 0x1b, 0xff, 0x96, 0x60, 0xfd,
 	0x34, 0x21, 0x40, 0x08, 0x54, 0x7c, 0x7b, 0x88, 0x9a, 0x52, 0x57, 0x1a, 0x55, 0x8b, 0xaf, 0xc9,
-	0x17, 0xa0, 0x7a, 0x76, 0x17, 0xbd, 0x58, 0x2b, 0xd5, 0xcb, 0x8d, 0xad, 0xd6, 0xc7, 0xe6, 0x1b,
+	0x17, 0xa0, 0x7a, 0x76, 0x17, 0xbd, 0x58, 0x2b, 0xd5, 0xcb, 0x8d, 0xad, 0xd6, 0xc7, 0xe6, 0x6b,
 	0x05, 0x30, 0x79, 0x24, 0xf3, 0x8c, 0x43, 0x4e, 0x7c, 0x16, 0x8d, 0x2d, 0x89, 0x27, 0x87, 0xa0,
 	0x32, 0x3b, 0x72, 0x91, 0x69, 0xe5, 0xba, 0xd2, 0xd8, 0x6a, 0xbd, 0x97, 0x8d, 0xc4, 0x6b, 0x33,
-	0x3b, 0xd7, 0xb5, 0xb5, 0x2b, 0x57, 0xaf, 0xf6, 0xd7, 0x2c, 0x89, 0x20, 0xc7, 0x00, 0x4e, 0x84,
+	0x3b, 0xd7, 0xb5, 0xb5, 0x2b, 0x57, 0x2f, 0xf7, 0xd7, 0x2c, 0x89, 0x20, 0xc7, 0x00, 0x4e, 0x84,
 	0x36, 0xc3, 0xde, 0x0b, 0x9b, 0x69, 0x1b, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33, 0x95, 0xc5, 0xfc,
-	0x3a, 0x95, 0xa5, 0xbd, 0x99, 0xa0, 0x7f, 0xfd, 0x6b, 0x5f, 0xb1, 0xaa, 0x12, 0xf7, 0x88, 0x07,
+	0x3a, 0x95, 0xa5, 0xbd, 0x99, 0xa0, 0x7f, 0xfb, 0x7b, 0x5f, 0xb1, 0xaa, 0x12, 0xf7, 0x88, 0x07,
 	0x19, 0x85, 0xbd, 0x34, 0xc8, 0xe6, 0x2a, 0x41, 0x24, 0xee, 0x11, 0xd3, 0x3f, 0x85, 0xad, 0x0c,
 	0x39, 0x72, 0x1b, 0xca, 0x03, 0x1c, 0x4b, 0xc5, 0x92, 0x25, 0xd9, 0x85, 0xf5, 0x0b, 0xdb, 0x1b,
-	0xa1, 0x56, 0xe2, 0x36, 0xb1, 0x39, 0x2c, 0x3d, 0x50, 0x8c, 0x0f, 0xe0, 0xd6, 0x13, 0x64, 0x5c,
-	0x20, 0x0b, 0xbf, 0x1f, 0x61, 0xcc, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0x53, 0xb7, 0x38, 0x0c,
+	0xa1, 0x56, 0xe2, 0x7b, 0xc2, 0x38, 0x2c, 0x3d, 0x50, 0x8c, 0x0f, 0xe0, 0xd6, 0x13, 0x64, 0x5c,
+	0x20, 0x0b, 0x7f, 0x18, 0x61, 0xcc, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0x53, 0xb7, 0x38, 0x0c,
 	0xfc, 0x18, 0xc9, 0x21, 0xac, 0x73, 0x89, 0xb9, 0xe3, 0x56, 0xeb, 0xde, 0x32, 0x87, 0x60, 0x09,
-	0x88, 0xf1, 0x0d, 0x90, 0x63, 0xae, 0x41, 0x2e, 0xf3, 0xe7, 0x6f, 0x11, 0x51, 0x1e, 0x8a, 0x8c,
-	0xfb, 0x2d, 0xdc, 0xcd, 0xc5, 0x95, 0xa5, 0xfe, 0xf7, 0xc0, 0xbf, 0x29, 0x40, 0x9e, 0x73, 0xc1,
+	0x88, 0xf1, 0x0d, 0x90, 0x63, 0xae, 0x41, 0x2e, 0xf3, 0xe7, 0x6f, 0x10, 0x51, 0x1e, 0x8a, 0x8c,
+	0xfb, 0x2d, 0xdc, 0xcd, 0xc5, 0x95, 0xa5, 0xfe, 0xff, 0xc0, 0xbf, 0x2b, 0x40, 0x9e, 0x73, 0xc1,
 	0x6f, 0xb6, 0x62, 0x72, 0x04, 0x5b, 0xe2, 0x20, 0xf9, 0xe3, 0xe2, 0x07, 0xb4, 0xe8, 0x06, 0x3c,
 	0x4e, 0xde, 0xdf, 0x57, 0x76, 0x3c, 0xb0, 0xe4, 0x7d, 0x49, 0xd6, 0x09, 0xdd, 0x5c, 0x51, 0x37,
 	0x46, 0xf7, 0x23, 0xb8, 0x73, 0x46, 0x63, 0x71, 0xe0, 0x71, 0x4a, 0x56, 0x83, 0x8d, 0x3e, 0xf5,
-	0x18, 0x46, 0xb1, 0xa6, 0xd4, 0xcb, 0x8d, 0xaa, 0x95, 0x6e, 0x8d, 0x73, 0x20, 0x59, 0x77, 0x59,
-	0x46, 0x1b, 0x54, 0x91, 0x84, 0xbb, 0xaf, 0x56, 0x87, 0x44, 0x1a, 0x0f, 0x81, 0x74, 0xd0, 0xc3,
-	0x19, 0xd9, 0x17, 0x35, 0x05, 0x02, 0x95, 0x78, 0xec, 0x3b, 0x5c, 0xc1, 0x4d, 0x8b, 0xaf, 0x8d,
-	0xe7, 0xb0, 0x73, 0xe2, 0x3b, 0xd1, 0x38, 0x64, 0xc7, 0x81, 0xdf, 0xa7, 0x2e, 0xa9, 0x01, 0x44,
-	0xe8, 0xd0, 0x90, 0xa2, 0xcf, 0x52, 0x16, 0x19, 0x0b, 0xb9, 0x07, 0x3b, 0x6e, 0xe8, 0x86, 0xa3,
-	0xee, 0x00, 0xc7, 0x11, 0xf5, 0x5d, 0x1e, 0x6d, 0xdb, 0xca, 0x1b, 0x8d, 0x5b, 0xb0, 0xd3, 0xc1,
-	0x4c, 0x58, 0xe3, 0x27, 0x05, 0xee, 0xca, 0x44, 0x85, 0x75, 0x6a, 0xb0, 0xe1, 0xe3, 0xe5, 0xd3,
-	0xc4, 0x2c, 0x5e, 0x63, 0xba, 0x25, 0x0f, 0xa1, 0xe4, 0x38, 0xb2, 0x11, 0x7d, 0x58, 0xa0, 0x55,
-	0x8e, 0x96, 0x55, 0x72, 0x1c, 0xe3, 0x1c, 0x76, 0xf3, 0x25, 0xdc, 0xd8, 0x65, 0x48, 0xd8, 0x49,
-	0xbe, 0xff, 0x13, 0xbb, 0x9c, 0xba, 0x29, 0xbb, 0x7c, 0x09, 0x37, 0xc6, 0xee, 0x4b, 0xd0, 0xd2,
-	0xd6, 0x76, 0x66, 0x8f, 0x31, 0x3a, 0xf5, 0xfb, 0xc1, 0x9b, 0x18, 0xea, 0xb0, 0x19, 0x7a, 0x36,
-	0xeb, 0x07, 0xd1, 0x50, 0x52, 0xbc, 0xde, 0x1b, 0xbf, 0x2b, 0x50, 0xbd, 0x0e, 0x42, 0xf6, 0xa0,
-	0x44, 0x7b, 0x1c, 0xbb, 0xd3, 0x56, 0x27, 0xaf, 0xf6, 0x4b, 0xa7, 0x1d, 0xab, 0x44, 0x7b, 0x64,
-	0x0f, 0xd4, 0x01, 0x8e, 0x4f, 0x7b, 0x62, 0x7c, 0x55, 0x2c, 0xb9, 0x4b, 0xec, 0x3d, 0xea, 0x62,
-	0x2c, 0x86, 0x51, 0xd5, 0x92, 0xbb, 0xe4, 0xd2, 0xa2, 0x38, 0x59, 0x1a, 0xf8, 0x5a, 0x85, 0x7f,
-	0xcb, 0x58, 0x92, 0x8a, 0xfa, 0xd4, 0xc3, 0x67, 0xf4, 0x07, 0xd4, 0xd6, 0xeb, 0x4a, 0xa3, 0x6c,
-	0x5d, 0xef, 0x89, 0x01, 0xdb, 0x76, 0xe4, 0xbc, 0xa4, 0x0c, 0x1d, 0x36, 0x8a, 0x50, 0x53, 0x39,
-	0x3a, 0x67, 0x33, 0x1c, 0x78, 0x67, 0x81, 0x02, 0x52, 0xe0, 0xc7, 0x50, 0xf5, 0x52, 0xa3, 0x7c,
-	0xc7, 0x8d, 0x02, 0x91, 0xa7, 0x41, 0xa6, 0xd0, 0xd6, 0x2f, 0x1b, 0xa0, 0x8a, 0xfe, 0x40, 0xfa,
-	0x50, 0x7e, 0x82, 0x8c, 0x98, 0x05, 0x61, 0x66, 0xe6, 0x92, 0xde, 0x5c, 0xda, 0x5f, 0x96, 0x3e,
-	0x80, 0x4a, 0xd2, 0x95, 0x48, 0xd1, 0xcf, 0x83, 0xb9, 0x4e, 0xa7, 0x1f, 0xac, 0x80, 0x90, 0xc9,
-	0x02, 0x50, 0xc5, 0xe4, 0x21, 0x45, 0xe0, 0xf9, 0xc1, 0xa7, 0xb7, 0x56, 0x81, 0x4c, 0x13, 0x8a,
-	0xde, 0x5f, 0x98, 0x70, 0x7e, 0x6e, 0x15, 0x26, 0x5c, 0x34, 0x55, 0x9e, 0x81, 0x2a, 0x5a, 0x71,
-	0x61, 0xc2, 0xf9, 0x8e, 0xad, 0xef, 0xcd, 0x4d, 0xb4, 0x93, 0xe4, 0xe7, 0x26, 0xb9, 0x84, 0xed,
-	0x6c, 0xd7, 0x22, 0xad, 0xe5, 0xfa, 0x5e, 0x2e, 0xf6, 0xfd, 0x95, 0x30, 0x92, 0xcd, 0x25, 0x6c,
-	0x67, 0x1b, 0x4a, 0x61, 0xe2, 0x05, 0x0d, 0xb0, 0x30, 0xf1, 0xc2, 0x8e, 0xf5, 0xb3, 0x02, 0x77,
-	0xe6, 0x9e, 0x1b, 0xf9, 0x64, 0xc9, 0xcb, 0x3d, 0xdb, 0xa2, 0xf4, 0x07, 0xab, 0x03, 0x45, 0x21,
-	0xed, 0xf3, 0xab, 0xd7, 0xb5, 0xb5, 0x3f, 0x5f, 0xd7, 0xd6, 0x7e, 0x9c, 0xd4, 0x94, 0xab, 0x49,
-	0x4d, 0xf9, 0x63, 0x52, 0x53, 0xfe, 0x9e, 0xd4, 0x94, 0xef, 0x3e, 0x7b, 0xcb, 0x7f, 0x25, 0x47,
-	0x62, 0x75, 0xbe, 0xd6, 0x55, 0xf9, 0x31, 0xdf, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x34, 0x82,
-	0xc7, 0x25, 0xe0, 0x0c, 0x00, 0x00,
+	0x18, 0x46, 0xb1, 0xa6, 0xd4, 0xcb, 0x8d, 0xaa, 0x95, 0x9a, 0xc6, 0x39, 0x90, 0xac, 0xbb, 0x2c,
+	0xa3, 0x0d, 0xaa, 0x48, 0xc2, 0xdd, 0x57, 0xab, 0x43, 0x22, 0x8d, 0x87, 0x40, 0x3a, 0xe8, 0xe1,
+	0x8c, 0xec, 0x8b, 0x9a, 0x02, 0x81, 0x4a, 0x3c, 0xf6, 0x1d, 0xae, 0xe0, 0xa6, 0xc5, 0xd7, 0xc6,
+	0x73, 0xd8, 0x39, 0xf1, 0x9d, 0x68, 0x1c, 0xb2, 0xe3, 0xc0, 0xef, 0x53, 0x97, 0xd4, 0x00, 0x22,
+	0x74, 0x68, 0x48, 0xd1, 0x67, 0x29, 0x8b, 0xcc, 0x0e, 0xb9, 0x07, 0x3b, 0x6e, 0xe8, 0x86, 0xa3,
+	0xee, 0x00, 0xc7, 0x11, 0xf5, 0x5d, 0x1e, 0x6d, 0xdb, 0xca, 0x6f, 0x1a, 0xb7, 0x60, 0xa7, 0x83,
+	0x99, 0xb0, 0xc6, 0xcf, 0x0a, 0xdc, 0x95, 0x89, 0x0a, 0xeb, 0xd4, 0x60, 0xc3, 0xc7, 0xcb, 0xa7,
+	0xc9, 0xb6, 0x78, 0x8d, 0xa9, 0x49, 0x1e, 0x42, 0xc9, 0x71, 0x64, 0x23, 0xfa, 0xb0, 0x40, 0xab,
+	0x1c, 0x2d, 0xab, 0xe4, 0x38, 0xc6, 0x39, 0xec, 0xe6, 0x4b, 0xb8, 0xb1, 0xcb, 0x90, 0xb0, 0x93,
+	0x7c, 0xdf, 0x12, 0xbb, 0x9c, 0xba, 0x29, 0xbb, 0x7c, 0x09, 0x37, 0xc6, 0xee, 0x4b, 0xd0, 0xd2,
+	0xd6, 0x76, 0x66, 0x8f, 0x31, 0x3a, 0xf5, 0xfb, 0xc1, 0xeb, 0x18, 0xea, 0xb0, 0x19, 0x7a, 0x36,
+	0xeb, 0x07, 0xd1, 0x50, 0x52, 0xbc, 0xb6, 0x8d, 0x3f, 0x14, 0xa8, 0x5e, 0x07, 0x21, 0x7b, 0x50,
+	0xa2, 0x3d, 0x8e, 0xdd, 0x69, 0xab, 0x93, 0x97, 0xfb, 0xa5, 0xd3, 0x8e, 0x55, 0xa2, 0x3d, 0xb2,
+	0x07, 0xea, 0x00, 0xc7, 0xa7, 0x3d, 0x31, 0xbe, 0x2a, 0x96, 0xb4, 0x92, 0xfd, 0x1e, 0x75, 0x31,
+	0x16, 0xc3, 0xa8, 0x6a, 0x49, 0x2b, 0xb9, 0xb4, 0x28, 0x4e, 0x96, 0x06, 0xbe, 0x56, 0xe1, 0xdf,
+	0x32, 0x3b, 0x49, 0x45, 0x7d, 0xea, 0xe1, 0x33, 0xfa, 0x23, 0x6a, 0xeb, 0x75, 0xa5, 0x51, 0xb6,
+	0xae, 0xed, 0x5c, 0xb5, 0xea, 0x4c, 0xb5, 0x0e, 0xbc, 0xb3, 0x80, 0xb9, 0x14, 0xf6, 0x31, 0x54,
+	0xbd, 0x74, 0x53, 0xbe, 0xdf, 0x46, 0x81, 0xb8, 0xd3, 0x20, 0x53, 0x68, 0xeb, 0xd7, 0x0d, 0x50,
+	0x45, 0x5f, 0x20, 0x7d, 0x28, 0x3f, 0x41, 0x46, 0xcc, 0x82, 0x30, 0x33, 0xf3, 0x48, 0x6f, 0x2e,
+	0xed, 0x2f, 0x4b, 0x1f, 0x40, 0x25, 0xe9, 0x46, 0xa4, 0xe8, 0x67, 0xc1, 0x5c, 0x87, 0xd3, 0x0f,
+	0x56, 0x40, 0xc8, 0x64, 0x01, 0xa8, 0x62, 0xe2, 0x90, 0x22, 0xf0, 0xfc, 0xc0, 0xd3, 0x5b, 0xab,
+	0x40, 0xa6, 0x09, 0x45, 0xcf, 0x2f, 0x4c, 0x38, 0x3f, 0xaf, 0x0a, 0x13, 0x2e, 0x9a, 0x26, 0xcf,
+	0x40, 0x15, 0x2d, 0xb8, 0x30, 0xe1, 0x7c, 0xa7, 0xd6, 0xf7, 0xe6, 0x26, 0xd9, 0x49, 0xf2, 0x33,
+	0x93, 0x5c, 0xc2, 0x76, 0xb6, 0x5b, 0x91, 0xd6, 0x72, 0xfd, 0x2e, 0x17, 0xfb, 0xfe, 0x4a, 0x18,
+	0xc9, 0xe6, 0x12, 0xb6, 0xb3, 0x8d, 0xa4, 0x30, 0xf1, 0x82, 0xc6, 0x57, 0x98, 0x78, 0x61, 0xa7,
+	0xfa, 0x45, 0x81, 0x3b, 0x73, 0xcf, 0x8d, 0x7c, 0xb2, 0xe4, 0xe5, 0x9e, 0x6d, 0x4d, 0xfa, 0x83,
+	0xd5, 0x81, 0xa2, 0x90, 0xf6, 0xf9, 0xd5, 0xab, 0xda, 0xda, 0x5f, 0xaf, 0x6a, 0x6b, 0x3f, 0x4d,
+	0x6a, 0xca, 0xd5, 0xa4, 0xa6, 0xfc, 0x39, 0xa9, 0x29, 0xff, 0x4c, 0x6a, 0xca, 0x77, 0x9f, 0xbd,
+	0xe1, 0xbf, 0x91, 0x23, 0xb1, 0x3a, 0x5f, 0xeb, 0xaa, 0xfc, 0x98, 0xef, 0xff, 0x17, 0x00, 0x00,
+	0xff, 0xff, 0xaf, 0x9b, 0x72, 0xdc, 0xd8, 0x0c, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index b3abd07..d559f8d 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -172,7 +172,7 @@ message LayerInfo {
 	string digest = 3;
 	string encryption = 4;
 	int64 fileSize = 5;
-	string architecture = 6;
+	string platform = 6;
 }
 
 message GetImageLayerInfoResponse {
diff --git a/image_store.go b/image_store.go
index 615ae5d..0b42a6b 100644
--- a/image_store.go
+++ b/image_store.go
@@ -99,7 +99,7 @@ func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string) ([]im
 		li[i].Digest = resp.LayerInfo[i].Digest
 		li[i].Encryption = resp.LayerInfo[i].Encryption
 		li[i].FileSize = resp.LayerInfo[i].FileSize
-		li[i].Architecture = resp.LayerInfo[i].Architecture
+		li[i].Platform = resp.LayerInfo[i].Platform
 	}
 
 	return li, nil
diff --git a/images/image.go b/images/image.go
index 4f01b6a..ddf13f6 100644
--- a/images/image.go
+++ b/images/image.go
@@ -70,8 +70,8 @@ type LayerInfo struct {
 	Encryption string
 	// The size of the layer file
 	FileSize int64
-	// The architecture for which this layer is
-	Architecture string
+	// The platform for which this layer is
+	Platform string
 }
 
 // DeleteOptions provide options on image delete
@@ -545,7 +545,7 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor) ([]LayerInfo, error) {
 	var (
 		lis []LayerInfo
-		Architecture string
+		Platform string
 	)
 
 	switch (desc.MediaType) {
@@ -553,7 +553,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
 		if desc.Platform != nil {
-			Architecture = desc.Platform.Architecture
+			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture
 		}
 		if err != nil {
 			return []LayerInfo{}, err
@@ -565,8 +565,8 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			}
 			for i := 0; i < len(tmp); i++ {
 				tmp[i].Id = uint32(i)
-				if Architecture != "" {
-					tmp[i].Architecture = Architecture
+				if Platform != "" {
+					tmp[i].Platform = Platform
 				}
 			}
 			lis = append(lis, tmp...)
diff --git a/services/images/local.go b/services/images/local.go
index 356c3de..0998710 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -243,12 +243,12 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	resp.LayerInfo = make([]*imagesapi.LayerInfo, len(lis))
 	for i := 0; i < len(lis); i++ {
 		resp.LayerInfo[i] = &imagesapi.LayerInfo{
-			ID:           lis[i].Id,
-			KeyIds:       lis[i].KeyIds,
-			Digest:       lis[i].Digest,
-			Encryption:   lis[i].Encryption,
-			FileSize:     lis[i].FileSize,
-			Architecture: lis[i].Architecture,
+			ID:         lis[i].Id,
+			KeyIds:     lis[i].KeyIds,
+			Digest:     lis[i].Digest,
+			Encryption: lis[i].Encryption,
+			FileSize:   lis[i].FileSize,
+			Platform:   lis[i].Platform,
 		}
 	}
 
-- 
2.7.4


From 205196ed3a2579e0122ce3205af930bb6f1ae03b Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 23 Jul 2018 12:01:28 -0400
Subject: [PATCH 16/79] Update client output to show Platform

---
 cmd/ctr/commands/images/layerinfo.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 51f03aa..7e5206c 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -54,7 +54,7 @@ var layerinfoCommand = cli.Command{
 			return err
 		}
 		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', tabwriter.AlignRight)
-		fmt.Fprintf(w, "Num\tDigest\tArchitecture\tSize\tEncryption\tKey IDs\t\n")
+		fmt.Fprintf(w, "#\tDIGEST\tPLATFORM\tSIZE\tENCRYPTION\tKEY IDS\t\n")
 		for _, layer := range LayerInfos {
 			keyids := ""
 			for _, keyid := range layer.KeyIds {
@@ -63,7 +63,7 @@ var layerinfoCommand = cli.Command{
 				}
 				keyids = keyids + "0x" + strconv.FormatUint(keyid, 16)
 			}
-			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Architecture, layer.FileSize, layer.Encryption, keyids)
+			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Platform, layer.FileSize, layer.Encryption, keyids)
 		}
 		w.Flush()
 		return nil
-- 
2.7.4


From 9cee1dcf46657dd9e5b063bdd5d08804abfd8aca Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 06:54:59 -0400
Subject: [PATCH 17/79] Pass the private key and password data through to the
 decryption function

---
 api/next.pb.txt                     |  50 +++-
 api/services/images/v1/images.pb.go | 540 +++++++++++++++++++++++++++++-------
 api/services/images/v1/images.proto |   8 +-
 image_store.go                      |  15 +-
 images/encryption.go                |  54 +++-
 images/image.go                     |  11 +-
 services/images/local.go            |  13 +-
 7 files changed, 573 insertions(+), 118 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 5e065c1..27be0b7 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2236,7 +2236,53 @@ file {
     }
   }
   message_type {
+    name: "DecryptKeyData"
+    field {
+      name: "keyData"
+      number: 1
+      label: LABEL_OPTIONAL
+      type: TYPE_BYTES
+      json_name: "keyData"
+    }
+    field {
+      name: "keyDataPassword"
+      number: 2
+      label: LABEL_OPTIONAL
+      type: TYPE_BYTES
+      json_name: "keyDataPassword"
+    }
+  }
+  message_type {
     name: "DecryptConfig"
+    field {
+      name: "keyIdMap"
+      number: 1
+      label: LABEL_REPEATED
+      type: TYPE_MESSAGE
+      type_name: ".containerd.services.images.v1.DecryptConfig.KeyIdMapEntry"
+      json_name: "keyIdMap"
+    }
+    nested_type {
+      name: "KeyIdMapEntry"
+      field {
+        name: "key"
+        number: 1
+        label: LABEL_OPTIONAL
+        type: TYPE_UINT64
+        json_name: "key"
+      }
+      field {
+        name: "value"
+        number: 2
+        label: LABEL_OPTIONAL
+        type: TYPE_MESSAGE
+        type_name: ".containerd.services.images.v1.DecryptKeyData"
+        json_name: "value"
+      }
+      options {
+        map_entry: true
+      }
+    }
   }
   message_type {
     name: "EncryptImageRequest"
@@ -2294,12 +2340,12 @@ file {
       json_name: "newName"
     }
     field {
-      name: "cc"
+      name: "dc"
       number: 3
       label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
       type_name: ".containerd.services.images.v1.DecryptConfig"
-      json_name: "cc"
+      json_name: "dc"
     }
   }
   message_type {
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 5141eac..1a7670e 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -19,6 +19,7 @@
 		ListImagesResponse
 		DeleteImageRequest
 		EncryptConfig
+		DecryptKeyData
 		DecryptConfig
 		EncryptImageRequest
 		EncryptImageResponse
@@ -191,12 +192,22 @@ func (m *EncryptConfig) Reset()                    { *m = EncryptConfig{} }
 func (*EncryptConfig) ProtoMessage()               {}
 func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
 
+type DecryptKeyData struct {
+	KeyData         []byte `protobuf:"bytes,1,opt,name=keyData,proto3" json:"keyData,omitempty"`
+	KeyDataPassword []byte `protobuf:"bytes,2,opt,name=keyDataPassword,proto3" json:"keyDataPassword,omitempty"`
+}
+
+func (m *DecryptKeyData) Reset()                    { *m = DecryptKeyData{} }
+func (*DecryptKeyData) ProtoMessage()               {}
+func (*DecryptKeyData) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{11} }
+
 type DecryptConfig struct {
+	KeyIdMap map[uint64]*DecryptKeyData `protobuf:"bytes,1,rep,name=keyIdMap" json:"keyIdMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
 }
 
 func (m *DecryptConfig) Reset()                    { *m = DecryptConfig{} }
 func (*DecryptConfig) ProtoMessage()               {}
-func (*DecryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{11} }
+func (*DecryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
 
 type EncryptImageRequest struct {
 	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
@@ -206,7 +217,7 @@ type EncryptImageRequest struct {
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
 func (*EncryptImageRequest) ProtoMessage()               {}
-func (*EncryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
+func (*EncryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{13} }
 
 type EncryptImageResponse struct {
 	Image Image `protobuf:"bytes,1,opt,name=image" json:"image"`
@@ -214,17 +225,17 @@ type EncryptImageResponse struct {
 
 func (m *EncryptImageResponse) Reset()                    { *m = EncryptImageResponse{} }
 func (*EncryptImageResponse) ProtoMessage()               {}
-func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{13} }
+func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
 
 type DecryptImageRequest struct {
 	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
 	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Cc      *DecryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Dc      *DecryptConfig `protobuf:"bytes,3,opt,name=dc" json:"dc,omitempty"`
 }
 
 func (m *DecryptImageRequest) Reset()                    { *m = DecryptImageRequest{} }
 func (*DecryptImageRequest) ProtoMessage()               {}
-func (*DecryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
+func (*DecryptImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
 
 type DecryptImageResponse struct {
 	Image Image `protobuf:"bytes,1,opt,name=image" json:"image"`
@@ -232,7 +243,7 @@ type DecryptImageResponse struct {
 
 func (m *DecryptImageResponse) Reset()                    { *m = DecryptImageResponse{} }
 func (*DecryptImageResponse) ProtoMessage()               {}
-func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{15} }
+func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type GetImageLayerInfoRequest struct {
 	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
@@ -241,7 +252,7 @@ type GetImageLayerInfoRequest struct {
 
 func (m *GetImageLayerInfoRequest) Reset()                    { *m = GetImageLayerInfoRequest{} }
 func (*GetImageLayerInfoRequest) ProtoMessage()               {}
-func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
+func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
 
 type LayerInfo struct {
 	ID         uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
@@ -254,7 +265,7 @@ type LayerInfo struct {
 
 func (m *LayerInfo) Reset()                    { *m = LayerInfo{} }
 func (*LayerInfo) ProtoMessage()               {}
-func (*LayerInfo) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
+func (*LayerInfo) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{18} }
 
 type GetImageLayerInfoResponse struct {
 	LayerInfo []*LayerInfo `protobuf:"bytes,1,rep,name=layerInfo" json:"layerInfo,omitempty"`
@@ -262,7 +273,7 @@ type GetImageLayerInfoResponse struct {
 
 func (m *GetImageLayerInfoResponse) Reset()                    { *m = GetImageLayerInfoResponse{} }
 func (*GetImageLayerInfoResponse) ProtoMessage()               {}
-func (*GetImageLayerInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{18} }
+func (*GetImageLayerInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{19} }
 
 func init() {
 	proto.RegisterType((*Image)(nil), "containerd.services.images.v1.Image")
@@ -276,6 +287,7 @@ func init() {
 	proto.RegisterType((*ListImagesResponse)(nil), "containerd.services.images.v1.ListImagesResponse")
 	proto.RegisterType((*DeleteImageRequest)(nil), "containerd.services.images.v1.DeleteImageRequest")
 	proto.RegisterType((*EncryptConfig)(nil), "containerd.services.images.v1.EncryptConfig")
+	proto.RegisterType((*DecryptKeyData)(nil), "containerd.services.images.v1.DecryptKeyData")
 	proto.RegisterType((*DecryptConfig)(nil), "containerd.services.images.v1.DecryptConfig")
 	proto.RegisterType((*EncryptImageRequest)(nil), "containerd.services.images.v1.EncryptImageRequest")
 	proto.RegisterType((*EncryptImageResponse)(nil), "containerd.services.images.v1.EncryptImageResponse")
@@ -978,6 +990,36 @@ func (m *EncryptConfig) MarshalTo(dAtA []byte) (int, error) {
 	return i, nil
 }
 
+func (m *DecryptKeyData) Marshal() (dAtA []byte, err error) {
+	size := m.Size()
+	dAtA = make([]byte, size)
+	n, err := m.MarshalTo(dAtA)
+	if err != nil {
+		return nil, err
+	}
+	return dAtA[:n], nil
+}
+
+func (m *DecryptKeyData) MarshalTo(dAtA []byte) (int, error) {
+	var i int
+	_ = i
+	var l int
+	_ = l
+	if len(m.KeyData) > 0 {
+		dAtA[i] = 0xa
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.KeyData)))
+		i += copy(dAtA[i:], m.KeyData)
+	}
+	if len(m.KeyDataPassword) > 0 {
+		dAtA[i] = 0x12
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(len(m.KeyDataPassword)))
+		i += copy(dAtA[i:], m.KeyDataPassword)
+	}
+	return i, nil
+}
+
 func (m *DecryptConfig) Marshal() (dAtA []byte, err error) {
 	size := m.Size()
 	dAtA = make([]byte, size)
@@ -993,6 +1035,33 @@ func (m *DecryptConfig) MarshalTo(dAtA []byte) (int, error) {
 	_ = i
 	var l int
 	_ = l
+	if len(m.KeyIdMap) > 0 {
+		for k, _ := range m.KeyIdMap {
+			dAtA[i] = 0xa
+			i++
+			v := m.KeyIdMap[k]
+			msgSize := 0
+			if v != nil {
+				msgSize = v.Size()
+				msgSize += 1 + sovImages(uint64(msgSize))
+			}
+			mapSize := 1 + sovImages(uint64(k)) + msgSize
+			i = encodeVarintImages(dAtA, i, uint64(mapSize))
+			dAtA[i] = 0x8
+			i++
+			i = encodeVarintImages(dAtA, i, uint64(k))
+			if v != nil {
+				dAtA[i] = 0x12
+				i++
+				i = encodeVarintImages(dAtA, i, uint64(v.Size()))
+				n10, err := v.MarshalTo(dAtA[i:])
+				if err != nil {
+					return 0, err
+				}
+				i += n10
+			}
+		}
+	}
 	return i, nil
 }
 
@@ -1027,11 +1096,11 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.Cc.Size()))
-		n10, err := m.Cc.MarshalTo(dAtA[i:])
+		n11, err := m.Cc.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n10
+		i += n11
 	}
 	return i, nil
 }
@@ -1054,11 +1123,11 @@ func (m *EncryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n11, err := m.Image.MarshalTo(dAtA[i:])
+	n12, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n11
+	i += n12
 	return i, nil
 }
 
@@ -1089,15 +1158,15 @@ func (m *DecryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.NewName)))
 		i += copy(dAtA[i:], m.NewName)
 	}
-	if m.Cc != nil {
+	if m.Dc != nil {
 		dAtA[i] = 0x1a
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(m.Cc.Size()))
-		n12, err := m.Cc.MarshalTo(dAtA[i:])
+		i = encodeVarintImages(dAtA, i, uint64(m.Dc.Size()))
+		n13, err := m.Dc.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n12
+		i += n13
 	}
 	return i, nil
 }
@@ -1120,11 +1189,11 @@ func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n13, err := m.Image.MarshalTo(dAtA[i:])
+	n14, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n13
+	i += n14
 	return i, nil
 }
 
@@ -1179,21 +1248,21 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(m.ID))
 	}
 	if len(m.KeyIds) > 0 {
-		dAtA15 := make([]byte, len(m.KeyIds)*10)
-		var j14 int
+		dAtA16 := make([]byte, len(m.KeyIds)*10)
+		var j15 int
 		for _, num := range m.KeyIds {
 			for num >= 1<<7 {
-				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j14++
+				j15++
 			}
-			dAtA15[j14] = uint8(num)
-			j14++
+			dAtA16[j15] = uint8(num)
+			j15++
 		}
 		dAtA[i] = 0x12
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j14))
-		i += copy(dAtA[i:], dAtA15[:j14])
+		i = encodeVarintImages(dAtA, i, uint64(j15))
+		i += copy(dAtA[i:], dAtA16[:j15])
 	}
 	if len(m.Digest) > 0 {
 		dAtA[i] = 0x1a
@@ -1393,9 +1462,36 @@ func (m *EncryptConfig) Size() (n int) {
 	return n
 }
 
+func (m *DecryptKeyData) Size() (n int) {
+	var l int
+	_ = l
+	l = len(m.KeyData)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	l = len(m.KeyDataPassword)
+	if l > 0 {
+		n += 1 + l + sovImages(uint64(l))
+	}
+	return n
+}
+
 func (m *DecryptConfig) Size() (n int) {
 	var l int
 	_ = l
+	if len(m.KeyIdMap) > 0 {
+		for k, v := range m.KeyIdMap {
+			_ = k
+			_ = v
+			l = 0
+			if v != nil {
+				l = v.Size()
+				l += 1 + sovImages(uint64(l))
+			}
+			mapEntrySize := 1 + sovImages(uint64(k)) + l
+			n += mapEntrySize + 1 + sovImages(uint64(mapEntrySize))
+		}
+	}
 	return n
 }
 
@@ -1436,8 +1532,8 @@ func (m *DecryptImageRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
-	if m.Cc != nil {
-		l = m.Cc.Size()
+	if m.Dc != nil {
+		l = m.Dc.Size()
 		n += 1 + l + sovImages(uint64(l))
 	}
 	return n
@@ -1648,11 +1744,33 @@ func (this *EncryptConfig) String() string {
 	}, "")
 	return s
 }
+func (this *DecryptKeyData) String() string {
+	if this == nil {
+		return "nil"
+	}
+	s := strings.Join([]string{`&DecryptKeyData{`,
+		`KeyData:` + fmt.Sprintf("%v", this.KeyData) + `,`,
+		`KeyDataPassword:` + fmt.Sprintf("%v", this.KeyDataPassword) + `,`,
+		`}`,
+	}, "")
+	return s
+}
 func (this *DecryptConfig) String() string {
 	if this == nil {
 		return "nil"
 	}
+	keysForKeyIdMap := make([]uint64, 0, len(this.KeyIdMap))
+	for k, _ := range this.KeyIdMap {
+		keysForKeyIdMap = append(keysForKeyIdMap, k)
+	}
+	sortkeys.Uint64s(keysForKeyIdMap)
+	mapStringForKeyIdMap := "map[uint64]*DecryptKeyData{"
+	for _, k := range keysForKeyIdMap {
+		mapStringForKeyIdMap += fmt.Sprintf("%v: %v,", k, this.KeyIdMap[k])
+	}
+	mapStringForKeyIdMap += "}"
 	s := strings.Join([]string{`&DecryptConfig{`,
+		`KeyIdMap:` + mapStringForKeyIdMap + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1686,7 +1804,7 @@ func (this *DecryptImageRequest) String() string {
 	s := strings.Join([]string{`&DecryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
-		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "DecryptConfig", "DecryptConfig", 1) + `,`,
+		`Dc:` + strings.Replace(fmt.Sprintf("%v", this.Dc), "DecryptConfig", "DecryptConfig", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -2916,6 +3034,118 @@ func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
 	}
 	return nil
 }
+func (m *DecryptKeyData) Unmarshal(dAtA []byte) error {
+	l := len(dAtA)
+	iNdEx := 0
+	for iNdEx < l {
+		preIndex := iNdEx
+		var wire uint64
+		for shift := uint(0); ; shift += 7 {
+			if shift >= 64 {
+				return ErrIntOverflowImages
+			}
+			if iNdEx >= l {
+				return io.ErrUnexpectedEOF
+			}
+			b := dAtA[iNdEx]
+			iNdEx++
+			wire |= (uint64(b) & 0x7F) << shift
+			if b < 0x80 {
+				break
+			}
+		}
+		fieldNum := int32(wire >> 3)
+		wireType := int(wire & 0x7)
+		if wireType == 4 {
+			return fmt.Errorf("proto: DecryptKeyData: wiretype end group for non-group")
+		}
+		if fieldNum <= 0 {
+			return fmt.Errorf("proto: DecryptKeyData: illegal tag %d (wire type %d)", fieldNum, wire)
+		}
+		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.KeyData = append(m.KeyData[:0], dAtA[iNdEx:postIndex]...)
+			if m.KeyData == nil {
+				m.KeyData = []byte{}
+			}
+			iNdEx = postIndex
+		case 2:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field KeyDataPassword", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if byteLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.KeyDataPassword = append(m.KeyDataPassword[:0], dAtA[iNdEx:postIndex]...)
+			if m.KeyDataPassword == nil {
+				m.KeyDataPassword = []byte{}
+			}
+			iNdEx = postIndex
+		default:
+			iNdEx = preIndex
+			skippy, err := skipImages(dAtA[iNdEx:])
+			if err != nil {
+				return err
+			}
+			if skippy < 0 {
+				return ErrInvalidLengthImages
+			}
+			if (iNdEx + skippy) > l {
+				return io.ErrUnexpectedEOF
+			}
+			iNdEx += skippy
+		}
+	}
+
+	if iNdEx > l {
+		return io.ErrUnexpectedEOF
+	}
+	return nil
+}
 func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 	l := len(dAtA)
 	iNdEx := 0
@@ -2945,6 +3175,118 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 			return fmt.Errorf("proto: DecryptConfig: illegal tag %d (wire type %d)", fieldNum, wire)
 		}
 		switch fieldNum {
+		case 1:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field KeyIdMap", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.KeyIdMap == nil {
+				m.KeyIdMap = make(map[uint64]*DecryptKeyData)
+			}
+			var mapkey uint64
+			var mapvalue *DecryptKeyData
+			for iNdEx < postIndex {
+				entryPreIndex := iNdEx
+				var wire uint64
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					wire |= (uint64(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				fieldNum := int32(wire >> 3)
+				if fieldNum == 1 {
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapkey |= (uint64(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+				} else if fieldNum == 2 {
+					var mapmsglen int
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						mapmsglen |= (int(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					if mapmsglen < 0 {
+						return ErrInvalidLengthImages
+					}
+					postmsgIndex := iNdEx + mapmsglen
+					if mapmsglen < 0 {
+						return ErrInvalidLengthImages
+					}
+					if postmsgIndex > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapvalue = &DecryptKeyData{}
+					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
+						return err
+					}
+					iNdEx = postmsgIndex
+				} else {
+					iNdEx = entryPreIndex
+					skippy, err := skipImages(dAtA[iNdEx:])
+					if err != nil {
+						return err
+					}
+					if skippy < 0 {
+						return ErrInvalidLengthImages
+					}
+					if (iNdEx + skippy) > postIndex {
+						return io.ErrUnexpectedEOF
+					}
+					iNdEx += skippy
+				}
+			}
+			m.KeyIdMap[mapkey] = mapvalue
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3276,7 +3618,7 @@ func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Cc", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Dc", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -3300,10 +3642,10 @@ func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Cc == nil {
-				m.Cc = &DecryptConfig{}
+			if m.Dc == nil {
+				m.Dc = &DecryptConfig{}
 			}
-			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Dc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -3944,66 +4286,72 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 970 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x41, 0x73, 0xdb, 0x44,
-	0x14, 0x8e, 0x6c, 0x47, 0x89, 0x5f, 0x92, 0x69, 0xbb, 0xcd, 0x64, 0x84, 0x00, 0xc7, 0xa3, 0x29,
-	0x33, 0x3e, 0x80, 0x4c, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0xd4, 0x71, 0x5a, 0xc2, 0x84, 0x1e, 0x54,
-	0x0a, 0x19, 0x2e, 0x1d, 0x59, 0x7e, 0x16, 0x3b, 0x96, 0x25, 0x21, 0xad, 0x93, 0x31, 0x27, 0xb8,
-	0x70, 0x85, 0x19, 0x7e, 0x06, 0x7f, 0x24, 0x47, 0x8e, 0x9c, 0x0a, 0xf5, 0x81, 0xdf, 0xc1, 0x68,
-	0x77, 0x15, 0x4b, 0xb6, 0xa7, 0xb2, 0x4b, 0xa6, 0xb7, 0x7d, 0xab, 0xf7, 0xbd, 0xf7, 0xbe, 0x6f,
-	0x77, 0xdf, 0xb3, 0xa1, 0xe3, 0x52, 0xf6, 0xfd, 0xa8, 0x6b, 0x3a, 0xc1, 0xb0, 0xe9, 0x04, 0x3e,
-	0xb3, 0xa9, 0x8f, 0x51, 0x2f, 0xbb, 0xb4, 0x43, 0xda, 0x8c, 0x31, 0xba, 0xa0, 0x0e, 0xc6, 0x4d,
-	0x3a, 0xb4, 0x5d, 0x8c, 0x9b, 0x17, 0x07, 0x72, 0x65, 0x86, 0x51, 0xc0, 0x02, 0xf2, 0xfe, 0xd4,
-	0xdf, 0x4c, 0x7d, 0x4d, 0xe9, 0x71, 0x71, 0xa0, 0xef, 0xba, 0x81, 0x1b, 0x70, 0xcf, 0x66, 0xb2,
-	0x12, 0x20, 0xfd, 0x5d, 0x37, 0x08, 0x5c, 0x0f, 0x9b, 0xdc, 0xea, 0x8e, 0xfa, 0x4d, 0x1c, 0x86,
-	0x6c, 0x2c, 0x3f, 0xd6, 0x67, 0x3f, 0xf6, 0x29, 0x7a, 0xbd, 0x17, 0x43, 0x3b, 0x1e, 0x48, 0x8f,
-	0xfd, 0x59, 0x0f, 0x46, 0x87, 0x18, 0x33, 0x7b, 0x18, 0x4a, 0x87, 0xa3, 0xa5, 0xa8, 0xb1, 0x71,
-	0x88, 0x71, 0xb3, 0x87, 0xb1, 0x13, 0xd1, 0x90, 0x05, 0x91, 0x00, 0x1b, 0xff, 0x96, 0x60, 0xfd,
-	0x34, 0x21, 0x40, 0x08, 0x54, 0x7c, 0x7b, 0x88, 0x9a, 0x52, 0x57, 0x1a, 0x55, 0x8b, 0xaf, 0xc9,
-	0x17, 0xa0, 0x7a, 0x76, 0x17, 0xbd, 0x58, 0x2b, 0xd5, 0xcb, 0x8d, 0xad, 0xd6, 0xc7, 0xe6, 0x6b,
-	0x05, 0x30, 0x79, 0x24, 0xf3, 0x8c, 0x43, 0x4e, 0x7c, 0x16, 0x8d, 0x2d, 0x89, 0x27, 0x87, 0xa0,
-	0x32, 0x3b, 0x72, 0x91, 0x69, 0xe5, 0xba, 0xd2, 0xd8, 0x6a, 0xbd, 0x97, 0x8d, 0xc4, 0x6b, 0x33,
-	0x3b, 0xd7, 0xb5, 0xb5, 0x2b, 0x57, 0x2f, 0xf7, 0xd7, 0x2c, 0x89, 0x20, 0xc7, 0x00, 0x4e, 0x84,
-	0x36, 0xc3, 0xde, 0x0b, 0x9b, 0x69, 0x1b, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33, 0x95, 0xc5, 0xfc,
-	0x3a, 0x95, 0xa5, 0xbd, 0x99, 0xa0, 0x7f, 0xfb, 0x7b, 0x5f, 0xb1, 0xaa, 0x12, 0xf7, 0x88, 0x07,
-	0x19, 0x85, 0xbd, 0x34, 0xc8, 0xe6, 0x2a, 0x41, 0x24, 0xee, 0x11, 0xd3, 0x3f, 0x85, 0xad, 0x0c,
-	0x39, 0x72, 0x1b, 0xca, 0x03, 0x1c, 0x4b, 0xc5, 0x92, 0x25, 0xd9, 0x85, 0xf5, 0x0b, 0xdb, 0x1b,
-	0xa1, 0x56, 0xe2, 0x7b, 0xc2, 0x38, 0x2c, 0x3d, 0x50, 0x8c, 0x0f, 0xe0, 0xd6, 0x13, 0x64, 0x5c,
-	0x20, 0x0b, 0x7f, 0x18, 0x61, 0xcc, 0x16, 0x29, 0x6e, 0x3c, 0x85, 0xdb, 0x53, 0xb7, 0x38, 0x0c,
-	0xfc, 0x18, 0xc9, 0x21, 0xac, 0x73, 0x89, 0xb9, 0xe3, 0x56, 0xeb, 0xde, 0x32, 0x87, 0x60, 0x09,
-	0x88, 0xf1, 0x0d, 0x90, 0x63, 0xae, 0x41, 0x2e, 0xf3, 0xe7, 0x6f, 0x10, 0x51, 0x1e, 0x8a, 0x8c,
-	0xfb, 0x2d, 0xdc, 0xcd, 0xc5, 0x95, 0xa5, 0xfe, 0xff, 0xc0, 0xbf, 0x2b, 0x40, 0x9e, 0x73, 0xc1,
-	0x6f, 0xb6, 0x62, 0x72, 0x04, 0x5b, 0xe2, 0x20, 0xf9, 0xe3, 0xe2, 0x07, 0xb4, 0xe8, 0x06, 0x3c,
-	0x4e, 0xde, 0xdf, 0x57, 0x76, 0x3c, 0xb0, 0xe4, 0x7d, 0x49, 0xd6, 0x09, 0xdd, 0x5c, 0x51, 0x37,
-	0x46, 0xf7, 0x23, 0xb8, 0x73, 0x46, 0x63, 0x71, 0xe0, 0x71, 0x4a, 0x56, 0x83, 0x8d, 0x3e, 0xf5,
-	0x18, 0x46, 0xb1, 0xa6, 0xd4, 0xcb, 0x8d, 0xaa, 0x95, 0x9a, 0xc6, 0x39, 0x90, 0xac, 0xbb, 0x2c,
-	0xa3, 0x0d, 0xaa, 0x48, 0xc2, 0xdd, 0x57, 0xab, 0x43, 0x22, 0x8d, 0x87, 0x40, 0x3a, 0xe8, 0xe1,
-	0x8c, 0xec, 0x8b, 0x9a, 0x02, 0x81, 0x4a, 0x3c, 0xf6, 0x1d, 0xae, 0xe0, 0xa6, 0xc5, 0xd7, 0xc6,
-	0x73, 0xd8, 0x39, 0xf1, 0x9d, 0x68, 0x1c, 0xb2, 0xe3, 0xc0, 0xef, 0x53, 0x97, 0xd4, 0x00, 0x22,
-	0x74, 0x68, 0x48, 0xd1, 0x67, 0x29, 0x8b, 0xcc, 0x0e, 0xb9, 0x07, 0x3b, 0x6e, 0xe8, 0x86, 0xa3,
-	0xee, 0x00, 0xc7, 0x11, 0xf5, 0x5d, 0x1e, 0x6d, 0xdb, 0xca, 0x6f, 0x1a, 0xb7, 0x60, 0xa7, 0x83,
-	0x99, 0xb0, 0xc6, 0xcf, 0x0a, 0xdc, 0x95, 0x89, 0x0a, 0xeb, 0xd4, 0x60, 0xc3, 0xc7, 0xcb, 0xa7,
-	0xc9, 0xb6, 0x78, 0x8d, 0xa9, 0x49, 0x1e, 0x42, 0xc9, 0x71, 0x64, 0x23, 0xfa, 0xb0, 0x40, 0xab,
-	0x1c, 0x2d, 0xab, 0xe4, 0x38, 0xc6, 0x39, 0xec, 0xe6, 0x4b, 0xb8, 0xb1, 0xcb, 0x90, 0xb0, 0x93,
-	0x7c, 0xdf, 0x12, 0xbb, 0x9c, 0xba, 0x29, 0xbb, 0x7c, 0x09, 0x37, 0xc6, 0xee, 0x4b, 0xd0, 0xd2,
-	0xd6, 0x76, 0x66, 0x8f, 0x31, 0x3a, 0xf5, 0xfb, 0xc1, 0xeb, 0x18, 0xea, 0xb0, 0x19, 0x7a, 0x36,
-	0xeb, 0x07, 0xd1, 0x50, 0x52, 0xbc, 0xb6, 0x8d, 0x3f, 0x14, 0xa8, 0x5e, 0x07, 0x21, 0x7b, 0x50,
-	0xa2, 0x3d, 0x8e, 0xdd, 0x69, 0xab, 0x93, 0x97, 0xfb, 0xa5, 0xd3, 0x8e, 0x55, 0xa2, 0x3d, 0xb2,
-	0x07, 0xea, 0x00, 0xc7, 0xa7, 0x3d, 0x31, 0xbe, 0x2a, 0x96, 0xb4, 0x92, 0xfd, 0x1e, 0x75, 0x31,
-	0x16, 0xc3, 0xa8, 0x6a, 0x49, 0x2b, 0xb9, 0xb4, 0x28, 0x4e, 0x96, 0x06, 0xbe, 0x56, 0xe1, 0xdf,
-	0x32, 0x3b, 0x49, 0x45, 0x7d, 0xea, 0xe1, 0x33, 0xfa, 0x23, 0x6a, 0xeb, 0x75, 0xa5, 0x51, 0xb6,
-	0xae, 0xed, 0x5c, 0xb5, 0xea, 0x4c, 0xb5, 0x0e, 0xbc, 0xb3, 0x80, 0xb9, 0x14, 0xf6, 0x31, 0x54,
-	0xbd, 0x74, 0x53, 0xbe, 0xdf, 0x46, 0x81, 0xb8, 0xd3, 0x20, 0x53, 0x68, 0xeb, 0xd7, 0x0d, 0x50,
-	0x45, 0x5f, 0x20, 0x7d, 0x28, 0x3f, 0x41, 0x46, 0xcc, 0x82, 0x30, 0x33, 0xf3, 0x48, 0x6f, 0x2e,
-	0xed, 0x2f, 0x4b, 0x1f, 0x40, 0x25, 0xe9, 0x46, 0xa4, 0xe8, 0x67, 0xc1, 0x5c, 0x87, 0xd3, 0x0f,
-	0x56, 0x40, 0xc8, 0x64, 0x01, 0xa8, 0x62, 0xe2, 0x90, 0x22, 0xf0, 0xfc, 0xc0, 0xd3, 0x5b, 0xab,
-	0x40, 0xa6, 0x09, 0x45, 0xcf, 0x2f, 0x4c, 0x38, 0x3f, 0xaf, 0x0a, 0x13, 0x2e, 0x9a, 0x26, 0xcf,
-	0x40, 0x15, 0x2d, 0xb8, 0x30, 0xe1, 0x7c, 0xa7, 0xd6, 0xf7, 0xe6, 0x26, 0xd9, 0x49, 0xf2, 0x33,
-	0x93, 0x5c, 0xc2, 0x76, 0xb6, 0x5b, 0x91, 0xd6, 0x72, 0xfd, 0x2e, 0x17, 0xfb, 0xfe, 0x4a, 0x18,
-	0xc9, 0xe6, 0x12, 0xb6, 0xb3, 0x8d, 0xa4, 0x30, 0xf1, 0x82, 0xc6, 0x57, 0x98, 0x78, 0x61, 0xa7,
-	0xfa, 0x45, 0x81, 0x3b, 0x73, 0xcf, 0x8d, 0x7c, 0xb2, 0xe4, 0xe5, 0x9e, 0x6d, 0x4d, 0xfa, 0x83,
-	0xd5, 0x81, 0xa2, 0x90, 0xf6, 0xf9, 0xd5, 0xab, 0xda, 0xda, 0x5f, 0xaf, 0x6a, 0x6b, 0x3f, 0x4d,
-	0x6a, 0xca, 0xd5, 0xa4, 0xa6, 0xfc, 0x39, 0xa9, 0x29, 0xff, 0x4c, 0x6a, 0xca, 0x77, 0x9f, 0xbd,
-	0xe1, 0xbf, 0x91, 0x23, 0xb1, 0x3a, 0x5f, 0xeb, 0xaa, 0xfc, 0x98, 0xef, 0xff, 0x17, 0x00, 0x00,
-	0xff, 0xff, 0xaf, 0x9b, 0x72, 0xdc, 0xd8, 0x0c, 0x00, 0x00,
+	// 1062 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
+	0x13, 0x36, 0x29, 0x99, 0xb6, 0x46, 0xf6, 0x9b, 0x64, 0x63, 0x18, 0x7c, 0xd9, 0x56, 0x16, 0x88,
+	0x14, 0xd0, 0xa1, 0xa1, 0x6a, 0xe5, 0xd0, 0xd4, 0x0e, 0x8a, 0xc6, 0x96, 0x93, 0xba, 0x71, 0x82,
+	0x82, 0xf9, 0xa8, 0xd1, 0x4b, 0x40, 0x93, 0x2b, 0x76, 0x2b, 0x8a, 0x64, 0xc9, 0x95, 0x0d, 0xf6,
+	0xd4, 0x5e, 0x7a, 0x6d, 0x81, 0xfe, 0x8c, 0xfe, 0x11, 0x1f, 0x0b, 0xf4, 0xd2, 0x53, 0xda, 0xe8,
+	0xd0, 0xdf, 0x51, 0x70, 0x77, 0x29, 0x91, 0x92, 0x10, 0x4a, 0x89, 0x6f, 0x33, 0xcb, 0x79, 0xe6,
+	0x73, 0xf7, 0x19, 0x09, 0xba, 0x2e, 0xa1, 0xdf, 0x0e, 0xcf, 0x0c, 0x3b, 0x18, 0xb4, 0xed, 0xc0,
+	0xa7, 0x16, 0xf1, 0x71, 0xe4, 0xe4, 0x45, 0x2b, 0x24, 0xed, 0x18, 0x47, 0xe7, 0xc4, 0xc6, 0x71,
+	0x9b, 0x0c, 0x2c, 0x17, 0xc7, 0xed, 0xf3, 0x5d, 0x21, 0x19, 0x61, 0x14, 0xd0, 0x00, 0x7d, 0x30,
+	0xb1, 0x37, 0x32, 0x5b, 0x43, 0x58, 0x9c, 0xef, 0x6a, 0x5b, 0x6e, 0xe0, 0x06, 0xcc, 0xb2, 0x9d,
+	0x4a, 0x1c, 0xa4, 0xbd, 0xe7, 0x06, 0x81, 0xeb, 0xe1, 0x36, 0xd3, 0xce, 0x86, 0xbd, 0x36, 0x1e,
+	0x84, 0x34, 0x11, 0x1f, 0x9b, 0xd3, 0x1f, 0x7b, 0x04, 0x7b, 0xce, 0xcb, 0x81, 0x15, 0xf7, 0x85,
+	0xc5, 0xce, 0xb4, 0x05, 0x25, 0x03, 0x1c, 0x53, 0x6b, 0x10, 0x0a, 0x83, 0xfd, 0x85, 0x4a, 0xa3,
+	0x49, 0x88, 0xe3, 0xb6, 0x83, 0x63, 0x3b, 0x22, 0x21, 0x0d, 0x22, 0x0e, 0xd6, 0xff, 0x95, 0x61,
+	0xf5, 0x38, 0x2d, 0x00, 0x21, 0xa8, 0xfa, 0xd6, 0x00, 0xab, 0x52, 0x53, 0x6a, 0xd5, 0x4c, 0x26,
+	0xa3, 0x2f, 0x40, 0xf1, 0xac, 0x33, 0xec, 0xc5, 0xaa, 0xdc, 0xac, 0xb4, 0xea, 0x9d, 0x8f, 0x8d,
+	0x37, 0x36, 0xc0, 0x60, 0x9e, 0x8c, 0x13, 0x06, 0x39, 0xf2, 0x69, 0x94, 0x98, 0x02, 0x8f, 0xf6,
+	0x40, 0xa1, 0x56, 0xe4, 0x62, 0xaa, 0x56, 0x9a, 0x52, 0xab, 0xde, 0x79, 0x3f, 0xef, 0x89, 0xe5,
+	0x66, 0x74, 0xc7, 0xb9, 0x1d, 0x54, 0x2f, 0x5f, 0xed, 0xac, 0x98, 0x02, 0x81, 0x0e, 0x01, 0xec,
+	0x08, 0x5b, 0x14, 0x3b, 0x2f, 0x2d, 0xaa, 0xae, 0x31, 0xbc, 0x66, 0xf0, 0xb6, 0x18, 0x59, 0x5b,
+	0x8c, 0x67, 0x59, 0x5b, 0x0e, 0xd6, 0x53, 0xf4, 0xaf, 0x7f, 0xef, 0x48, 0x66, 0x4d, 0xe0, 0xee,
+	0x33, 0x27, 0xc3, 0xd0, 0xc9, 0x9c, 0xac, 0x2f, 0xe3, 0x44, 0xe0, 0xee, 0x53, 0xed, 0x53, 0xa8,
+	0xe7, 0x8a, 0x43, 0xd7, 0xa1, 0xd2, 0xc7, 0x89, 0xe8, 0x58, 0x2a, 0xa2, 0x2d, 0x58, 0x3d, 0xb7,
+	0xbc, 0x21, 0x56, 0x65, 0x76, 0xc6, 0x95, 0x3d, 0xf9, 0xae, 0xa4, 0x7f, 0x08, 0xd7, 0x1e, 0x62,
+	0xca, 0x1a, 0x64, 0xe2, 0xef, 0x87, 0x38, 0xa6, 0xf3, 0x3a, 0xae, 0x3f, 0x81, 0xeb, 0x13, 0xb3,
+	0x38, 0x0c, 0xfc, 0x18, 0xa3, 0x3d, 0x58, 0x65, 0x2d, 0x66, 0x86, 0xf5, 0xce, 0xad, 0x45, 0x86,
+	0x60, 0x72, 0x88, 0xfe, 0x02, 0xd0, 0x21, 0xeb, 0x41, 0x21, 0xf2, 0xe7, 0x6f, 0xe1, 0x51, 0x0c,
+	0x45, 0xf8, 0xfd, 0x1a, 0x6e, 0x16, 0xfc, 0x8a, 0x54, 0xdf, 0xdd, 0xf1, 0x6f, 0x12, 0xa0, 0xe7,
+	0xac, 0xe1, 0x57, 0x9b, 0x31, 0xda, 0x87, 0x3a, 0x1f, 0x24, 0x7b, 0x5c, 0x6c, 0x40, 0xf3, 0x6e,
+	0xc0, 0x83, 0xf4, 0xfd, 0x3d, 0xb6, 0xe2, 0xbe, 0x29, 0xee, 0x4b, 0x2a, 0xa7, 0xe5, 0x16, 0x92,
+	0xba, 0xb2, 0x72, 0x6f, 0xc3, 0x8d, 0x13, 0x12, 0xf3, 0x81, 0xc7, 0x59, 0xb1, 0x2a, 0xac, 0xf5,
+	0x88, 0x47, 0x71, 0x14, 0xab, 0x52, 0xb3, 0xd2, 0xaa, 0x99, 0x99, 0xaa, 0x9f, 0x02, 0xca, 0x9b,
+	0x8b, 0x34, 0x0e, 0x40, 0xe1, 0x41, 0x98, 0xf9, 0x72, 0x79, 0x08, 0xa4, 0x7e, 0x0f, 0x50, 0x17,
+	0x7b, 0x78, 0xaa, 0xed, 0xf3, 0x48, 0x01, 0x41, 0x35, 0x4e, 0x7c, 0x9b, 0x75, 0x70, 0xdd, 0x64,
+	0xb2, 0xfe, 0x1c, 0x36, 0x8f, 0x7c, 0x3b, 0x4a, 0x42, 0x7a, 0x18, 0xf8, 0x3d, 0xe2, 0xa2, 0x06,
+	0x40, 0x84, 0x6d, 0x12, 0x12, 0xec, 0xd3, 0xac, 0x8a, 0xdc, 0x09, 0xba, 0x05, 0x9b, 0x6e, 0xe8,
+	0x86, 0xc3, 0xb3, 0x3e, 0x4e, 0x22, 0xe2, 0xbb, 0xcc, 0xdb, 0x86, 0x59, 0x3c, 0xd4, 0x9f, 0xc1,
+	0xff, 0xba, 0x98, 0xb9, 0x7d, 0x84, 0x93, 0xae, 0x45, 0xad, 0xb4, 0x35, 0x7d, 0x2e, 0xb2, 0x9c,
+	0x36, 0xcc, 0x4c, 0x45, 0x2d, 0xb8, 0x26, 0xc4, 0xaf, 0xac, 0x38, 0xbe, 0x08, 0x22, 0x47, 0xf8,
+	0x9c, 0x3e, 0xd6, 0xff, 0x94, 0x60, 0x53, 0xb8, 0x15, 0xd9, 0xbe, 0x80, 0xf5, 0x3e, 0x4e, 0x8e,
+	0x9d, 0xc7, 0x56, 0x28, 0x5a, 0xb8, 0x57, 0xd2, 0xc2, 0x02, 0xde, 0x78, 0x24, 0xc0, 0x9c, 0xf3,
+	0xc6, 0xbe, 0xb4, 0xef, 0x60, 0xb3, 0xf0, 0x29, 0xcf, 0x18, 0x55, 0xce, 0x18, 0x87, 0x79, 0xc6,
+	0xa8, 0x77, 0x6e, 0x2f, 0x16, 0x57, 0xb4, 0x23, 0x4f, 0x30, 0x3f, 0x49, 0x70, 0x53, 0xcc, 0xa0,
+	0x74, 0x84, 0x2a, 0xac, 0xf9, 0xf8, 0xe2, 0x49, 0x7a, 0xcc, 0x89, 0x2a, 0x53, 0xd1, 0x3d, 0x90,
+	0x6d, 0x5b, 0x70, 0xf4, 0x47, 0x25, 0xb9, 0x14, 0x26, 0x6e, 0xca, 0xb6, 0xad, 0x9f, 0xc2, 0x56,
+	0x31, 0x85, 0x2b, 0x7b, 0x27, 0x69, 0x75, 0xa2, 0xf6, 0x77, 0xab, 0xce, 0x59, 0xb4, 0xba, 0xc2,
+	0x84, 0x4d, 0xd9, 0x61, 0xd5, 0x15, 0x53, 0xb8, 0xb2, 0xea, 0xbe, 0x04, 0x35, 0x63, 0xfd, 0x13,
+	0x2b, 0xc1, 0xd1, 0xb1, 0xdf, 0x0b, 0xde, 0x54, 0xa1, 0x06, 0xeb, 0xa1, 0x67, 0xd1, 0x5e, 0x10,
+	0x0d, 0x44, 0x89, 0x63, 0x5d, 0xff, 0x5d, 0x82, 0xda, 0xd8, 0x09, 0xda, 0x06, 0x99, 0x38, 0x0c,
+	0xbb, 0x79, 0xa0, 0x8c, 0x5e, 0xed, 0xc8, 0xc7, 0x5d, 0x53, 0x26, 0x0e, 0xda, 0x06, 0x85, 0xdd,
+	0x52, 0xbe, 0xd9, 0xab, 0xa6, 0xd0, 0xd2, 0x73, 0x87, 0xb8, 0x38, 0xe6, 0x7b, 0xba, 0x66, 0x0a,
+	0x2d, 0x7d, 0xcf, 0x98, 0x4f, 0x96, 0x04, 0xbe, 0x5a, 0x65, 0xdf, 0x72, 0x27, 0x69, 0x46, 0x3d,
+	0xe2, 0xe1, 0xa7, 0xe4, 0x07, 0xac, 0xae, 0x36, 0xa5, 0x56, 0xc5, 0x1c, 0xeb, 0x85, 0x6c, 0x95,
+	0xa9, 0x6c, 0x6d, 0xf8, 0xff, 0x9c, 0xca, 0x45, 0x63, 0x1f, 0x40, 0xcd, 0xcb, 0x0e, 0xc5, 0xbb,
+	0x6c, 0x95, 0x34, 0x77, 0xe2, 0x64, 0x02, 0xed, 0xfc, 0xb2, 0x06, 0x0a, 0xa7, 0x4c, 0xd4, 0x83,
+	0xca, 0x43, 0x4c, 0x91, 0x51, 0xe2, 0x66, 0x6a, 0x55, 0x6b, 0xed, 0x85, 0xed, 0x45, 0xea, 0x7d,
+	0xa8, 0xa6, 0x44, 0x8d, 0xca, 0x7e, 0x31, 0xcd, 0x90, 0xbf, 0xb6, 0xbb, 0x04, 0x42, 0x04, 0x0b,
+	0x40, 0xe1, 0xcb, 0x18, 0x95, 0x81, 0x67, 0x7f, 0x0b, 0x68, 0x9d, 0x65, 0x20, 0x93, 0x80, 0x7c,
+	0x1d, 0x96, 0x06, 0x9c, 0x5d, 0xe5, 0xa5, 0x01, 0xe7, 0x2d, 0xda, 0xa7, 0xa0, 0xf0, 0xed, 0x54,
+	0x1a, 0x70, 0x76, 0x89, 0x69, 0xdb, 0x33, 0x4b, 0xfe, 0x28, 0xfd, 0x05, 0x8e, 0x2e, 0x60, 0x23,
+	0xcf, 0x56, 0xa8, 0xb3, 0x18, 0xdf, 0x15, 0x7c, 0xdf, 0x59, 0x0a, 0x23, 0xaa, 0xb9, 0x80, 0x8d,
+	0x3c, 0x91, 0x94, 0x06, 0x9e, 0x43, 0x7c, 0xa5, 0x81, 0xe7, 0x32, 0xd5, 0xcf, 0x12, 0xdc, 0x98,
+	0x79, 0x6e, 0xe8, 0x93, 0x05, 0x2f, 0xf7, 0x34, 0x35, 0x69, 0x77, 0x97, 0x07, 0xf2, 0x44, 0x0e,
+	0x4e, 0x2f, 0x5f, 0x37, 0x56, 0xfe, 0x7a, 0xdd, 0x58, 0xf9, 0x71, 0xd4, 0x90, 0x2e, 0x47, 0x0d,
+	0xe9, 0x8f, 0x51, 0x43, 0xfa, 0x67, 0xd4, 0x90, 0xbe, 0xf9, 0xec, 0x2d, 0xff, 0xa8, 0xed, 0x73,
+	0xe9, 0x74, 0xe5, 0x4c, 0x61, 0x63, 0xbe, 0xf3, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x68,
+	0x0a, 0xa2, 0xf3, 0x0d, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index d559f8d..d795bc3 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -136,7 +136,13 @@ message EncryptConfig {
 	bytes gpgpubkeyring = 2;
 }
 
+message DecryptKeyData {
+	bytes keyData = 1;
+	bytes keyDataPassword = 2;
+}
+
 message DecryptConfig {
+	map<uint64, DecryptKeyData> keyIdMap = 1;
 }
 
 message EncryptImageRequest {
@@ -154,7 +160,7 @@ message DecryptImageRequest {
 	string name = 1;
 	string newName = 2;
 
-	DecryptConfig cc = 3;
+	DecryptConfig dc = 3;
 }
 
 message DecryptImageResponse {
diff --git a/image_store.go b/image_store.go
index 0b42a6b..4d66877 100644
--- a/image_store.go
+++ b/image_store.go
@@ -67,13 +67,19 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, ec *images.CryptoConfig) (images.Image, error) {
-	fmt.Printf("image_store.go: DecryptImage() name=%s\n", name);
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
+	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
+	for k, v := range cc.Dc.KeyIdMap {
+		keyIdMap[k] = &imagesapi.DecryptKeyData{
+			KeyData:         v.KeyData,
+			KeyDataPassword: v.KeyDataPassword,
+		}
+	}
 	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
 		Name:    name,
 		NewName: newName,
-		Cc:      &imagesapi.DecryptConfig{
-			// FIXME: missing parameters here
+		Dc:      &imagesapi.DecryptConfig{
+			KeyIdMap: keyIdMap,
 		},
 	});
 	if err != nil {
@@ -84,7 +90,6 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, e
 }
 
 func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string) ([]images.LayerInfo, error) {
-	fmt.Printf("image_store.go: GetImageKeyIds() name=%s\n", name);
 	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
 		Name:    name,
 	});
diff --git a/images/encryption.go b/images/encryption.go
index 302a09f..60ab534 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -37,13 +37,27 @@ type EncryptConfig struct {
        GPGPubRingFile []byte
 }
 
-type CryptoConfig struct {
-	Ec *EncryptConfig
+// DecryptKeyData stores private key data for decryption and the necessary password
+// for being able to access/decrypt the private key data
+type DecryptKeyData struct {
+	KeyData []byte
+	KeyDataPassword []byte
+}
+
+// DecryptConfig stores the KeyIDs of keys needed for decryption as keys of
+// a map and the actual private key data in the values
+type DecryptConfig struct {
+	KeyIdMap map[uint64]DecryptKeyData
 }
 
-type Encryptor interface {
+// CryptoConfig is a common wrapper for EncryptConfig and DecrypConfig that can
+// be passed through functions that share much code for encryption and decryption
+type CryptoConfig struct {
+	Ec *EncryptConfig
+	Dc *DecryptConfig
 }
 
+// ReadGPGPubRingFile reads the GPG public key ring file
 func ReadGPGPubRingFile() ([]byte, error) {
 	home, err := homedir.Dir()
 	if err != nil {
@@ -112,7 +126,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 	return filteredList, nil
 }
 
-// Encrypt encrypts a byte array using data from the EncryptConfig
+// Encrypt encrypts a byte array using data from the CryptoConfig
 func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 	filteredList, err := createEntityList(cc)
 	if err != nil {
@@ -141,13 +155,37 @@ func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 	return ioutil.ReadAll(buf)
 }
 
-// Decrypt decrypts a byte array using data from the EncryptConfig
+// Decrypt decrypts a byte array using data from the CryptoConfig
 func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
-	// nothing here for now...
-	return data, fmt.Errorf("Missing implementation")
+	dc := cc.Dc
+	keyIds, err := GetKeyIds(data, ocispec.Descriptor{})
+	if err != nil {
+		return []byte{}, err
+	}
+	// decrypt with the right key
+	for _, keyId := range keyIds {
+		if keydata, ok := dc.KeyIdMap[keyId]; ok {
+			r := bytes.NewReader(keydata.KeyData)
+			entityList, err := openpgp.ReadKeyRing(r)
+			if err != nil {
+				return []byte{}, err
+			}
+			entity := entityList[0]
+			entity.PrivateKey.Decrypt(keydata.KeyDataPassword)
+			for _, subkey := range entity.Subkeys {
+				subkey.PrivateKey.Decrypt(keydata.KeyDataPassword)
+			}
+			md, err := openpgp.ReadMessage(bytes.NewBuffer(data), entityList, nil, nil)
+			if err != nil {
+				return []byte{}, err
+			}
+			return ioutil.ReadAll(md.UnverifiedBody)
+		}
+	}
+	return []byte{}, fmt.Errorf("No suitable decryption key was found.")
 }
 
-// GetKeyIds 
+// GetKeyIds gets the Key IDs for which the data are encrypted
 func GetKeyIds(encData []byte, desc ocispec.Descriptor) ([]uint64, error) {
 	var keyids []uint64
 
diff --git a/images/image.go b/images/image.go
index ddf13f6..c734e76 100644
--- a/images/image.go
+++ b/images/image.go
@@ -367,23 +367,24 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 		Size:     size,
 		Platform: desc.Platform,
 	}
-	newDesc.Annotations = make(map[string]string)
-	newDesc.Annotations["org.opencontainers.image.pgp.keys"] = "foo-bar"
+	if encrypt {
+		newDesc.Annotations = make(map[string]string)
+		newDesc.Annotations["org.opencontainers.image.pgp.keys"] = "foo-bar"
+	}
 
 	switch (desc.MediaType) {
 	case MediaTypeDockerSchema2LayerGzip:
 		newDesc.MediaType = MediaTypeDockerSchema2LayerGzipPGP
-	case MediaTypeDockerSchema2LayerGzipPGP:
-		newDesc.MediaType = MediaTypeDockerSchema2LayerGzip
 	case MediaTypeDockerSchema2Layer:
 		newDesc.MediaType = MediaTypeDockerSchema2LayerPGP
+	case MediaTypeDockerSchema2LayerGzipPGP:
+		newDesc.MediaType = MediaTypeDockerSchema2LayerGzip
 	case MediaTypeDockerSchema2LayerPGP:
 		newDesc.MediaType = MediaTypeDockerSchema2Layer
 	default:
 		return ocispec.Descriptor{}, errors.Wrapf(err, "Unsupporter layer MediaType: %s\n", desc.MediaType)
 	}
 
-	fmt.Printf("   ... writing layer %s in encrypted form as %s\n", desc.Digest, d)
 	ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
 	content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc);
 
diff --git a/services/images/local.go b/services/images/local.go
index 0998710..063ea21 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -212,8 +212,19 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 
 	var resp       imagesapi.DecryptImageResponse
 
+	keyIdMap := make(map[uint64]images.DecryptKeyData)
+
+	for k, v := range req.Dc.KeyIdMap {
+		keyIdMap[k] = images.DecryptKeyData{
+			KeyData:         v.KeyData,
+			KeyDataPassword: v.KeyDataPassword,
+		}
+	}
+
 	encrypted, err := l.store.DecryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
-		// FIXME: missing parameters here
+		Dc:	&images.DecryptConfig{
+			KeyIdMap: keyIdMap,
+		},
 	})
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
-- 
2.7.4


From 7cee0923d846b102cede40e43c5bc6407c1ee66c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 07:05:18 -0400
Subject: [PATCH 18/79] Enable password entry for private keys and decrypt
 image

---
 cmd/ctr/commands/images/decrypt.go | 53 +++++++++++++++++++++++++++++++++++---
 1 file changed, 50 insertions(+), 3 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index c7814df..4fd7453 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -17,11 +17,17 @@
 package images
 
 import (
+	"io/ioutil"
+	"os/exec"
 	"fmt"
+	"syscall"
 
+	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/cmd/ctr/commands"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
+
+	"golang.org/x/crypto/ssh/terminal"
 )
 
 var decryptCommand = cli.Command{
@@ -64,19 +70,60 @@ var decryptCommand = cli.Command{
 			keyIds = addToSet(keyIds, LayerInfos[i].KeyIds)
 		}
 
+		keyIdMap := make(map[uint64]images.DecryptKeyData)
 		if len(keyIds) == 0 {
-			fmt.Printf("Image is not encrypted.\n")
+			fmt.Printf("The image is not encrypted.\n")
+			return nil
 		} else {
-			fmt.Printf("Image is encrypted to the following keys: ")
 			for _, keyid := range keyIds {
-				fmt.Printf("0x%x ", keyid)
+				fmt.Printf("Enter password for key with Id 0x%x: ", keyid)
+				password, err := terminal.ReadPassword(int(syscall.Stdin))
+				if err != nil {
+					return err
+				}
+				keydata, err := GetGPGPrivateKey(keyid, string(password))
+				if err != nil {
+					return err
+				}
+				keyIdMap[keyid] = images.DecryptKeyData{
+					KeyData:         keydata,
+					KeyDataPassword: password,
+				}
 			}
 			fmt.Printf("\n")
 		}
+		client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
+			Dc: &images.DecryptConfig {
+				KeyIdMap: keyIdMap,
+			},
+		})
+
 		return nil
 	},
 }
 
+func GetGPGPrivateKey (keyid uint64, password string) ([]byte, error) {
+	args := append([]string{"--pinentry-mode", "loopback", "--passphrase", password,"--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	if err != nil {
+		return nil, err
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, err
+	}
+
+	return keydata, err2
+}
+
 func addToSet(set, add []uint64) []uint64 {
 	for i := 0; i < len(add); i++ {
 		found := false
-- 
2.7.4


From bbb41a17988a9dfdea73735e1730ada2e303d79e Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 11:10:46 -0400
Subject: [PATCH 19/79] Check each layer and prompt for password for each one
 of them

---
 cmd/ctr/commands/images/decrypt.go | 57 ++++++++++++++++++++++++++++++++------
 1 file changed, 49 insertions(+), 8 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 4fd7453..0e53840 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -65,17 +65,38 @@ var decryptCommand = cli.Command{
 		if err != nil {
 			return err
 		}
-		var keyIds []uint64
+
+		isEncrypted := false
 		for i := 0; i < len(LayerInfos); i++ {
-			keyIds = addToSet(keyIds, LayerInfos[i].KeyIds)
+			if len(LayerInfos[i].KeyIds) > 0 {
+				isEncrypted = true
+			}
 		}
-
-		keyIdMap := make(map[uint64]images.DecryptKeyData)
-		if len(keyIds) == 0 {
+		if !isEncrypted {
 			fmt.Printf("The image is not encrypted.\n")
 			return nil
-		} else {
-			for _, keyid := range keyIds {
+		}
+
+		keyIdMap := make(map[uint64]images.DecryptKeyData)
+
+		// we need one key per encrypted layer
+		for _, LayerInfo := range LayerInfos {
+			found := false
+			for _, keyid := range LayerInfo.KeyIds {
+				if _, ok := keyIdMap[keyid]; ok {
+					// password already there
+					found = true
+					break
+				}
+				// do we have this key
+				haveKey, err := HaveGPGPrivateKey(keyid)
+				if err != nil {
+					return err
+				}
+				if !haveKey {
+					// key not on this system
+					continue
+				}
 				fmt.Printf("Enter password for key with Id 0x%x: ", keyid)
 				password, err := terminal.ReadPassword(int(syscall.Stdin))
 				if err != nil {
@@ -89,9 +110,14 @@ var decryptCommand = cli.Command{
 					KeyData:         keydata,
 					KeyDataPassword: password,
 				}
+				found = true
+				break
+			}
+			if !found {
+				return fmt.Errorf("Missing key for decryption of layer %d.\n", LayerInfo.Id)
 			}
-			fmt.Printf("\n")
 		}
+		fmt.Printf("\n")
 		client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
 			Dc: &images.DecryptConfig {
 				KeyIdMap: keyIdMap,
@@ -102,6 +128,21 @@ var decryptCommand = cli.Command{
 	},
 }
 
+func HaveGPGPrivateKey(keyid uint64) (bool, error) {
+	args := append([]string{"-K"}, fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	if err := cmd.Start(); err != nil {
+		return false, err
+	}
+
+	if err := cmd.Wait(); err != nil {
+		return false, err
+	}
+	return true, nil
+}
+
 func GetGPGPrivateKey (keyid uint64, password string) ([]byte, error) {
 	args := append([]string{"--pinentry-mode", "loopback", "--passphrase", password,"--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
 
-- 
2.7.4


From 7727865ee3e183a6140bd94f8f276ebb9f9c60bf Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Tue, 24 Jul 2018 11:20:30 -0400
Subject: [PATCH 20/79] Create encrypt/decrypt for layers with separated
 openpgp packets

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/openpgp.go | 231 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 231 insertions(+)
 create mode 100644 images/openpgp.go

diff --git a/images/openpgp.go b/images/openpgp.go
new file mode 100644
index 0000000..12fabf6
--- /dev/null
+++ b/images/openpgp.go
@@ -0,0 +1,231 @@
+package images
+
+import (
+	"bytes"
+	"io"
+	"io/ioutil"
+	"log"
+	"fmt"
+	"time"
+
+	"crypto"
+	"crypto/rand"
+	"golang.org/x/crypto/openpgp"
+	"golang.org/x/crypto/openpgp/packet"
+)
+
+var (
+	// DefaultEncryptConfig is the default configuration for layer encryption/decryption
+	DefaultEncryptConfig = &packet.Config{
+		Rand:              rand.Reader,
+		DefaultHash:       crypto.SHA256,
+		DefaultCipher:     packet.CipherAES128,
+		CompressionConfig: &packet.CompressionConfig{Level: 0}, // No compression
+		RSABits:           2048,
+	}
+)
+
+// createWrappedKeys creates wrapped key bytes
+func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
+	// Array of serialized EncryptedKeys
+	encKeys := make([][]byte, 0, len(recipients))
+	encKeyBuf := new(bytes.Buffer)
+
+	for _, et := range recipients {
+		pkey, canEncrypt := encryptionKey(et, time.Now())
+		if !canEncrypt {
+			log.Printf("Error key doesn't support encryption")
+			return nil, fmt.Errorf("key doesn't support encryption")
+		}
+		if err := packet.SerializeEncryptedKey(encKeyBuf, pkey.PublicKey, config.DefaultCipher, symKey, config); err != nil {
+			return nil, fmt.Errorf("Error serializing encrypted key: %v", err)
+		}
+		encryptedKeyBytes := encKeyBuf.Bytes()
+		encKeys = append(encKeys, encryptedKeyBytes)
+		encKeyBuf = new(bytes.Buffer)
+	}
+
+	log.Printf("Encrypted keys' bytes: %x", encKeys)
+
+	return encKeys, nil
+}
+
+// createEncryptedBlob creates encrypted data blob bytes
+func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (encBlob []byte, err error) {
+	// Perform encryption
+	encData := new(bytes.Buffer)
+	encContent, err := packet.SerializeSymmetricallyEncrypted(encData, config.DefaultCipher, symKey, config)
+	if err != nil {
+		return nil, fmt.Errorf("Error serializing SymmetricallyEncrypted packet: %v", err)
+	}
+
+	content, err := packet.SerializeLiteral(encContent, true, "", 0)
+	if err != nil {
+		return nil, fmt.Errorf("Error serializing Lietral packet: %v", err)
+	}
+
+	content.Write(data)
+	content.Close()
+
+	encBlob = encData.Bytes()
+	log.Printf("Encrypted data bytes: %x", encBlob)
+
+	return encBlob, nil
+}
+
+func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList) (data []byte, err error) {
+	// Assemble message by concatenating packets
+	message := make([]byte, 0)
+	for _, ek := range wrappedKeys {
+		message = append(message, ek...)
+
+		// experiment
+		ekbuf := bytes.NewBuffer(ek)
+		p, err := packet.Read(ekbuf)
+		if err != nil {
+			log.Fatalf("Err reading enc key packet: %v", err)
+		}
+
+		pek := p.(*packet.EncryptedKey)
+		log.Printf("Enckey KeyID: %x", pek.KeyId)
+		log.Printf("  getting KeyID: %v", kring.KeysById(pek.KeyId))
+
+	}
+
+	message = append(message, encBlob...)
+
+	log.Printf("Encrypted message bytes: %x", message)
+
+	promptFunc := func(key []openpgp.Key, symm bool) ([]byte, error) {
+		for _, k := range key {
+			if symm {
+				return nil, fmt.Errorf("Not handled")
+			} else {
+				k.PrivateKey.Decrypt([]byte("hidden!"))
+			}
+		}
+		return nil, nil
+	}
+	messageIn := bytes.NewBuffer(message)
+	md, err := openpgp.ReadMessage(messageIn, kring, promptFunc, DefaultEncryptConfig)
+	if err != nil {
+		return nil, fmt.Errorf("Unable to read message: %v", err)
+	}
+
+	plaintext, err := ioutil.ReadAll(md.UnverifiedBody)
+	if err != nil {
+		return nil, fmt.Errorf("error reading encrypted contents: %s", err)
+	}
+
+	return plaintext, nil
+}
+
+func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (encBlob []byte, wrappedKeys [][]byte, err error) {
+	config := DefaultEncryptConfig
+
+	// If no symkey, generate
+	if len(symKey) == 0 {
+		symKey = make([]byte, config.DefaultCipher.KeySize())
+		if _, err := io.ReadFull(config.Random(), symKey); err != nil {
+			return nil, nil, err
+		}
+	}
+
+	wrappedKeys, err = createWrappedKeys(symKey, recipients, config)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	encBlob, err = createEncryptedBlob(data, symKey, config)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	return encBlob, wrappedKeys, nil
+}
+
+// Helper private functions copied from golang.org/x/crypto/openpgp/packet
+
+// encryptionKey returns the best candidate Key for encrypting a message to the
+// given Entity.
+func encryptionKey(e *openpgp.Entity, now time.Time) (openpgp.Key, bool) {
+	candidateSubkey := -1
+
+	// Iterate the keys to find the newest key
+	var maxTime time.Time
+	for i, subkey := range e.Subkeys {
+		if subkey.Sig.FlagsValid &&
+			subkey.Sig.FlagEncryptCommunications &&
+			subkey.PublicKey.PubKeyAlgo.CanEncrypt() &&
+			!subkey.Sig.KeyExpired(now) &&
+			(maxTime.IsZero() || subkey.Sig.CreationTime.After(maxTime)) {
+			candidateSubkey = i
+			maxTime = subkey.Sig.CreationTime
+		}
+	}
+
+	if candidateSubkey != -1 {
+		subkey := e.Subkeys[candidateSubkey]
+		return openpgp.Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true
+	}
+
+	// If we don't have any candidate subkeys for encryption and
+	// the primary key doesn't have any usage metadata then we
+	// assume that the primary key is ok. Or, if the primary key is
+	// marked as ok to encrypt to, then we can obviously use it.
+	i := primaryIdentity(e)
+	if !i.SelfSignature.FlagsValid || i.SelfSignature.FlagEncryptCommunications &&
+		e.PrimaryKey.PubKeyAlgo.CanEncrypt() &&
+		!i.SelfSignature.KeyExpired(now) {
+		return openpgp.Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true
+	}
+
+	// This Entity appears to be signing only.
+	return openpgp.Key{}, false
+}
+
+// signingKey return the best candidate Key for signing a message with this
+// Entity.
+func signingKey(e *openpgp.Entity, now time.Time) (openpgp.Key, bool) {
+	candidateSubkey := -1
+
+	for i, subkey := range e.Subkeys {
+		if subkey.Sig.FlagsValid &&
+			subkey.Sig.FlagSign &&
+			subkey.PublicKey.PubKeyAlgo.CanSign() &&
+			!subkey.Sig.KeyExpired(now) {
+			candidateSubkey = i
+			break
+		}
+	}
+
+	if candidateSubkey != -1 {
+		subkey := e.Subkeys[candidateSubkey]
+		return openpgp.Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true
+	}
+
+	// If we have no candidate subkey then we assume that it's ok to sign
+	// with the primary key.
+	i := primaryIdentity(e)
+	if !i.SelfSignature.FlagsValid || i.SelfSignature.FlagSign &&
+		!i.SelfSignature.KeyExpired(now) {
+		return openpgp.Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true
+	}
+
+	return openpgp.Key{}, false
+}
+
+// primaryIdentity returns the Identity marked as primary or the first identity
+// if none are so marked.
+func primaryIdentity(e *openpgp.Entity) *openpgp.Identity {
+	var firstIdentity *openpgp.Identity
+	for _, ident := range e.Identities {
+		if firstIdentity == nil {
+			firstIdentity = ident
+		}
+		if ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {
+			return ident
+		}
+	}
+	return firstIdentity
+}
-- 
2.7.4


From 13a81aace31eceb50c7a43ef358e90334fc92349 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Tue, 24 Jul 2018 11:31:00 -0400
Subject: [PATCH 21/79] Added comments to encrypt/decrypt functions

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/openpgp.go | 100 ++++++++++++++++++++++++++++--------------------------
 1 file changed, 51 insertions(+), 49 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 12fabf6..7ee5232 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -2,10 +2,10 @@ package images
 
 import (
 	"bytes"
+	"fmt"
 	"io"
 	"io/ioutil"
 	"log"
-	"fmt"
 	"time"
 
 	"crypto"
@@ -25,54 +25,32 @@ var (
 	}
 )
 
-// createWrappedKeys creates wrapped key bytes
-func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
-	// Array of serialized EncryptedKeys
-	encKeys := make([][]byte, 0, len(recipients))
-	encKeyBuf := new(bytes.Buffer)
+// encryptData encrypts data with openpgp and returns the encrypted blob and wrapped keys separately
+func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (encBlob []byte, wrappedKeys [][]byte, err error) {
+	config := DefaultEncryptConfig
 
-	for _, et := range recipients {
-		pkey, canEncrypt := encryptionKey(et, time.Now())
-		if !canEncrypt {
-			log.Printf("Error key doesn't support encryption")
-			return nil, fmt.Errorf("key doesn't support encryption")
-		}
-		if err := packet.SerializeEncryptedKey(encKeyBuf, pkey.PublicKey, config.DefaultCipher, symKey, config); err != nil {
-			return nil, fmt.Errorf("Error serializing encrypted key: %v", err)
+	// If no symkey, generate
+	if len(symKey) == 0 {
+		symKey = make([]byte, config.DefaultCipher.KeySize())
+		if _, err := io.ReadFull(config.Random(), symKey); err != nil {
+			return nil, nil, err
 		}
-		encryptedKeyBytes := encKeyBuf.Bytes()
-		encKeys = append(encKeys, encryptedKeyBytes)
-		encKeyBuf = new(bytes.Buffer)
 	}
 
-	log.Printf("Encrypted keys' bytes: %x", encKeys)
-
-	return encKeys, nil
-}
-
-// createEncryptedBlob creates encrypted data blob bytes
-func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (encBlob []byte, err error) {
-	// Perform encryption
-	encData := new(bytes.Buffer)
-	encContent, err := packet.SerializeSymmetricallyEncrypted(encData, config.DefaultCipher, symKey, config)
+	wrappedKeys, err = createWrappedKeys(symKey, recipients, config)
 	if err != nil {
-		return nil, fmt.Errorf("Error serializing SymmetricallyEncrypted packet: %v", err)
+		return nil, nil, err
 	}
 
-	content, err := packet.SerializeLiteral(encContent, true, "", 0)
+	encBlob, err = createEncryptedBlob(data, symKey, config)
 	if err != nil {
-		return nil, fmt.Errorf("Error serializing Lietral packet: %v", err)
+		return nil, nil, err
 	}
 
-	content.Write(data)
-	content.Close()
-
-	encBlob = encData.Bytes()
-	log.Printf("Encrypted data bytes: %x", encBlob)
-
-	return encBlob, nil
+	return encBlob, wrappedKeys, nil
 }
 
+// decryptData decrypts an openpgp encrypted blob and wrapped keys and returns the decrypted data
 func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList) (data []byte, err error) {
 	// Assemble message by concatenating packets
 	message := make([]byte, 0)
@@ -120,28 +98,52 @@ func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList)
 	return plaintext, nil
 }
 
-func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (encBlob []byte, wrappedKeys [][]byte, err error) {
-	config := DefaultEncryptConfig
+// createWrappedKeys creates wrapped key bytes
+func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
+	// Array of serialized EncryptedKeys
+	encKeys := make([][]byte, 0, len(recipients))
+	encKeyBuf := new(bytes.Buffer)
 
-	// If no symkey, generate
-	if len(symKey) == 0 {
-		symKey = make([]byte, config.DefaultCipher.KeySize())
-		if _, err := io.ReadFull(config.Random(), symKey); err != nil {
-			return nil, nil, err
+	for _, et := range recipients {
+		pkey, canEncrypt := encryptionKey(et, time.Now())
+		if !canEncrypt {
+			log.Printf("Error key doesn't support encryption")
+			return nil, fmt.Errorf("key doesn't support encryption")
+		}
+		if err := packet.SerializeEncryptedKey(encKeyBuf, pkey.PublicKey, config.DefaultCipher, symKey, config); err != nil {
+			return nil, fmt.Errorf("Error serializing encrypted key: %v", err)
 		}
+		encryptedKeyBytes := encKeyBuf.Bytes()
+		encKeys = append(encKeys, encryptedKeyBytes)
+		encKeyBuf = new(bytes.Buffer)
 	}
 
-	wrappedKeys, err = createWrappedKeys(symKey, recipients, config)
+	log.Printf("Encrypted keys' bytes: %x", encKeys)
+
+	return encKeys, nil
+}
+
+// createEncryptedBlob creates encrypted data blob bytes
+func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (encBlob []byte, err error) {
+	// Perform encryption
+	encData := new(bytes.Buffer)
+	encContent, err := packet.SerializeSymmetricallyEncrypted(encData, config.DefaultCipher, symKey, config)
 	if err != nil {
-		return nil, nil, err
+		return nil, fmt.Errorf("Error serializing SymmetricallyEncrypted packet: %v", err)
 	}
 
-	encBlob, err = createEncryptedBlob(data, symKey, config)
+	content, err := packet.SerializeLiteral(encContent, true, "", 0)
 	if err != nil {
-		return nil, nil, err
+		return nil, fmt.Errorf("Error serializing Lietral packet: %v", err)
 	}
 
-	return encBlob, wrappedKeys, nil
+	content.Write(data)
+	content.Close()
+
+	encBlob = encData.Bytes()
+	log.Printf("Encrypted data bytes: %x", encBlob)
+
+	return encBlob, nil
 }
 
 // Helper private functions copied from golang.org/x/crypto/openpgp/packet
-- 
2.7.4


From 0d924e17f21714d4381c3eccd470eb7ace8d7acb Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 14:46:26 -0400
Subject: [PATCH 22/79] Allow selection of layers to encrypt/decrypt using
 --layer option.

---
 api/next.pb.txt                      |  22 +-
 api/services/images/v1/images.pb.go  | 455 ++++++++++++++++++++++++++---------
 api/services/images/v1/images.proto  |   4 +-
 cmd/ctr/commands/images/decrypt.go   |  18 +-
 cmd/ctr/commands/images/encrypt.go   |   5 +-
 cmd/ctr/commands/images/layerinfo.go |   7 +-
 cmd/ctr/commands/images/push.go      |   2 +-
 image_store.go                       |  20 +-
 images/image.go                      |  89 +++++--
 metadata/images.go                   |  17 +-
 services/images/local.go             |  17 +-
 11 files changed, 493 insertions(+), 163 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 27be0b7..81c3512 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2308,6 +2308,13 @@ file {
       type_name: ".containerd.services.images.v1.EncryptConfig"
       json_name: "cc"
     }
+    field {
+      name: "layers"
+      number: 4
+      label: LABEL_REPEATED
+      type: TYPE_INT32
+      json_name: "layers"
+    }
   }
   message_type {
     name: "EncryptImageResponse"
@@ -2347,6 +2354,13 @@ file {
       type_name: ".containerd.services.images.v1.DecryptConfig"
       json_name: "dc"
     }
+    field {
+      name: "layers"
+      number: 4
+      label: LABEL_REPEATED
+      type: TYPE_INT32
+      json_name: "layers"
+    }
   }
   message_type {
     name: "DecryptImageResponse"
@@ -2372,11 +2386,11 @@ file {
       json_name: "name"
     }
     field {
-      name: "platform"
+      name: "layers"
       number: 2
-      label: LABEL_OPTIONAL
-      type: TYPE_STRING
-      json_name: "platform"
+      label: LABEL_REPEATED
+      type: TYPE_INT32
+      json_name: "layers"
     }
   }
   message_type {
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 1a7670e..06e6e42 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -213,6 +213,7 @@ type EncryptImageRequest struct {
 	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
 	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
 	Cc      *EncryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Layers  []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
 }
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
@@ -231,6 +232,7 @@ type DecryptImageRequest struct {
 	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
 	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
 	Dc      *DecryptConfig `protobuf:"bytes,3,opt,name=dc" json:"dc,omitempty"`
+	Layers  []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
 }
 
 func (m *DecryptImageRequest) Reset()                    { *m = DecryptImageRequest{} }
@@ -246,8 +248,8 @@ func (*DecryptImageResponse) ProtoMessage()               {}
 func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type GetImageLayerInfoRequest struct {
-	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	Platform string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
+	Name   string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Layers []int32 `protobuf:"varint,2,rep,packed,name=layers" json:"layers,omitempty"`
 }
 
 func (m *GetImageLayerInfoRequest) Reset()                    { *m = GetImageLayerInfoRequest{} }
@@ -1102,6 +1104,24 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		}
 		i += n11
 	}
+	if len(m.Layers) > 0 {
+		dAtA13 := make([]byte, len(m.Layers)*10)
+		var j12 int
+		for _, num1 := range m.Layers {
+			num := uint64(num1)
+			for num >= 1<<7 {
+				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j12++
+			}
+			dAtA13[j12] = uint8(num)
+			j12++
+		}
+		dAtA[i] = 0x22
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(j12))
+		i += copy(dAtA[i:], dAtA13[:j12])
+	}
 	return i, nil
 }
 
@@ -1123,11 +1143,11 @@ func (m *EncryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n12, err := m.Image.MarshalTo(dAtA[i:])
+	n14, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n12
+	i += n14
 	return i, nil
 }
 
@@ -1162,11 +1182,29 @@ func (m *DecryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.Dc.Size()))
-		n13, err := m.Dc.MarshalTo(dAtA[i:])
+		n15, err := m.Dc.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n13
+		i += n15
+	}
+	if len(m.Layers) > 0 {
+		dAtA17 := make([]byte, len(m.Layers)*10)
+		var j16 int
+		for _, num1 := range m.Layers {
+			num := uint64(num1)
+			for num >= 1<<7 {
+				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j16++
+			}
+			dAtA17[j16] = uint8(num)
+			j16++
+		}
+		dAtA[i] = 0x22
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(j16))
+		i += copy(dAtA[i:], dAtA17[:j16])
 	}
 	return i, nil
 }
@@ -1189,11 +1227,11 @@ func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n14, err := m.Image.MarshalTo(dAtA[i:])
+	n18, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n14
+	i += n18
 	return i, nil
 }
 
@@ -1218,11 +1256,23 @@ func (m *GetImageLayerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Name)))
 		i += copy(dAtA[i:], m.Name)
 	}
-	if len(m.Platform) > 0 {
+	if len(m.Layers) > 0 {
+		dAtA20 := make([]byte, len(m.Layers)*10)
+		var j19 int
+		for _, num1 := range m.Layers {
+			num := uint64(num1)
+			for num >= 1<<7 {
+				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
+				num >>= 7
+				j19++
+			}
+			dAtA20[j19] = uint8(num)
+			j19++
+		}
 		dAtA[i] = 0x12
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(len(m.Platform)))
-		i += copy(dAtA[i:], m.Platform)
+		i = encodeVarintImages(dAtA, i, uint64(j19))
+		i += copy(dAtA[i:], dAtA20[:j19])
 	}
 	return i, nil
 }
@@ -1248,21 +1298,21 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(m.ID))
 	}
 	if len(m.KeyIds) > 0 {
-		dAtA16 := make([]byte, len(m.KeyIds)*10)
-		var j15 int
+		dAtA22 := make([]byte, len(m.KeyIds)*10)
+		var j21 int
 		for _, num := range m.KeyIds {
 			for num >= 1<<7 {
-				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j15++
+				j21++
 			}
-			dAtA16[j15] = uint8(num)
-			j15++
+			dAtA22[j21] = uint8(num)
+			j21++
 		}
 		dAtA[i] = 0x12
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j15))
-		i += copy(dAtA[i:], dAtA16[:j15])
+		i = encodeVarintImages(dAtA, i, uint64(j21))
+		i += copy(dAtA[i:], dAtA22[:j21])
 	}
 	if len(m.Digest) > 0 {
 		dAtA[i] = 0x1a
@@ -1510,6 +1560,13 @@ func (m *EncryptImageRequest) Size() (n int) {
 		l = m.Cc.Size()
 		n += 1 + l + sovImages(uint64(l))
 	}
+	if len(m.Layers) > 0 {
+		l = 0
+		for _, e := range m.Layers {
+			l += sovImages(uint64(e))
+		}
+		n += 1 + sovImages(uint64(l)) + l
+	}
 	return n
 }
 
@@ -1536,6 +1593,13 @@ func (m *DecryptImageRequest) Size() (n int) {
 		l = m.Dc.Size()
 		n += 1 + l + sovImages(uint64(l))
 	}
+	if len(m.Layers) > 0 {
+		l = 0
+		for _, e := range m.Layers {
+			l += sovImages(uint64(e))
+		}
+		n += 1 + sovImages(uint64(l)) + l
+	}
 	return n
 }
 
@@ -1554,9 +1618,12 @@ func (m *GetImageLayerInfoRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
-	l = len(m.Platform)
-	if l > 0 {
-		n += 1 + l + sovImages(uint64(l))
+	if len(m.Layers) > 0 {
+		l = 0
+		for _, e := range m.Layers {
+			l += sovImages(uint64(e))
+		}
+		n += 1 + sovImages(uint64(l)) + l
 	}
 	return n
 }
@@ -1783,6 +1850,7 @@ func (this *EncryptImageRequest) String() string {
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
 		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "EncryptConfig", "EncryptConfig", 1) + `,`,
+		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1805,6 +1873,7 @@ func (this *DecryptImageRequest) String() string {
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
 		`Dc:` + strings.Replace(fmt.Sprintf("%v", this.Dc), "DecryptConfig", "DecryptConfig", 1) + `,`,
+		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1825,7 +1894,7 @@ func (this *GetImageLayerInfoRequest) String() string {
 	}
 	s := strings.Join([]string{`&GetImageLayerInfoRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
-		`Platform:` + fmt.Sprintf("%v", this.Platform) + `,`,
+		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -3428,6 +3497,68 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType == 0 {
+				var v int32
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= (int32(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				m.Layers = append(m.Layers, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= (int(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthImages
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				for iNdEx < postIndex {
+					var v int32
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= (int32(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Layers = append(m.Layers, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3649,6 +3780,68 @@ func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
 				return err
 			}
 			iNdEx = postIndex
+		case 4:
+			if wireType == 0 {
+				var v int32
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= (int32(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				m.Layers = append(m.Layers, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= (int(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthImages
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex > l {
+					return io.ErrUnexpectedEOF
+				}
+				for iNdEx < postIndex {
+					var v int32
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= (int32(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Layers = append(m.Layers, v)
+				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3809,34 +4002,67 @@ func (m *GetImageLayerInfoRequest) Unmarshal(dAtA []byte) error {
 			m.Name = string(dAtA[iNdEx:postIndex])
 			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
-			}
-			var stringLen uint64
-			for shift := uint(0); ; shift += 7 {
-				if shift >= 64 {
-					return ErrIntOverflowImages
+			if wireType == 0 {
+				var v int32
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					v |= (int32(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
 				}
-				if iNdEx >= l {
+				m.Layers = append(m.Layers, v)
+			} else if wireType == 2 {
+				var packedLen int
+				for shift := uint(0); ; shift += 7 {
+					if shift >= 64 {
+						return ErrIntOverflowImages
+					}
+					if iNdEx >= l {
+						return io.ErrUnexpectedEOF
+					}
+					b := dAtA[iNdEx]
+					iNdEx++
+					packedLen |= (int(b) & 0x7F) << shift
+					if b < 0x80 {
+						break
+					}
+				}
+				if packedLen < 0 {
+					return ErrInvalidLengthImages
+				}
+				postIndex := iNdEx + packedLen
+				if postIndex > l {
 					return io.ErrUnexpectedEOF
 				}
-				b := dAtA[iNdEx]
-				iNdEx++
-				stringLen |= (uint64(b) & 0x7F) << shift
-				if b < 0x80 {
-					break
+				for iNdEx < postIndex {
+					var v int32
+					for shift := uint(0); ; shift += 7 {
+						if shift >= 64 {
+							return ErrIntOverflowImages
+						}
+						if iNdEx >= l {
+							return io.ErrUnexpectedEOF
+						}
+						b := dAtA[iNdEx]
+						iNdEx++
+						v |= (int32(b) & 0x7F) << shift
+						if b < 0x80 {
+							break
+						}
+					}
+					m.Layers = append(m.Layers, v)
 				}
+			} else {
+				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
 			}
-			intStringLen := int(stringLen)
-			if intStringLen < 0 {
-				return ErrInvalidLengthImages
-			}
-			postIndex := iNdEx + intStringLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.Platform = string(dAtA[iNdEx:postIndex])
-			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -4286,72 +4512,73 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 1062 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
-	0x13, 0x36, 0x29, 0x99, 0xb6, 0x46, 0xf6, 0x9b, 0x64, 0x63, 0x18, 0x7c, 0xd9, 0x56, 0x16, 0x88,
-	0x14, 0xd0, 0xa1, 0xa1, 0x6a, 0xe5, 0xd0, 0xd4, 0x0e, 0x8a, 0xc6, 0x96, 0x93, 0xba, 0x71, 0x82,
-	0x82, 0xf9, 0xa8, 0xd1, 0x4b, 0x40, 0x93, 0x2b, 0x76, 0x2b, 0x8a, 0x64, 0xc9, 0x95, 0x0d, 0xf6,
-	0xd4, 0x5e, 0x7a, 0x6d, 0x81, 0xfe, 0x8c, 0xfe, 0x11, 0x1f, 0x0b, 0xf4, 0xd2, 0x53, 0xda, 0xe8,
-	0xd0, 0xdf, 0x51, 0x70, 0x77, 0x29, 0x91, 0x92, 0x10, 0x4a, 0x89, 0x6f, 0x33, 0xcb, 0x79, 0xe6,
-	0x73, 0xf7, 0x19, 0x09, 0xba, 0x2e, 0xa1, 0xdf, 0x0e, 0xcf, 0x0c, 0x3b, 0x18, 0xb4, 0xed, 0xc0,
-	0xa7, 0x16, 0xf1, 0x71, 0xe4, 0xe4, 0x45, 0x2b, 0x24, 0xed, 0x18, 0x47, 0xe7, 0xc4, 0xc6, 0x71,
-	0x9b, 0x0c, 0x2c, 0x17, 0xc7, 0xed, 0xf3, 0x5d, 0x21, 0x19, 0x61, 0x14, 0xd0, 0x00, 0x7d, 0x30,
-	0xb1, 0x37, 0x32, 0x5b, 0x43, 0x58, 0x9c, 0xef, 0x6a, 0x5b, 0x6e, 0xe0, 0x06, 0xcc, 0xb2, 0x9d,
-	0x4a, 0x1c, 0xa4, 0xbd, 0xe7, 0x06, 0x81, 0xeb, 0xe1, 0x36, 0xd3, 0xce, 0x86, 0xbd, 0x36, 0x1e,
-	0x84, 0x34, 0x11, 0x1f, 0x9b, 0xd3, 0x1f, 0x7b, 0x04, 0x7b, 0xce, 0xcb, 0x81, 0x15, 0xf7, 0x85,
-	0xc5, 0xce, 0xb4, 0x05, 0x25, 0x03, 0x1c, 0x53, 0x6b, 0x10, 0x0a, 0x83, 0xfd, 0x85, 0x4a, 0xa3,
-	0x49, 0x88, 0xe3, 0xb6, 0x83, 0x63, 0x3b, 0x22, 0x21, 0x0d, 0x22, 0x0e, 0xd6, 0xff, 0x95, 0x61,
-	0xf5, 0x38, 0x2d, 0x00, 0x21, 0xa8, 0xfa, 0xd6, 0x00, 0xab, 0x52, 0x53, 0x6a, 0xd5, 0x4c, 0x26,
-	0xa3, 0x2f, 0x40, 0xf1, 0xac, 0x33, 0xec, 0xc5, 0xaa, 0xdc, 0xac, 0xb4, 0xea, 0x9d, 0x8f, 0x8d,
-	0x37, 0x36, 0xc0, 0x60, 0x9e, 0x8c, 0x13, 0x06, 0x39, 0xf2, 0x69, 0x94, 0x98, 0x02, 0x8f, 0xf6,
-	0x40, 0xa1, 0x56, 0xe4, 0x62, 0xaa, 0x56, 0x9a, 0x52, 0xab, 0xde, 0x79, 0x3f, 0xef, 0x89, 0xe5,
-	0x66, 0x74, 0xc7, 0xb9, 0x1d, 0x54, 0x2f, 0x5f, 0xed, 0xac, 0x98, 0x02, 0x81, 0x0e, 0x01, 0xec,
-	0x08, 0x5b, 0x14, 0x3b, 0x2f, 0x2d, 0xaa, 0xae, 0x31, 0xbc, 0x66, 0xf0, 0xb6, 0x18, 0x59, 0x5b,
-	0x8c, 0x67, 0x59, 0x5b, 0x0e, 0xd6, 0x53, 0xf4, 0xaf, 0x7f, 0xef, 0x48, 0x66, 0x4d, 0xe0, 0xee,
-	0x33, 0x27, 0xc3, 0xd0, 0xc9, 0x9c, 0xac, 0x2f, 0xe3, 0x44, 0xe0, 0xee, 0x53, 0xed, 0x53, 0xa8,
-	0xe7, 0x8a, 0x43, 0xd7, 0xa1, 0xd2, 0xc7, 0x89, 0xe8, 0x58, 0x2a, 0xa2, 0x2d, 0x58, 0x3d, 0xb7,
-	0xbc, 0x21, 0x56, 0x65, 0x76, 0xc6, 0x95, 0x3d, 0xf9, 0xae, 0xa4, 0x7f, 0x08, 0xd7, 0x1e, 0x62,
-	0xca, 0x1a, 0x64, 0xe2, 0xef, 0x87, 0x38, 0xa6, 0xf3, 0x3a, 0xae, 0x3f, 0x81, 0xeb, 0x13, 0xb3,
-	0x38, 0x0c, 0xfc, 0x18, 0xa3, 0x3d, 0x58, 0x65, 0x2d, 0x66, 0x86, 0xf5, 0xce, 0xad, 0x45, 0x86,
-	0x60, 0x72, 0x88, 0xfe, 0x02, 0xd0, 0x21, 0xeb, 0x41, 0x21, 0xf2, 0xe7, 0x6f, 0xe1, 0x51, 0x0c,
-	0x45, 0xf8, 0xfd, 0x1a, 0x6e, 0x16, 0xfc, 0x8a, 0x54, 0xdf, 0xdd, 0xf1, 0x6f, 0x12, 0xa0, 0xe7,
-	0xac, 0xe1, 0x57, 0x9b, 0x31, 0xda, 0x87, 0x3a, 0x1f, 0x24, 0x7b, 0x5c, 0x6c, 0x40, 0xf3, 0x6e,
-	0xc0, 0x83, 0xf4, 0xfd, 0x3d, 0xb6, 0xe2, 0xbe, 0x29, 0xee, 0x4b, 0x2a, 0xa7, 0xe5, 0x16, 0x92,
-	0xba, 0xb2, 0x72, 0x6f, 0xc3, 0x8d, 0x13, 0x12, 0xf3, 0x81, 0xc7, 0x59, 0xb1, 0x2a, 0xac, 0xf5,
-	0x88, 0x47, 0x71, 0x14, 0xab, 0x52, 0xb3, 0xd2, 0xaa, 0x99, 0x99, 0xaa, 0x9f, 0x02, 0xca, 0x9b,
-	0x8b, 0x34, 0x0e, 0x40, 0xe1, 0x41, 0x98, 0xf9, 0x72, 0x79, 0x08, 0xa4, 0x7e, 0x0f, 0x50, 0x17,
-	0x7b, 0x78, 0xaa, 0xed, 0xf3, 0x48, 0x01, 0x41, 0x35, 0x4e, 0x7c, 0x9b, 0x75, 0x70, 0xdd, 0x64,
-	0xb2, 0xfe, 0x1c, 0x36, 0x8f, 0x7c, 0x3b, 0x4a, 0x42, 0x7a, 0x18, 0xf8, 0x3d, 0xe2, 0xa2, 0x06,
-	0x40, 0x84, 0x6d, 0x12, 0x12, 0xec, 0xd3, 0xac, 0x8a, 0xdc, 0x09, 0xba, 0x05, 0x9b, 0x6e, 0xe8,
-	0x86, 0xc3, 0xb3, 0x3e, 0x4e, 0x22, 0xe2, 0xbb, 0xcc, 0xdb, 0x86, 0x59, 0x3c, 0xd4, 0x9f, 0xc1,
-	0xff, 0xba, 0x98, 0xb9, 0x7d, 0x84, 0x93, 0xae, 0x45, 0xad, 0xb4, 0x35, 0x7d, 0x2e, 0xb2, 0x9c,
-	0x36, 0xcc, 0x4c, 0x45, 0x2d, 0xb8, 0x26, 0xc4, 0xaf, 0xac, 0x38, 0xbe, 0x08, 0x22, 0x47, 0xf8,
-	0x9c, 0x3e, 0xd6, 0xff, 0x94, 0x60, 0x53, 0xb8, 0x15, 0xd9, 0xbe, 0x80, 0xf5, 0x3e, 0x4e, 0x8e,
-	0x9d, 0xc7, 0x56, 0x28, 0x5a, 0xb8, 0x57, 0xd2, 0xc2, 0x02, 0xde, 0x78, 0x24, 0xc0, 0x9c, 0xf3,
-	0xc6, 0xbe, 0xb4, 0xef, 0x60, 0xb3, 0xf0, 0x29, 0xcf, 0x18, 0x55, 0xce, 0x18, 0x87, 0x79, 0xc6,
-	0xa8, 0x77, 0x6e, 0x2f, 0x16, 0x57, 0xb4, 0x23, 0x4f, 0x30, 0x3f, 0x49, 0x70, 0x53, 0xcc, 0xa0,
-	0x74, 0x84, 0x2a, 0xac, 0xf9, 0xf8, 0xe2, 0x49, 0x7a, 0xcc, 0x89, 0x2a, 0x53, 0xd1, 0x3d, 0x90,
-	0x6d, 0x5b, 0x70, 0xf4, 0x47, 0x25, 0xb9, 0x14, 0x26, 0x6e, 0xca, 0xb6, 0xad, 0x9f, 0xc2, 0x56,
-	0x31, 0x85, 0x2b, 0x7b, 0x27, 0x69, 0x75, 0xa2, 0xf6, 0x77, 0xab, 0xce, 0x59, 0xb4, 0xba, 0xc2,
-	0x84, 0x4d, 0xd9, 0x61, 0xd5, 0x15, 0x53, 0xb8, 0xb2, 0xea, 0xbe, 0x04, 0x35, 0x63, 0xfd, 0x13,
-	0x2b, 0xc1, 0xd1, 0xb1, 0xdf, 0x0b, 0xde, 0x54, 0xa1, 0x06, 0xeb, 0xa1, 0x67, 0xd1, 0x5e, 0x10,
-	0x0d, 0x44, 0x89, 0x63, 0x5d, 0xff, 0x5d, 0x82, 0xda, 0xd8, 0x09, 0xda, 0x06, 0x99, 0x38, 0x0c,
-	0xbb, 0x79, 0xa0, 0x8c, 0x5e, 0xed, 0xc8, 0xc7, 0x5d, 0x53, 0x26, 0x0e, 0xda, 0x06, 0x85, 0xdd,
-	0x52, 0xbe, 0xd9, 0xab, 0xa6, 0xd0, 0xd2, 0x73, 0x87, 0xb8, 0x38, 0xe6, 0x7b, 0xba, 0x66, 0x0a,
-	0x2d, 0x7d, 0xcf, 0x98, 0x4f, 0x96, 0x04, 0xbe, 0x5a, 0x65, 0xdf, 0x72, 0x27, 0x69, 0x46, 0x3d,
-	0xe2, 0xe1, 0xa7, 0xe4, 0x07, 0xac, 0xae, 0x36, 0xa5, 0x56, 0xc5, 0x1c, 0xeb, 0x85, 0x6c, 0x95,
-	0xa9, 0x6c, 0x6d, 0xf8, 0xff, 0x9c, 0xca, 0x45, 0x63, 0x1f, 0x40, 0xcd, 0xcb, 0x0e, 0xc5, 0xbb,
-	0x6c, 0x95, 0x34, 0x77, 0xe2, 0x64, 0x02, 0xed, 0xfc, 0xb2, 0x06, 0x0a, 0xa7, 0x4c, 0xd4, 0x83,
-	0xca, 0x43, 0x4c, 0x91, 0x51, 0xe2, 0x66, 0x6a, 0x55, 0x6b, 0xed, 0x85, 0xed, 0x45, 0xea, 0x7d,
-	0xa8, 0xa6, 0x44, 0x8d, 0xca, 0x7e, 0x31, 0xcd, 0x90, 0xbf, 0xb6, 0xbb, 0x04, 0x42, 0x04, 0x0b,
-	0x40, 0xe1, 0xcb, 0x18, 0x95, 0x81, 0x67, 0x7f, 0x0b, 0x68, 0x9d, 0x65, 0x20, 0x93, 0x80, 0x7c,
-	0x1d, 0x96, 0x06, 0x9c, 0x5d, 0xe5, 0xa5, 0x01, 0xe7, 0x2d, 0xda, 0xa7, 0xa0, 0xf0, 0xed, 0x54,
-	0x1a, 0x70, 0x76, 0x89, 0x69, 0xdb, 0x33, 0x4b, 0xfe, 0x28, 0xfd, 0x05, 0x8e, 0x2e, 0x60, 0x23,
-	0xcf, 0x56, 0xa8, 0xb3, 0x18, 0xdf, 0x15, 0x7c, 0xdf, 0x59, 0x0a, 0x23, 0xaa, 0xb9, 0x80, 0x8d,
-	0x3c, 0x91, 0x94, 0x06, 0x9e, 0x43, 0x7c, 0xa5, 0x81, 0xe7, 0x32, 0xd5, 0xcf, 0x12, 0xdc, 0x98,
-	0x79, 0x6e, 0xe8, 0x93, 0x05, 0x2f, 0xf7, 0x34, 0x35, 0x69, 0x77, 0x97, 0x07, 0xf2, 0x44, 0x0e,
-	0x4e, 0x2f, 0x5f, 0x37, 0x56, 0xfe, 0x7a, 0xdd, 0x58, 0xf9, 0x71, 0xd4, 0x90, 0x2e, 0x47, 0x0d,
-	0xe9, 0x8f, 0x51, 0x43, 0xfa, 0x67, 0xd4, 0x90, 0xbe, 0xf9, 0xec, 0x2d, 0xff, 0xa8, 0xed, 0x73,
-	0xe9, 0x74, 0xe5, 0x4c, 0x61, 0x63, 0xbe, 0xf3, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6e, 0x68,
-	0x0a, 0xa2, 0xf3, 0x0d, 0x00, 0x00,
+	// 1075 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
+	0x10, 0x36, 0x29, 0x59, 0xb6, 0x46, 0x76, 0x93, 0x6c, 0x0c, 0x83, 0x65, 0x5b, 0x59, 0x20, 0x52,
+	0x40, 0x87, 0x86, 0xaa, 0x95, 0x43, 0x53, 0x3b, 0x28, 0x1a, 0x5b, 0x76, 0x6a, 0xc4, 0x09, 0x0a,
+	0xe6, 0xa7, 0x46, 0x2f, 0x01, 0x45, 0xae, 0xd8, 0xad, 0x28, 0x92, 0x25, 0x57, 0x36, 0xd8, 0x53,
+	0x4f, 0xbd, 0xb6, 0x40, 0x4f, 0x7d, 0x86, 0xbe, 0x88, 0x8f, 0x05, 0x7a, 0xe9, 0x29, 0x6d, 0x74,
+	0xe8, 0x73, 0x14, 0xdc, 0x5d, 0x4a, 0xa4, 0x24, 0x98, 0x52, 0xe2, 0xdb, 0xcc, 0x72, 0xbe, 0xf9,
+	0xf9, 0x66, 0x77, 0x46, 0x82, 0x8e, 0x43, 0xe8, 0x77, 0xc3, 0xae, 0x6e, 0xf9, 0x83, 0x96, 0xe5,
+	0x7b, 0xd4, 0x24, 0x1e, 0x0e, 0xed, 0xac, 0x68, 0x06, 0xa4, 0x15, 0xe1, 0xf0, 0x9c, 0x58, 0x38,
+	0x6a, 0x91, 0x81, 0xe9, 0xe0, 0xa8, 0x75, 0xbe, 0x2b, 0x24, 0x3d, 0x08, 0x7d, 0xea, 0xa3, 0x8f,
+	0x26, 0xf6, 0x7a, 0x6a, 0xab, 0x0b, 0x8b, 0xf3, 0x5d, 0x75, 0xcb, 0xf1, 0x1d, 0x9f, 0x59, 0xb6,
+	0x12, 0x89, 0x83, 0xd4, 0x0f, 0x1c, 0xdf, 0x77, 0x5c, 0xdc, 0x62, 0x5a, 0x77, 0xd8, 0x6b, 0xe1,
+	0x41, 0x40, 0x63, 0xf1, 0xb1, 0x31, 0xfd, 0xb1, 0x47, 0xb0, 0x6b, 0xbf, 0x1a, 0x98, 0x51, 0x5f,
+	0x58, 0xec, 0x4c, 0x5b, 0x50, 0x32, 0xc0, 0x11, 0x35, 0x07, 0x81, 0x30, 0xd8, 0x5f, 0xa8, 0x34,
+	0x1a, 0x07, 0x38, 0x6a, 0xd9, 0x38, 0xb2, 0x42, 0x12, 0x50, 0x3f, 0xe4, 0x60, 0xed, 0x3f, 0x19,
+	0x56, 0x4f, 0x92, 0x02, 0x10, 0x82, 0xb2, 0x67, 0x0e, 0xb0, 0x22, 0x35, 0xa4, 0x66, 0xd5, 0x60,
+	0x32, 0xfa, 0x0a, 0x2a, 0xae, 0xd9, 0xc5, 0x6e, 0xa4, 0xc8, 0x8d, 0x52, 0xb3, 0xd6, 0xfe, 0x54,
+	0xbf, 0x92, 0x00, 0x9d, 0x79, 0xd2, 0x4f, 0x19, 0xe4, 0xc8, 0xa3, 0x61, 0x6c, 0x08, 0x3c, 0xda,
+	0x83, 0x0a, 0x35, 0x43, 0x07, 0x53, 0xa5, 0xd4, 0x90, 0x9a, 0xb5, 0xf6, 0x87, 0x59, 0x4f, 0x2c,
+	0x37, 0xbd, 0x33, 0xce, 0xed, 0xa0, 0x7c, 0xf9, 0x7a, 0x67, 0xc5, 0x10, 0x08, 0x74, 0x08, 0x60,
+	0x85, 0xd8, 0xa4, 0xd8, 0x7e, 0x65, 0x52, 0x65, 0x8d, 0xe1, 0x55, 0x9d, 0xd3, 0xa2, 0xa7, 0xb4,
+	0xe8, 0xcf, 0x53, 0x5a, 0x0e, 0xd6, 0x13, 0xf4, 0xaf, 0xff, 0xec, 0x48, 0x46, 0x55, 0xe0, 0x1e,
+	0x32, 0x27, 0xc3, 0xc0, 0x4e, 0x9d, 0xac, 0x2f, 0xe3, 0x44, 0xe0, 0x1e, 0x52, 0xf5, 0x73, 0xa8,
+	0x65, 0x8a, 0x43, 0x37, 0xa1, 0xd4, 0xc7, 0xb1, 0x60, 0x2c, 0x11, 0xd1, 0x16, 0xac, 0x9e, 0x9b,
+	0xee, 0x10, 0x2b, 0x32, 0x3b, 0xe3, 0xca, 0x9e, 0x7c, 0x5f, 0xd2, 0x3e, 0x86, 0x1b, 0x8f, 0x30,
+	0x65, 0x04, 0x19, 0xf8, 0x87, 0x21, 0x8e, 0xe8, 0x3c, 0xc6, 0xb5, 0xa7, 0x70, 0x73, 0x62, 0x16,
+	0x05, 0xbe, 0x17, 0x61, 0xb4, 0x07, 0xab, 0x8c, 0x62, 0x66, 0x58, 0x6b, 0xdf, 0x59, 0xa4, 0x09,
+	0x06, 0x87, 0x68, 0x2f, 0x01, 0x1d, 0x32, 0x0e, 0x72, 0x91, 0xbf, 0x7c, 0x0b, 0x8f, 0xa2, 0x29,
+	0xc2, 0xef, 0x37, 0x70, 0x3b, 0xe7, 0x57, 0xa4, 0xfa, 0xee, 0x8e, 0x7f, 0x93, 0x00, 0xbd, 0x60,
+	0x84, 0x5f, 0x6f, 0xc6, 0x68, 0x1f, 0x6a, 0xbc, 0x91, 0xec, 0x71, 0xb1, 0x06, 0xcd, 0xbb, 0x01,
+	0xc7, 0xc9, 0xfb, 0x7b, 0x62, 0x46, 0x7d, 0x43, 0xdc, 0x97, 0x44, 0x4e, 0xca, 0xcd, 0x25, 0x75,
+	0x6d, 0xe5, 0xde, 0x85, 0x5b, 0xa7, 0x24, 0xe2, 0x0d, 0x8f, 0xd2, 0x62, 0x15, 0x58, 0xeb, 0x11,
+	0x97, 0xe2, 0x30, 0x52, 0xa4, 0x46, 0xa9, 0x59, 0x35, 0x52, 0x55, 0x3b, 0x03, 0x94, 0x35, 0x17,
+	0x69, 0x1c, 0x40, 0x85, 0x07, 0x61, 0xe6, 0xcb, 0xe5, 0x21, 0x90, 0xda, 0x03, 0x40, 0x1d, 0xec,
+	0xe2, 0x29, 0xda, 0xe7, 0x0d, 0x05, 0x04, 0xe5, 0x28, 0xf6, 0x2c, 0xc6, 0xe0, 0xba, 0xc1, 0x64,
+	0xed, 0x05, 0x6c, 0x1e, 0x79, 0x56, 0x18, 0x07, 0xf4, 0xd0, 0xf7, 0x7a, 0xc4, 0x41, 0x75, 0x80,
+	0x10, 0x5b, 0x24, 0x20, 0xd8, 0xa3, 0x69, 0x15, 0x99, 0x13, 0x74, 0x07, 0x36, 0x9d, 0xc0, 0x09,
+	0x86, 0xdd, 0x3e, 0x8e, 0x43, 0xe2, 0x39, 0xcc, 0xdb, 0x86, 0x91, 0x3f, 0xd4, 0x9e, 0xc3, 0x7b,
+	0x1d, 0xcc, 0xdc, 0x3e, 0xc6, 0x71, 0xc7, 0xa4, 0x66, 0x42, 0x4d, 0x9f, 0x8b, 0x2c, 0xa7, 0x0d,
+	0x23, 0x55, 0x51, 0x13, 0x6e, 0x08, 0xf1, 0x6b, 0x33, 0x8a, 0x2e, 0xfc, 0xd0, 0x16, 0x3e, 0xa7,
+	0x8f, 0xb5, 0xbf, 0x24, 0xd8, 0x14, 0x6e, 0x45, 0xb6, 0x2f, 0x61, 0xbd, 0x8f, 0xe3, 0x13, 0xfb,
+	0x89, 0x19, 0x08, 0x0a, 0xf7, 0x0a, 0x28, 0xcc, 0xe1, 0xf5, 0xc7, 0x02, 0xcc, 0x67, 0xde, 0xd8,
+	0x97, 0xfa, 0x3d, 0x6c, 0xe6, 0x3e, 0x65, 0x27, 0x46, 0x99, 0x4f, 0x8c, 0xc3, 0xec, 0xc4, 0xa8,
+	0xb5, 0xef, 0x2e, 0x16, 0x57, 0xd0, 0x91, 0x1d, 0x30, 0xbf, 0x4b, 0x70, 0x5b, 0xf4, 0xa0, 0xb0,
+	0x85, 0x0a, 0xac, 0x79, 0xf8, 0xe2, 0x69, 0x72, 0xcc, 0x07, 0x55, 0xaa, 0xa2, 0x07, 0x20, 0x5b,
+	0x96, 0x98, 0xd1, 0x9f, 0x14, 0xe4, 0x92, 0xeb, 0xb8, 0x21, 0x5b, 0x16, 0xda, 0x4e, 0xf6, 0x45,
+	0x9c, 0xdc, 0xdb, 0x72, 0xa3, 0xd4, 0x5c, 0x35, 0x84, 0xa6, 0x9d, 0xc1, 0x56, 0x3e, 0xb5, 0x6b,
+	0x7b, 0x3f, 0x49, 0xd5, 0x82, 0x93, 0x77, 0xab, 0xda, 0x5e, 0xb4, 0xea, 0x5c, 0xe7, 0x0d, 0xd9,
+	0xbe, 0xb2, 0xea, 0x7c, 0x6a, 0xd7, 0x56, 0xf5, 0x31, 0x28, 0xe9, 0x96, 0x38, 0x4d, 0x62, 0x9d,
+	0x78, 0x3d, 0xff, 0xaa, 0xca, 0x27, 0x19, 0xca, 0xb9, 0x0c, 0xff, 0x90, 0xa0, 0x3a, 0x76, 0x80,
+	0xb6, 0x41, 0x26, 0x36, 0xc3, 0x6d, 0x1e, 0x54, 0x46, 0xaf, 0x77, 0xe4, 0x93, 0x8e, 0x21, 0x13,
+	0x3b, 0x41, 0xb3, 0x1b, 0xcd, 0xd1, 0x65, 0x43, 0x68, 0xc9, 0xb9, 0x4d, 0x1c, 0x1c, 0xf1, 0x9d,
+	0x5e, 0x35, 0x84, 0x96, 0xbc, 0x7d, 0xcc, 0xbb, 0x4d, 0x7c, 0x4f, 0x29, 0xb3, 0x6f, 0x99, 0x13,
+	0xa4, 0xc2, 0x7a, 0x8f, 0xb8, 0xf8, 0x19, 0xf9, 0x11, 0x2b, 0xab, 0x0d, 0xa9, 0x59, 0x32, 0xc6,
+	0x7a, 0xf2, 0x2d, 0x70, 0x4d, 0xda, 0xf3, 0xc3, 0x81, 0x52, 0x61, 0xc8, 0xb1, 0xae, 0x59, 0xf0,
+	0xfe, 0x9c, 0xaa, 0x05, 0xa9, 0xc7, 0x50, 0x75, 0xd3, 0x43, 0xf1, 0x86, 0x9b, 0x05, 0xc4, 0x4e,
+	0x9c, 0x4c, 0xa0, 0xed, 0x5f, 0xd6, 0xa0, 0xc2, 0xc7, 0x2b, 0xea, 0x41, 0xe9, 0x11, 0xa6, 0x48,
+	0x2f, 0x70, 0x33, 0xb5, 0xd6, 0xd5, 0xd6, 0xc2, 0xf6, 0x22, 0xf5, 0x3e, 0x94, 0x93, 0xa1, 0x8e,
+	0x8a, 0x7e, 0x5d, 0xcd, 0x2c, 0x0a, 0x75, 0x77, 0x09, 0x84, 0x08, 0xe6, 0x43, 0x85, 0x2f, 0x6e,
+	0x54, 0x04, 0x9e, 0xfd, 0xdd, 0xa0, 0xb6, 0x97, 0x81, 0x4c, 0x02, 0xf2, 0xd5, 0x59, 0x18, 0x70,
+	0x76, 0xed, 0x17, 0x06, 0x9c, 0xb7, 0x94, 0x9f, 0x41, 0x85, 0x6f, 0xb2, 0xc2, 0x80, 0xb3, 0x0b,
+	0x4f, 0xdd, 0x9e, 0xf9, 0x41, 0x70, 0x94, 0xfc, 0x5a, 0x47, 0x17, 0xb0, 0x91, 0x9d, 0x60, 0xa8,
+	0xbd, 0xd8, 0x6c, 0xcc, 0xf9, 0xbe, 0xb7, 0x14, 0x46, 0x54, 0x73, 0x01, 0x1b, 0xd9, 0x21, 0x52,
+	0x18, 0x78, 0xce, 0x30, 0x2c, 0x0c, 0x3c, 0x77, 0x4a, 0xfd, 0x2c, 0xc1, 0xad, 0x99, 0xe7, 0x86,
+	0x3e, 0x5b, 0xf0, 0x72, 0x4f, 0x8f, 0x25, 0xf5, 0xfe, 0xf2, 0x40, 0x9e, 0xc8, 0xc1, 0xd9, 0xe5,
+	0x9b, 0xfa, 0xca, 0xdf, 0x6f, 0xea, 0x2b, 0x3f, 0x8d, 0xea, 0xd2, 0xe5, 0xa8, 0x2e, 0xfd, 0x39,
+	0xaa, 0x4b, 0xff, 0x8e, 0xea, 0xd2, 0xb7, 0x5f, 0xbc, 0xe5, 0x9f, 0xba, 0x7d, 0x2e, 0x9d, 0xad,
+	0x74, 0x2b, 0xac, 0xcd, 0xf7, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x33, 0x0f, 0xcb, 0x18, 0x1f,
+	0x0e, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index d795bc3..46de40d 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -150,6 +150,7 @@ message EncryptImageRequest {
 	string newName = 2;
 
 	EncryptConfig cc = 3;
+	repeated int32 layers = 4;
 }
 
 message EncryptImageResponse {
@@ -161,6 +162,7 @@ message DecryptImageRequest {
 	string newName = 2;
 
 	DecryptConfig dc = 3;
+	repeated int32 layers = 4;
 }
 
 message DecryptImageResponse {
@@ -169,7 +171,7 @@ message DecryptImageResponse {
 
 message GetImageLayerInfoRequest {
 	string name = 1;
-	string platform = 2;
+	repeated int32 layers = 2;
 }
 
 message LayerInfo {
diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 0e53840..d623a38 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -22,8 +22,8 @@ import (
 	"fmt"
 	"syscall"
 
-	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/containerd/containerd/images"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
 
@@ -38,15 +38,16 @@ var decryptCommand = cli.Command{
 
 	XYZ
 `,
-	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
-		Name:  "foo",
-		Usage: "foo",
+	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
+		Name:  "layer",
+		Usage: "The layer to decrypt; this must be either the layer number or a negative number starting with -1 for topmost layer",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
 			local = context.Args().First()
 			newName = context.Args().Get(1)
 		)
+		fmt.Printf("pl: %s\n", context.StringSlice("platform"))
 		if local == "" {
 			return errors.New("please provide the name of an image to decrypt")
 		}
@@ -61,7 +62,7 @@ var decryptCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local)
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"))
 		if err != nil {
 			return err
 		}
@@ -118,13 +119,12 @@ var decryptCommand = cli.Command{
 			}
 		}
 		fmt.Printf("\n")
-		client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
+		_, err = client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
 			Dc: &images.DecryptConfig {
 				KeyIdMap: keyIdMap,
 			},
-		})
-
-		return nil
+		}, context.IntSlice("layer"))
+		return err
 	},
 }
 
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index e133d6e..878b862 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -36,6 +36,9 @@ var encryptCommand = cli.Command{
 	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
 		Name:  "recipient",
 		Usage: "Recipient of the image is the person who can decrypt it",
+		}, cli.IntSliceFlag{
+		Name:  "layer",
+		Usage: "The layer to encrypt; this must be either the layer number or a negative number starting with -1 for topmost layer",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -71,7 +74,7 @@ var encryptCommand = cli.Command{
 				Recipients:     recipients,
 			},
 		}
-		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc)
+		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, context.IntSlice("layer"))
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 7e5206c..8616f68 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -35,7 +35,10 @@ var layerinfoCommand = cli.Command{
 
 	XYZ
 `,
-	Flags: commands.RegistryFlags,
+	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
+		Name:  "layer",
+		Usage: "The layer to get info for; this must be either the layer number or a negative number starting with -1 for topmost layer",
+	}),
 	Action: func(context *cli.Context) error {
 		var (
 			local = context.Args().First()
@@ -49,7 +52,7 @@ var layerinfoCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local)
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"))
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index 6f142f4..7334d8a 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -105,7 +105,7 @@ var pushCommand = cli.Command{
 					Recipients:     recipients,
 				},
 			}
-			img, err := client.ImageService().EncryptImage(ctx, local, local, cc)
+			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int{})
 			if err != nil {
 				return err
 			}
diff --git a/image_store.go b/image_store.go
index 4d66877..f7bc0b0 100644
--- a/image_store.go
+++ b/image_store.go
@@ -50,8 +50,9 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
 	fmt.Printf("image_store.go: EncryptImage() name=%s\n", name);
+
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
@@ -59,6 +60,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 			Recipients   : cc.Ec.Recipients,
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 		},
+		Layers: layersToLayers32(layers),
 	});
 	if err != nil {
 		return images.Image{}, errdefs.FromGRPC(err)
@@ -67,7 +69,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
 	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
 	for k, v := range cc.Dc.KeyIdMap {
 		keyIdMap[k] = &imagesapi.DecryptKeyData{
@@ -75,12 +77,14 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, c
 			KeyDataPassword: v.KeyDataPassword,
 		}
 	}
+
 	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
 		Name:    name,
 		NewName: newName,
 		Dc:      &imagesapi.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
+		Layers: layersToLayers32(layers),
 	});
 	if err != nil {
 		return images.Image{}, errdefs.FromGRPC(err)
@@ -89,9 +93,19 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string) ([]images.LayerInfo, error) {
+func layersToLayers32(layers []int) []int32 {
+	var layers32 [] int32
+
+	for _, layer := range layers {
+		layers32 = append(layers32, int32(layer))
+	}
+	return layers32
+}
+
+func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]images.LayerInfo, error) {
 	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
 		Name:    name,
+		Layers:  layersToLayers32(layers),
 	});
 	if err != nil {
 		return []images.LayerInfo{}, errdefs.FromGRPC(err)
diff --git a/images/image.go b/images/image.go
index c734e76..b8bd605 100644
--- a/images/image.go
+++ b/images/image.go
@@ -103,9 +103,9 @@ type Store interface {
 
 	Delete(ctx context.Context, name string, opts ...DeleteOpt) error
 
-	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
-	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig) (Image, error)
-	GetImageLayerInfo(ctx context.Context, name string) ([]LayerInfo, error)
+	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int) (Image, error)
+	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int) (Image, error)
+	GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]LayerInfo, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -391,13 +391,58 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	return newDesc, nil
 }
 
+// isDecriptorALayer determines whether the given Descriptor describes a layer
+func isDescriptorALayer(desc ocispec.Descriptor) bool {
+	switch desc.MediaType {
+	case MediaTypeDockerSchema2LayerGzip,MediaTypeDockerSchema2Layer,
+		MediaTypeDockerSchema2LayerGzipPGP,MediaTypeDockerSchema2LayerPGP:
+		return true
+	}
+	return false
+}
+
+// countLayers counts the number of layer OCI descriptors in the given array
+func countLayers(desc []ocispec.Descriptor) int {
+	c := 0
+
+	for _, d := range desc {
+		if isDescriptorALayer(d) {
+			c = c + 1
+		}
+	}
+	return c
+}
+
+// needModifyLayer checks whether we need to modify this layer given its number
+// A layer can be described with its (positive) index number or its negative number, which
+// is counted relative to the last one
+func isUserSelectedLayer(layerNum, layersTotal int, layers []int) bool {
+	if len(layers) == 0 {
+		// convenience for the user; none given means 'all'
+		return true
+	}
+	negNumber := layerNum - layersTotal
+	fmt.Printf("%d vs %d\n", layerNum, negNumber)
+
+	for _, l := range layers {
+		if l == negNumber || l == layerNum {
+			return true
+		}
+	}
+	return false;
+}
+
 // Encrypt all the Children of a given descriptor
-func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, bool, error) {
-	//fmt.Printf("metadata/image.go EncryptChildren(): Getting Children of %s [%s]\n", desc.MediaType, desc.Digest)
+func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, layers []int, encrypt bool) (ocispec.Descriptor, bool, error) {
+	layerNum := 0
+
 	children, err := Children(ctx, cs, desc)
 	if err != nil {
 		return ocispec.Descriptor{}, false, err
 	}
+
+	layersTotal := countLayers(children)
+
 	//fmt.Printf("metadata/image.go EncryptChildren(): got %d children\n", len(children))
 	var newLayers []ocispec.Descriptor
 	var config ocispec.Descriptor
@@ -405,14 +450,12 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 
 	for _, child := range children {
 		// we only encrypt child layers and have to update their parents if encyrption happened
-		//fmt.Printf("   child : %s\n", child.MediaType)
 		switch child.MediaType {
 		case MediaTypeDockerSchema2Config:
 			config = child
 		case MediaTypeDockerSchema2LayerGzip,MediaTypeDockerSchema2Layer:
 			// this one we can only encrypt
-			if encrypt {
-				//fmt.Printf("   ... a layer to encrypt\n")
+			if encrypt && isUserSelectedLayer(layerNum, layersTotal, layers) {
 				nl, err := cryptLayer(ctx, cs, child, cc, true)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -422,9 +465,10 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			} else {
 				newLayers = append(newLayers, child)
 			}
+			layerNum = layerNum + 1
 		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
 			// this one we can only decrypt
-			if !encrypt {
+			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, layers){
 				nl, err := cryptLayer(ctx, cs, child, cc, false)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -434,6 +478,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			} else {
 				newLayers = append(newLayers, child)
 			}
+			layerNum = layerNum + 1
 		default:
 			return ocispec.Descriptor{}, false, errors.Wrapf(err, "Bad/unhandled MediaType %s in encryptChildren\n", child.MediaType)
 		}
@@ -479,7 +524,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 }
 
 // cryptManifestList encrypts or decrypts the children of a top level manifest list
-func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, bool, error) {
+func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, layers []int, encrypt bool) (ocispec.Descriptor, bool, error) {
 	if desc.MediaType != MediaTypeDockerSchema2ManifestList {
 		return ocispec.Descriptor{}, false, errors.Wrapf(nil, "Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
 	}
@@ -497,7 +542,7 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
-		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, encrypt)
+		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, layers, encrypt)
 		if err != nil {
 			return ocispec.Descriptor{}, false, err
 		}
@@ -543,9 +588,10 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
-func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor) ([]LayerInfo, error) {
+func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, layers []int, layerNum int) ([]LayerInfo, error) {
 	var (
 		lis []LayerInfo
+		tmp []LayerInfo
 		Platform string
 	)
 
@@ -559,13 +605,26 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		if err != nil {
 			return []LayerInfo{}, err
 		}
+
+		layersTotal := countLayers(children)
+		layerNum := -1
+
 		for _, child := range children {
-			tmp, err := GetImageLayerInfo(ctx, cs, child)
+			if isDescriptorALayer(child) {
+				layerNum = layerNum + 1
+				if isUserSelectedLayer(layerNum, layersTotal, layers) {
+					tmp, err = GetImageLayerInfo(ctx, cs, child, layers, layerNum)
+				} else {
+					continue
+				}
+			} else {
+				tmp, err = GetImageLayerInfo(ctx, cs, child, layers, -1)
+			}
 			if err != nil {
 				return []LayerInfo{}, err
 			}
+
 			for i := 0; i < len(tmp); i++ {
-				tmp[i].Id = uint32(i)
 				if Platform != "" {
 					tmp[i].Platform = Platform
 				}
@@ -578,6 +637,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Digest:       desc.Digest.String(),
 			Encryption:   "",
 			FileSize:     desc.Size,
+			Id:           uint32(layerNum),
 		}
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
@@ -595,6 +655,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Digest:       desc.Digest.String(),
 			Encryption:   "gpg",
 			FileSize:     desc.Size,
+			Id:           uint32(layerNum),
 		}
 		lis = append(lis, li)
 	default:
diff --git a/metadata/images.go b/metadata/images.go
index d89b95e..418f956 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -79,8 +79,7 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 
 // cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
 // or updates the existing one
-func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, encrypt bool) (images.Image, error) {
-	fmt.Printf("metadata/images.go: cryptImage() name=%s\n", name)
+func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, encrypt bool) (images.Image, error) {
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -113,7 +112,7 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	fmt.Printf("metadata/images.go: cs = %v\n",cs)
 	fmt.Printf("  high level image.Target is of MediaType %s\n", image.Target.MediaType)
 
-	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, encrypt)
+	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, layers, encrypt)
 	if err != nil {
 		return image, err
 	}
@@ -189,15 +188,15 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	return image, nil
 }
 
-func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, true)
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, true)
 }
 
-func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, false)
+func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, false)
 }
 
-func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string) ([]images.LayerInfo, error) {
+func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]images.LayerInfo, error) {
 	fmt.Printf("metadata/images.go: GetImageLayerInfo() name=%s\n", name)
 	var image images.Image
 
@@ -228,7 +227,7 @@ func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string) ([]imag
 	}
 
 	cs := s.db.ContentStore()
-	return images.GetImageLayerInfo(ctx, cs, image.Target)
+	return images.GetImageLayerInfo(ctx, cs, image.Target, layers, -1)
 }
 
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
diff --git a/services/images/local.go b/services/images/local.go
index 063ea21..2006019 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -184,14 +184,14 @@ func (l *local) Delete(ctx context.Context, req *imagesapi.DeleteImageRequest, _
 func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageRequest, _ ...grpc.CallOption) (*imagesapi.EncryptImageResponse, error) {
 	log.G(ctx).WithField("name", req.Name).Debugf("encrypt image")
 
-	var resp       imagesapi.EncryptImageResponse
+	var resp   imagesapi.EncryptImageResponse
 
 	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
 		Ec:	&images.EncryptConfig{
 			Recipients    : req.Cc.Recipients,
 			GPGPubRingFile: req.Cc.Gpgpubkeyring,
 		},
-	})
+	}, layers32ToLayers(req.Layers))
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -210,7 +210,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest, _ ...grpc.CallOption) (*imagesapi.DecryptImageResponse, error) {
 	log.G(ctx).WithField("name", req.Name).Debugf("decrypt image")
 
-	var resp       imagesapi.DecryptImageResponse
+	var resp   imagesapi.DecryptImageResponse
 
 	keyIdMap := make(map[uint64]images.DecryptKeyData)
 
@@ -225,7 +225,7 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 		Dc:	&images.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
-	})
+	}, layers32ToLayers(req.Layers))
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -246,7 +246,7 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 
 	var resp imagesapi.GetImageLayerInfoResponse
 
-	lis, err := l.store.GetImageLayerInfo(ctx, req.Name)
+	lis, err := l.store.GetImageLayerInfo(ctx, req.Name, layers32ToLayers(req.Layers))
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -266,4 +266,11 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	return &resp, nil
 }
 
+func layers32ToLayers(layers []int32) []int {
+	var l []int
 
+	for _, layer := range layers{
+		l = append(l, int(layer))
+	}
+	return l;
+}
-- 
2.7.4


From bedadb4ae84a63e95ff52001fba2b7bcf4670f8f Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 15:29:41 -0400
Subject: [PATCH 23/79] Fix error report if no key was found for decrypting an
 unencrypted layer

---
 cmd/ctr/commands/images/decrypt.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index d623a38..e28b9fb 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -114,8 +114,8 @@ var decryptCommand = cli.Command{
 				found = true
 				break
 			}
-			if !found {
-				return fmt.Errorf("Missing key for decryption of layer %d.\n", LayerInfo.Id)
+			if !found && len(LayerInfo.KeyIds) > 0 {
+				return fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %s\n", LayerInfo.Id, LayerInfo.Platform, LayerInfo.KeyIds)
 			}
 		}
 		fmt.Printf("\n")
-- 
2.7.4


From 37f1ac0dd5ee4bd8821c5f0b9717e5024316ae35 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 16:34:10 -0400
Subject: [PATCH 24/79] Ignore 'error' returned from function testing for
 whether key is on system

---
 cmd/ctr/commands/images/decrypt.go | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index e28b9fb..fae93f1 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -90,10 +90,8 @@ var decryptCommand = cli.Command{
 					break
 				}
 				// do we have this key
-				haveKey, err := HaveGPGPrivateKey(keyid)
-				if err != nil {
-					return err
-				}
+				haveKey, _ := HaveGPGPrivateKey(keyid)
+				// this may fail if the key is not here; we ignore the error
 				if !haveKey {
 					// key not on this system
 					continue
@@ -101,6 +99,7 @@ var decryptCommand = cli.Command{
 				fmt.Printf("Enter password for key with Id 0x%x: ", keyid)
 				password, err := terminal.ReadPassword(int(syscall.Stdin))
 				if err != nil {
+					fmt.Printf("B!\n");
 					return err
 				}
 				keydata, err := GetGPGPrivateKey(keyid, string(password))
-- 
2.7.4


From 70a3880d266ac651319155594ed9469cc1eabe6f Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 16:52:25 -0400
Subject: [PATCH 25/79] Return error message if something goes wrong while
 executing gpg2 tool

---
 cmd/ctr/commands/images/decrypt.go | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index fae93f1..7d36e5d 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -98,8 +98,8 @@ var decryptCommand = cli.Command{
 				}
 				fmt.Printf("Enter password for key with Id 0x%x: ", keyid)
 				password, err := terminal.ReadPassword(int(syscall.Stdin))
+				fmt.Printf("\n")
 				if err != nil {
-					fmt.Printf("B!\n");
 					return err
 				}
 				keydata, err := GetGPGPrivateKey(keyid, string(password))
@@ -148,6 +148,7 @@ func GetGPGPrivateKey (keyid uint64, password string) ([]byte, error) {
 	cmd := exec.Command("gpg2", args...)
 
 	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
 	if err != nil {
 		return nil, err
 	}
@@ -156,9 +157,10 @@ func GetGPGPrivateKey (keyid uint64, password string) ([]byte, error) {
 	}
 
 	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
 
 	if err := cmd.Wait(); err != nil {
-		return nil, err
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
 
 	return keydata, err2
-- 
2.7.4


From df8518fc083532142cb3403a374d423e8129cf30 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 24 Jul 2018 16:59:35 -0400
Subject: [PATCH 26/79] Make the variant also part of the platform

---
 images/image.go | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/images/image.go b/images/image.go
index b8bd605..b6917bd 100644
--- a/images/image.go
+++ b/images/image.go
@@ -600,7 +600,10 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
 		if desc.Platform != nil {
-			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture
+			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture;
+			if desc.Platform.Variant != "" {
+				Platform = Platform + "/" + desc.Platform.Variant
+			}
 		}
 		if err != nil {
 			return []LayerInfo{}, err
-- 
2.7.4


From 24577eb38ffb498b7fcb99204fe8f940623343f6 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 25 Jul 2018 10:14:03 -0400
Subject: [PATCH 27/79] Fix case where no change was done on a Descriptor; this
 allows decryption of individual layers

---
 images/image.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/images/image.go b/images/image.go
index b6917bd..e125baa 100644
--- a/images/image.go
+++ b/images/image.go
@@ -520,7 +520,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		return nDesc, true, nil
 	}
 
-	return ocispec.Descriptor{}, modified, nil
+	return desc, modified, nil
 }
 
 // cryptManifestList encrypts or decrypts the children of a top level manifest list
-- 
2.7.4


From 9f46265e31a9913ffb54327362494e7a29f72ac3 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Wed, 25 Jul 2018 11:37:09 -0400
Subject: [PATCH 28/79] Changed to new format with key annotations

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/encryption.go | 42 +++++++++++++---------------
 images/image.go      | 79 ++++++++++++++++++++++++++++++++++++++++++++++------
 images/openpgp.go    |  9 ++++--
 3 files changed, 98 insertions(+), 32 deletions(-)

diff --git a/images/encryption.go b/images/encryption.go
index 60ab534..81d0777 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -127,38 +127,27 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 }
 
 // Encrypt encrypts a byte array using data from the CryptoConfig
-func Encrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
+func Encrypt(cc *CryptoConfig, data []byte) ([]byte, [][]byte, error) {
 	filteredList, err := createEntityList(cc)
 	if err != nil {
-		return nil, err
+		return nil, nil, err
 	}
 	if len(filteredList) == 0 {
-		return nil, fmt.Errorf("No keys were found to encrypt message to.\n")
-	}
-
-	buf := new(bytes.Buffer)
-
-	w, err := openpgp.Encrypt(buf, filteredList, nil, nil, nil)
-	if err != nil {
-		return nil, err
+		return nil, nil, fmt.Errorf("No keys were found to encrypt message to.\n")
 	}
 
-	_, err = w.Write(data)
+	encBlob, wrappedKeys, err := encryptData(data, filteredList, nil)
 	if err != nil {
-		return nil, err
-	}
-	err = w.Close();
-	if err != nil {
-		return nil, err
+		return nil, nil, err
 	}
 
-	return ioutil.ReadAll(buf)
+	return encBlob, wrappedKeys, nil
 }
 
 // Decrypt decrypts a byte array using data from the CryptoConfig
 func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 	dc := cc.Dc
-	keyIds, err := GetKeyIds(data, ocispec.Descriptor{})
+	keyIds, err := GetKeyIds(ocispec.Descriptor{})
 	if err != nil {
 		return []byte{}, err
 	}
@@ -186,17 +175,26 @@ func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
 }
 
 // GetKeyIds gets the Key IDs for which the data are encrypted
-func GetKeyIds(encData []byte, desc ocispec.Descriptor) ([]uint64, error) {
+func GetKeyIds(desc ocispec.Descriptor) ([]uint64, error) {
 	var keyids []uint64
 
-	r := bytes.NewReader(encData)
+    keys, err := getWrappedKeys(desc)
+    if err != nil {
+        return nil, err
+    }
+
+    kbytes := make([]byte, 0)
+    for _, k := range keys {
+        kbytes = append(kbytes, k...)
+    }
+    kbuf := bytes.NewBuffer(kbytes)
 
-	packets := packet.NewReader(r)
+	packets := packet.NewReader(kbuf)
 ParsePackets:
 	for {
 		p, err := packets.Next()
 		if err != nil {
-			return []uint64{}, fmt.Errorf("yeek: %v\n", err)
+			break ParsePackets
 		}
 		switch p := p.(type) {
 		case *packet.EncryptedKey:
diff --git a/images/image.go b/images/image.go
index e125baa..349b0a0 100644
--- a/images/image.go
+++ b/images/image.go
@@ -20,6 +20,7 @@ import (
 	"bytes"
 	"context"
 	"encoding/json"
+	"encoding/base64"
 	"fmt"
 	"sort"
 	"strings"
@@ -350,10 +351,17 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	// now we should encrypt
 
 	var p []byte
+    var keys [][]byte
 	if encrypt {
-		p, err = Encrypt(cc, data)
+		p, keys, err = Encrypt(cc, data)
 	} else {
-		p, err = Decrypt(cc, data)
+		keys, err = getWrappedKeys(desc)
+        if err != nil {
+            return ocispec.Descriptor{}, err
+        }
+
+	    inData := assemblyEncryptedMessage (data, keys)
+		p, err = Decrypt(cc, inData)
 	}
 	if err != nil {
 		return ocispec.Descriptor{}, err
@@ -369,7 +377,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	}
 	if encrypt {
 		newDesc.Annotations = make(map[string]string)
-		newDesc.Annotations["org.opencontainers.image.pgp.keys"] = "foo-bar"
+        newDesc.Annotations["org.opencontainers.image.pgp.keys"] = encodeWrappedKeys(keys)
 	}
 
 	switch (desc.MediaType) {
@@ -390,6 +398,64 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 
 	return newDesc, nil
 }
+func getWrappedKeys (desc ocispec.Descriptor) ([][]byte, error) {
+    // Parse and decode keys
+    if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
+        keys, err := decodeWrappedKeys(v)
+        if err != nil {
+            return nil, err
+        }
+        return keys, nil
+    } else {
+        return make([][]byte,0), nil
+    }
+}
+
+// assemblyEncryptedMessage takes in the openpgp encrypted body packets and 
+// assembles the openpgp message
+func assemblyEncryptedMessage (encBody []byte, keys [][]byte) []byte {
+	encMsg := make([]byte, 0)
+
+	for _, k := range keys {
+		encMsg = append(encMsg, k...)
+	}
+	encMsg = append(encMsg, encBody...)
+
+	return encMsg
+}
+
+
+// encodeWrappedKeys encodes wrapped openpgp keys to a string readable ','
+// separated base64 strings.
+func encodeWrappedKeys (keys [][]byte) string {
+    keyString := ""
+    for _, k := range keys {
+        if keyString == "" {
+            keyString += base64.StdEncoding.EncodeToString(k)
+        } else {
+            keyString += "," + base64.StdEncoding.EncodeToString(k)
+        }
+    }
+
+    return keyString
+}
+
+// decodeWrappedKeys decodes wrapped openpgp keys from string readable ','
+// separated base64 strings to their byte values
+func decodeWrappedKeys (keys string) ([][]byte, error){
+	kSplit := strings.Split(keys, ",")
+	keyBytes := make([][]byte, 0, len(kSplit))
+
+    for _, v := range kSplit {
+		data, err := base64.StdEncoding.DecodeString(v)
+		if err != nil {
+			return nil, err
+		}
+		keyBytes = append(keyBytes, data)
+    }
+
+    return keyBytes, nil
+}
 
 // isDecriptorALayer determines whether the given Descriptor describes a layer
 func isDescriptorALayer(desc ocispec.Descriptor) bool {
@@ -645,11 +711,8 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
-		encData, err := content.ReadBlob(ctx, cs, desc);
-		if err != nil {
-			return []LayerInfo{}, err
-		}
-		kids, err := GetKeyIds(encData, desc)
+        
+		kids, err := GetKeyIds(desc)
 		if err != nil {
 			return []LayerInfo{}, err
 		}
diff --git a/images/openpgp.go b/images/openpgp.go
index 7ee5232..34150fb 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -137,8 +137,13 @@ func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (enc
 		return nil, fmt.Errorf("Error serializing Lietral packet: %v", err)
 	}
 
-	content.Write(data)
-	content.Close()
+    if _, err := content.Write(data); err != nil {
+        return nil, err
+    }
+
+    if err := content.Close(); err != nil {
+        return nil, err
+    }
 
 	encBlob = encData.Bytes()
 	log.Printf("Encrypted data bytes: %x", encBlob)
-- 
2.7.4


From 7a393877c413ffa8ea73a9c8158ff2afa9288a5c Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Wed, 25 Jul 2018 11:59:59 -0400
Subject: [PATCH 29/79] Fixed decrypt getKeyId

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/encryption.go | 13 ++++++++++---
 images/image.go      | 13 +++----------
 2 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/images/encryption.go b/images/encryption.go
index 81d0777..90fa2cc 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -145,12 +145,19 @@ func Encrypt(cc *CryptoConfig, data []byte) ([]byte, [][]byte, error) {
 }
 
 // Decrypt decrypts a byte array using data from the CryptoConfig
-func Decrypt(cc *CryptoConfig, data []byte) ([]byte, error) {
+func Decrypt(cc *CryptoConfig, encBody []byte, desc ocispec.Descriptor) ([]byte, error) {
 	dc := cc.Dc
-	keyIds, err := GetKeyIds(ocispec.Descriptor{})
+	keyIds, err := GetKeyIds(desc)
 	if err != nil {
-		return []byte{}, err
+		return nil, err
 	}
+
+    keys, err :=  getWrappedKeys (desc)
+    if err != nil {
+        return nil, err
+    }
+
+    data := assembleEncryptedMessage (encBody, keys)
 	// decrypt with the right key
 	for _, keyId := range keyIds {
 		if keydata, ok := dc.KeyIdMap[keyId]; ok {
diff --git a/images/image.go b/images/image.go
index 349b0a0..317c187 100644
--- a/images/image.go
+++ b/images/image.go
@@ -355,13 +355,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	if encrypt {
 		p, keys, err = Encrypt(cc, data)
 	} else {
-		keys, err = getWrappedKeys(desc)
-        if err != nil {
-            return ocispec.Descriptor{}, err
-        }
-
-	    inData := assemblyEncryptedMessage (data, keys)
-		p, err = Decrypt(cc, inData)
+		p, err = Decrypt(cc, data, desc)
 	}
 	if err != nil {
 		return ocispec.Descriptor{}, err
@@ -411,9 +405,9 @@ func getWrappedKeys (desc ocispec.Descriptor) ([][]byte, error) {
     }
 }
 
-// assemblyEncryptedMessage takes in the openpgp encrypted body packets and 
+// assembleEncryptedMessage takes in the openpgp encrypted body packets and 
 // assembles the openpgp message
-func assemblyEncryptedMessage (encBody []byte, keys [][]byte) []byte {
+func assembleEncryptedMessage (encBody []byte, keys [][]byte) []byte {
 	encMsg := make([]byte, 0)
 
 	for _, k := range keys {
@@ -711,7 +705,6 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
-        
 		kids, err := GetKeyIds(desc)
 		if err != nil {
 			return []LayerInfo{}, err
-- 
2.7.4


From e3efcc65ae376af3e81aeca5ccc1f3e8345c73ba Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Wed, 25 Jul 2018 12:00:15 -0400
Subject: [PATCH 30/79] Gofmt

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/encryption.go |  47 ++++++++++----------
 images/image.go      | 121 +++++++++++++++++++++++++--------------------------
 images/openpgp.go    |  12 ++---
 3 files changed, 89 insertions(+), 91 deletions(-)

diff --git a/images/encryption.go b/images/encryption.go
index 90fa2cc..056a26c 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -15,32 +15,32 @@
 */
 
 package images
+
 import (
 	"bytes"
 	"fmt"
-        "io/ioutil"
+	"io/ioutil"
 	"net/mail"
 	"strings"
 
-	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/mitchellh/go-homedir"
+	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"golang.org/x/crypto/openpgp"
 	"golang.org/x/crypto/openpgp/packet"
-
 )
 
 // EncryptConfig is the container image PGP encryption configuration holding
 // the identifiers of those that will be able to decrypt the container and
 // the PGP public keyring file data that contains their public keys.
 type EncryptConfig struct {
-       Recipients     []string
-       GPGPubRingFile []byte
+	Recipients     []string
+	GPGPubRingFile []byte
 }
 
 // DecryptKeyData stores private key data for decryption and the necessary password
 // for being able to access/decrypt the private key data
 type DecryptKeyData struct {
-	KeyData []byte
+	KeyData         []byte
 	KeyDataPassword []byte
 }
 
@@ -89,7 +89,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 	var filteredList openpgp.EntityList
 	for _, entity := range entityList {
 		for k, _ := range entity.Identities {
-			fmt.Printf("k = %s\n",k)
+			fmt.Printf("k = %s\n", k)
 			addr, err := mail.ParseAddress(k)
 			if err != nil {
 				return nil, err
@@ -106,7 +106,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 
 	// make sure we found keys for all the Recipients...
 	var buffer bytes.Buffer
-	notFound := false;
+	notFound := false
 	buffer.WriteString("No key found for the following recipients: ")
 
 	for k, v := range rSet {
@@ -115,7 +115,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 				buffer.WriteString(", ")
 			}
 			buffer.WriteString(k)
-			notFound = true;
+			notFound = true
 		}
 	}
 
@@ -152,12 +152,12 @@ func Decrypt(cc *CryptoConfig, encBody []byte, desc ocispec.Descriptor) ([]byte,
 		return nil, err
 	}
 
-    keys, err :=  getWrappedKeys (desc)
-    if err != nil {
-        return nil, err
-    }
+	keys, err := getWrappedKeys(desc)
+	if err != nil {
+		return nil, err
+	}
 
-    data := assembleEncryptedMessage (encBody, keys)
+	data := assembleEncryptedMessage(encBody, keys)
 	// decrypt with the right key
 	for _, keyId := range keyIds {
 		if keydata, ok := dc.KeyIdMap[keyId]; ok {
@@ -185,16 +185,16 @@ func Decrypt(cc *CryptoConfig, encBody []byte, desc ocispec.Descriptor) ([]byte,
 func GetKeyIds(desc ocispec.Descriptor) ([]uint64, error) {
 	var keyids []uint64
 
-    keys, err := getWrappedKeys(desc)
-    if err != nil {
-        return nil, err
-    }
+	keys, err := getWrappedKeys(desc)
+	if err != nil {
+		return nil, err
+	}
 
-    kbytes := make([]byte, 0)
-    for _, k := range keys {
-        kbytes = append(kbytes, k...)
-    }
-    kbuf := bytes.NewBuffer(kbytes)
+	kbytes := make([]byte, 0)
+	for _, k := range keys {
+		kbytes = append(kbytes, k...)
+	}
+	kbuf := bytes.NewBuffer(kbytes)
 
 	packets := packet.NewReader(kbuf)
 ParsePackets:
@@ -212,4 +212,3 @@ ParsePackets:
 	}
 	return keyids, nil
 }
-
diff --git a/images/image.go b/images/image.go
index 317c187..ea9b367 100644
--- a/images/image.go
+++ b/images/image.go
@@ -19,8 +19,8 @@ package images
 import (
 	"bytes"
 	"context"
-	"encoding/json"
 	"encoding/base64"
+	"encoding/json"
 	"fmt"
 	"sort"
 	"strings"
@@ -343,7 +343,7 @@ func Check(ctx context.Context, provider content.Provider, image ocispec.Descrip
 
 // encryptLayer encryts a single layer and writes the encrypted layer back into storage
 func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
-	data, err := content.ReadBlob(ctx, cs, desc);
+	data, err := content.ReadBlob(ctx, cs, desc)
 	if err != nil {
 		return ocispec.Descriptor{}, err
 	}
@@ -351,7 +351,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	// now we should encrypt
 
 	var p []byte
-    var keys [][]byte
+	var keys [][]byte
 	if encrypt {
 		p, keys, err = Encrypt(cc, data)
 	} else {
@@ -371,10 +371,10 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	}
 	if encrypt {
 		newDesc.Annotations = make(map[string]string)
-        newDesc.Annotations["org.opencontainers.image.pgp.keys"] = encodeWrappedKeys(keys)
+		newDesc.Annotations["org.opencontainers.image.pgp.keys"] = encodeWrappedKeys(keys)
 	}
 
-	switch (desc.MediaType) {
+	switch desc.MediaType {
 	case MediaTypeDockerSchema2LayerGzip:
 		newDesc.MediaType = MediaTypeDockerSchema2LayerGzipPGP
 	case MediaTypeDockerSchema2Layer:
@@ -388,26 +388,26 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	}
 
 	ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
-	content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc);
+	content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc)
 
 	return newDesc, nil
 }
-func getWrappedKeys (desc ocispec.Descriptor) ([][]byte, error) {
-    // Parse and decode keys
-    if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
-        keys, err := decodeWrappedKeys(v)
-        if err != nil {
-            return nil, err
-        }
-        return keys, nil
-    } else {
-        return make([][]byte,0), nil
-    }
+func getWrappedKeys(desc ocispec.Descriptor) ([][]byte, error) {
+	// Parse and decode keys
+	if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
+		keys, err := decodeWrappedKeys(v)
+		if err != nil {
+			return nil, err
+		}
+		return keys, nil
+	} else {
+		return make([][]byte, 0), nil
+	}
 }
 
-// assembleEncryptedMessage takes in the openpgp encrypted body packets and 
+// assembleEncryptedMessage takes in the openpgp encrypted body packets and
 // assembles the openpgp message
-func assembleEncryptedMessage (encBody []byte, keys [][]byte) []byte {
+func assembleEncryptedMessage(encBody []byte, keys [][]byte) []byte {
 	encMsg := make([]byte, 0)
 
 	for _, k := range keys {
@@ -418,44 +418,43 @@ func assembleEncryptedMessage (encBody []byte, keys [][]byte) []byte {
 	return encMsg
 }
 
-
 // encodeWrappedKeys encodes wrapped openpgp keys to a string readable ','
 // separated base64 strings.
-func encodeWrappedKeys (keys [][]byte) string {
-    keyString := ""
-    for _, k := range keys {
-        if keyString == "" {
-            keyString += base64.StdEncoding.EncodeToString(k)
-        } else {
-            keyString += "," + base64.StdEncoding.EncodeToString(k)
-        }
-    }
-
-    return keyString
+func encodeWrappedKeys(keys [][]byte) string {
+	keyString := ""
+	for _, k := range keys {
+		if keyString == "" {
+			keyString += base64.StdEncoding.EncodeToString(k)
+		} else {
+			keyString += "," + base64.StdEncoding.EncodeToString(k)
+		}
+	}
+
+	return keyString
 }
 
 // decodeWrappedKeys decodes wrapped openpgp keys from string readable ','
 // separated base64 strings to their byte values
-func decodeWrappedKeys (keys string) ([][]byte, error){
+func decodeWrappedKeys(keys string) ([][]byte, error) {
 	kSplit := strings.Split(keys, ",")
 	keyBytes := make([][]byte, 0, len(kSplit))
 
-    for _, v := range kSplit {
+	for _, v := range kSplit {
 		data, err := base64.StdEncoding.DecodeString(v)
 		if err != nil {
 			return nil, err
 		}
 		keyBytes = append(keyBytes, data)
-    }
+	}
 
-    return keyBytes, nil
+	return keyBytes, nil
 }
 
 // isDecriptorALayer determines whether the given Descriptor describes a layer
 func isDescriptorALayer(desc ocispec.Descriptor) bool {
 	switch desc.MediaType {
-	case MediaTypeDockerSchema2LayerGzip,MediaTypeDockerSchema2Layer,
-		MediaTypeDockerSchema2LayerGzipPGP,MediaTypeDockerSchema2LayerPGP:
+	case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer,
+		MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
 		return true
 	}
 	return false
@@ -489,7 +488,7 @@ func isUserSelectedLayer(layerNum, layersTotal int, layers []int) bool {
 			return true
 		}
 	}
-	return false;
+	return false
 }
 
 // Encrypt all the Children of a given descriptor
@@ -506,14 +505,14 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	//fmt.Printf("metadata/image.go EncryptChildren(): got %d children\n", len(children))
 	var newLayers []ocispec.Descriptor
 	var config ocispec.Descriptor
-	modified := false;
+	modified := false
 
 	for _, child := range children {
 		// we only encrypt child layers and have to update their parents if encyrption happened
 		switch child.MediaType {
 		case MediaTypeDockerSchema2Config:
 			config = child
-		case MediaTypeDockerSchema2LayerGzip,MediaTypeDockerSchema2Layer:
+		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
 			// this one we can only encrypt
 			if encrypt && isUserSelectedLayer(layerNum, layersTotal, layers) {
 				nl, err := cryptLayer(ctx, cs, child, cc, true)
@@ -528,7 +527,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			layerNum = layerNum + 1
 		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
 			// this one we can only decrypt
-			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, layers){
+			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, layers) {
 				nl, err := cryptLayer(ctx, cs, child, cc, false)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -545,11 +544,11 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	}
 
 	if modified && len(newLayers) > 0 {
-		nM := ocispec.Manifest {
+		nM := ocispec.Manifest{
 			Versioned: specs.Versioned{
 				SchemaVersion: 2,
 			},
-			Config : config,
+			Config: config,
 			Layers: newLayers,
 		}
 
@@ -559,7 +558,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		}
 
 		nDesc := ocispec.Descriptor{
-			MediaType: MediaTypeDockerSchema2Manifest,//ocispec.MediaTypeImageManifest,//MediaTypeDockerSchema2Manifest,
+			MediaType: MediaTypeDockerSchema2Manifest, //ocispec.MediaTypeImageManifest,//MediaTypeDockerSchema2Manifest,
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
 			Platform:  desc.Platform,
@@ -612,7 +611,7 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 	}
 
-	if (modified) {
+	if modified {
 		// we need to update the index
 		newIndex := ocispec.Index{
 			Versioned: index.Versioned,
@@ -650,17 +649,17 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // until we get them from the layer descriptors
 func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, layers []int, layerNum int) ([]LayerInfo, error) {
 	var (
-		lis []LayerInfo
-		tmp []LayerInfo
+		lis      []LayerInfo
+		tmp      []LayerInfo
 		Platform string
 	)
 
-	switch (desc.MediaType) {
+	switch desc.MediaType {
 	case MediaTypeDockerSchema2ManifestList,
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
 		if desc.Platform != nil {
-			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture;
+			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture
 			if desc.Platform.Variant != "" {
 				Platform = Platform + "/" + desc.Platform.Variant
 			}
@@ -694,27 +693,27 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			}
 			lis = append(lis, tmp...)
 		}
-	case MediaTypeDockerSchema2Layer,MediaTypeDockerSchema2LayerGzip:
+	case MediaTypeDockerSchema2Layer, MediaTypeDockerSchema2LayerGzip:
 		li := LayerInfo{
-			KeyIds:       []uint64{},
-			Digest:       desc.Digest.String(),
-			Encryption:   "",
-			FileSize:     desc.Size,
-			Id:           uint32(layerNum),
+			KeyIds:     []uint64{},
+			Digest:     desc.Digest.String(),
+			Encryption: "",
+			FileSize:   desc.Size,
+			Id:         uint32(layerNum),
 		}
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
-	case MediaTypeDockerSchema2LayerPGP,MediaTypeDockerSchema2LayerGzipPGP:
+	case MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP:
 		kids, err := GetKeyIds(desc)
 		if err != nil {
 			return []LayerInfo{}, err
 		}
 		li := LayerInfo{
-			KeyIds:       kids,
-			Digest:       desc.Digest.String(),
-			Encryption:   "gpg",
-			FileSize:     desc.Size,
-			Id:           uint32(layerNum),
+			KeyIds:     kids,
+			Digest:     desc.Digest.String(),
+			Encryption: "gpg",
+			FileSize:   desc.Size,
+			Id:         uint32(layerNum),
 		}
 		lis = append(lis, li)
 	default:
diff --git a/images/openpgp.go b/images/openpgp.go
index 34150fb..bba0805 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -137,13 +137,13 @@ func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (enc
 		return nil, fmt.Errorf("Error serializing Lietral packet: %v", err)
 	}
 
-    if _, err := content.Write(data); err != nil {
-        return nil, err
-    }
+	if _, err := content.Write(data); err != nil {
+		return nil, err
+	}
 
-    if err := content.Close(); err != nil {
-        return nil, err
-    }
+	if err := content.Close(); err != nil {
+		return nil, err
+	}
 
 	encBlob = encData.Bytes()
 	log.Printf("Encrypted data bytes: %x", encBlob)
-- 
2.7.4


From 08b4edce973e3f75ddf3e99a5e95f09678776c10 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 25 Jul 2018 10:42:46 -0400
Subject: [PATCH 31/79] Enable selection of platforms using --platform for
 encryption/decryption/layerinfo

---
 api/next.pb.txt                      |  21 +++
 api/services/images/v1/images.pb.go  | 313 ++++++++++++++++++++++++++---------
 api/services/images/v1/images.proto  |   3 +
 cmd/ctr/commands/images/decrypt.go   |  11 +-
 cmd/ctr/commands/images/encrypt.go   |   7 +-
 cmd/ctr/commands/images/layerinfo.go |  10 +-
 cmd/ctr/commands/images/push.go      |   2 +-
 image_store.go                       |  12 +-
 images/image.go                      |  67 +++++---
 metadata/images.go                   |  38 ++++-
 platforms/platforms.go               |  13 ++
 services/images/local.go             |   9 +-
 12 files changed, 379 insertions(+), 127 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 81c3512..725868b 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2315,6 +2315,13 @@ file {
       type: TYPE_INT32
       json_name: "layers"
     }
+    field {
+      name: "platforms"
+      number: 5
+      label: LABEL_REPEATED
+      type: TYPE_STRING
+      json_name: "platforms"
+    }
   }
   message_type {
     name: "EncryptImageResponse"
@@ -2361,6 +2368,13 @@ file {
       type: TYPE_INT32
       json_name: "layers"
     }
+    field {
+      name: "platforms"
+      number: 5
+      label: LABEL_REPEATED
+      type: TYPE_STRING
+      json_name: "platforms"
+    }
   }
   message_type {
     name: "DecryptImageResponse"
@@ -2392,6 +2406,13 @@ file {
       type: TYPE_INT32
       json_name: "layers"
     }
+    field {
+      name: "platforms"
+      number: 3
+      label: LABEL_REPEATED
+      type: TYPE_STRING
+      json_name: "platforms"
+    }
   }
   message_type {
     name: "LayerInfo"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 06e6e42..239eaf8 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -210,10 +210,11 @@ func (*DecryptConfig) ProtoMessage()               {}
 func (*DecryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{12} }
 
 type EncryptImageRequest struct {
-	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Cc      *EncryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
-	Layers  []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
+	Name      string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName   string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Cc        *EncryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Layers    []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
+	Platforms []string       `protobuf:"bytes,5,rep,name=platforms" json:"platforms,omitempty"`
 }
 
 func (m *EncryptImageRequest) Reset()                    { *m = EncryptImageRequest{} }
@@ -229,10 +230,11 @@ func (*EncryptImageResponse) ProtoMessage()               {}
 func (*EncryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{14} }
 
 type DecryptImageRequest struct {
-	Name    string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	NewName string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Dc      *DecryptConfig `protobuf:"bytes,3,opt,name=dc" json:"dc,omitempty"`
-	Layers  []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
+	Name      string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	NewName   string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
+	Dc        *DecryptConfig `protobuf:"bytes,3,opt,name=dc" json:"dc,omitempty"`
+	Layers    []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
+	Platforms []string       `protobuf:"bytes,5,rep,name=platforms" json:"platforms,omitempty"`
 }
 
 func (m *DecryptImageRequest) Reset()                    { *m = DecryptImageRequest{} }
@@ -248,8 +250,9 @@ func (*DecryptImageResponse) ProtoMessage()               {}
 func (*DecryptImageResponse) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{16} }
 
 type GetImageLayerInfoRequest struct {
-	Name   string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
-	Layers []int32 `protobuf:"varint,2,rep,packed,name=layers" json:"layers,omitempty"`
+	Name      string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
+	Layers    []int32  `protobuf:"varint,2,rep,packed,name=layers" json:"layers,omitempty"`
+	Platforms []string `protobuf:"bytes,3,rep,name=platforms" json:"platforms,omitempty"`
 }
 
 func (m *GetImageLayerInfoRequest) Reset()                    { *m = GetImageLayerInfoRequest{} }
@@ -1122,6 +1125,21 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(j12))
 		i += copy(dAtA[i:], dAtA13[:j12])
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			dAtA[i] = 0x2a
+			i++
+			l = len(s)
+			for l >= 1<<7 {
+				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
+				l >>= 7
+				i++
+			}
+			dAtA[i] = uint8(l)
+			i++
+			i += copy(dAtA[i:], s)
+		}
+	}
 	return i, nil
 }
 
@@ -1206,6 +1224,21 @@ func (m *DecryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(j16))
 		i += copy(dAtA[i:], dAtA17[:j16])
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			dAtA[i] = 0x2a
+			i++
+			l = len(s)
+			for l >= 1<<7 {
+				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
+				l >>= 7
+				i++
+			}
+			dAtA[i] = uint8(l)
+			i++
+			i += copy(dAtA[i:], s)
+		}
+	}
 	return i, nil
 }
 
@@ -1274,6 +1307,21 @@ func (m *GetImageLayerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(j19))
 		i += copy(dAtA[i:], dAtA20[:j19])
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			dAtA[i] = 0x1a
+			i++
+			l = len(s)
+			for l >= 1<<7 {
+				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
+				l >>= 7
+				i++
+			}
+			dAtA[i] = uint8(l)
+			i++
+			i += copy(dAtA[i:], s)
+		}
+	}
 	return i, nil
 }
 
@@ -1567,6 +1615,12 @@ func (m *EncryptImageRequest) Size() (n int) {
 		}
 		n += 1 + sovImages(uint64(l)) + l
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			l = len(s)
+			n += 1 + l + sovImages(uint64(l))
+		}
+	}
 	return n
 }
 
@@ -1600,6 +1654,12 @@ func (m *DecryptImageRequest) Size() (n int) {
 		}
 		n += 1 + sovImages(uint64(l)) + l
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			l = len(s)
+			n += 1 + l + sovImages(uint64(l))
+		}
+	}
 	return n
 }
 
@@ -1625,6 +1685,12 @@ func (m *GetImageLayerInfoRequest) Size() (n int) {
 		}
 		n += 1 + sovImages(uint64(l)) + l
 	}
+	if len(m.Platforms) > 0 {
+		for _, s := range m.Platforms {
+			l = len(s)
+			n += 1 + l + sovImages(uint64(l))
+		}
+	}
 	return n
 }
 
@@ -1851,6 +1917,7 @@ func (this *EncryptImageRequest) String() string {
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
 		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "EncryptConfig", "EncryptConfig", 1) + `,`,
 		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
+		`Platforms:` + fmt.Sprintf("%v", this.Platforms) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1874,6 +1941,7 @@ func (this *DecryptImageRequest) String() string {
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
 		`Dc:` + strings.Replace(fmt.Sprintf("%v", this.Dc), "DecryptConfig", "DecryptConfig", 1) + `,`,
 		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
+		`Platforms:` + fmt.Sprintf("%v", this.Platforms) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1895,6 +1963,7 @@ func (this *GetImageLayerInfoRequest) String() string {
 	s := strings.Join([]string{`&GetImageLayerInfoRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
+		`Platforms:` + fmt.Sprintf("%v", this.Platforms) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -3559,6 +3628,35 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			} else {
 				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
 			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Platforms", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Platforms = append(m.Platforms, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3842,6 +3940,35 @@ func (m *DecryptImageRequest) Unmarshal(dAtA []byte) error {
 			} else {
 				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
 			}
+		case 5:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Platforms", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Platforms = append(m.Platforms, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -4063,6 +4190,35 @@ func (m *GetImageLayerInfoRequest) Unmarshal(dAtA []byte) error {
 			} else {
 				return fmt.Errorf("proto: wrong wireType = %d for field Layers", wireType)
 			}
+		case 3:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Platforms", wireType)
+			}
+			var stringLen uint64
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				stringLen |= (uint64(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			intStringLen := int(stringLen)
+			if intStringLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + intStringLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.Platforms = append(m.Platforms, string(dAtA[iNdEx:postIndex]))
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -4512,73 +4668,74 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 1075 bytes of a gzipped FileDescriptorProto
+	// 1094 bytes of a gzipped FileDescriptorProto
 	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
-	0x10, 0x36, 0x29, 0x59, 0xb6, 0x46, 0x76, 0x93, 0x6c, 0x0c, 0x83, 0x65, 0x5b, 0x59, 0x20, 0x52,
-	0x40, 0x87, 0x86, 0xaa, 0x95, 0x43, 0x53, 0x3b, 0x28, 0x1a, 0x5b, 0x76, 0x6a, 0xc4, 0x09, 0x0a,
-	0xe6, 0xa7, 0x46, 0x2f, 0x01, 0x45, 0xae, 0xd8, 0xad, 0x28, 0x92, 0x25, 0x57, 0x36, 0xd8, 0x53,
-	0x4f, 0xbd, 0xb6, 0x40, 0x4f, 0x7d, 0x86, 0xbe, 0x88, 0x8f, 0x05, 0x7a, 0xe9, 0x29, 0x6d, 0x74,
-	0xe8, 0x73, 0x14, 0xdc, 0x5d, 0x4a, 0xa4, 0x24, 0x98, 0x52, 0xe2, 0xdb, 0xcc, 0x72, 0xbe, 0xf9,
-	0xf9, 0x66, 0x77, 0x46, 0x82, 0x8e, 0x43, 0xe8, 0x77, 0xc3, 0xae, 0x6e, 0xf9, 0x83, 0x96, 0xe5,
-	0x7b, 0xd4, 0x24, 0x1e, 0x0e, 0xed, 0xac, 0x68, 0x06, 0xa4, 0x15, 0xe1, 0xf0, 0x9c, 0x58, 0x38,
-	0x6a, 0x91, 0x81, 0xe9, 0xe0, 0xa8, 0x75, 0xbe, 0x2b, 0x24, 0x3d, 0x08, 0x7d, 0xea, 0xa3, 0x8f,
-	0x26, 0xf6, 0x7a, 0x6a, 0xab, 0x0b, 0x8b, 0xf3, 0x5d, 0x75, 0xcb, 0xf1, 0x1d, 0x9f, 0x59, 0xb6,
-	0x12, 0x89, 0x83, 0xd4, 0x0f, 0x1c, 0xdf, 0x77, 0x5c, 0xdc, 0x62, 0x5a, 0x77, 0xd8, 0x6b, 0xe1,
-	0x41, 0x40, 0x63, 0xf1, 0xb1, 0x31, 0xfd, 0xb1, 0x47, 0xb0, 0x6b, 0xbf, 0x1a, 0x98, 0x51, 0x5f,
-	0x58, 0xec, 0x4c, 0x5b, 0x50, 0x32, 0xc0, 0x11, 0x35, 0x07, 0x81, 0x30, 0xd8, 0x5f, 0xa8, 0x34,
-	0x1a, 0x07, 0x38, 0x6a, 0xd9, 0x38, 0xb2, 0x42, 0x12, 0x50, 0x3f, 0xe4, 0x60, 0xed, 0x3f, 0x19,
-	0x56, 0x4f, 0x92, 0x02, 0x10, 0x82, 0xb2, 0x67, 0x0e, 0xb0, 0x22, 0x35, 0xa4, 0x66, 0xd5, 0x60,
-	0x32, 0xfa, 0x0a, 0x2a, 0xae, 0xd9, 0xc5, 0x6e, 0xa4, 0xc8, 0x8d, 0x52, 0xb3, 0xd6, 0xfe, 0x54,
-	0xbf, 0x92, 0x00, 0x9d, 0x79, 0xd2, 0x4f, 0x19, 0xe4, 0xc8, 0xa3, 0x61, 0x6c, 0x08, 0x3c, 0xda,
-	0x83, 0x0a, 0x35, 0x43, 0x07, 0x53, 0xa5, 0xd4, 0x90, 0x9a, 0xb5, 0xf6, 0x87, 0x59, 0x4f, 0x2c,
-	0x37, 0xbd, 0x33, 0xce, 0xed, 0xa0, 0x7c, 0xf9, 0x7a, 0x67, 0xc5, 0x10, 0x08, 0x74, 0x08, 0x60,
-	0x85, 0xd8, 0xa4, 0xd8, 0x7e, 0x65, 0x52, 0x65, 0x8d, 0xe1, 0x55, 0x9d, 0xd3, 0xa2, 0xa7, 0xb4,
-	0xe8, 0xcf, 0x53, 0x5a, 0x0e, 0xd6, 0x13, 0xf4, 0xaf, 0xff, 0xec, 0x48, 0x46, 0x55, 0xe0, 0x1e,
-	0x32, 0x27, 0xc3, 0xc0, 0x4e, 0x9d, 0xac, 0x2f, 0xe3, 0x44, 0xe0, 0x1e, 0x52, 0xf5, 0x73, 0xa8,
-	0x65, 0x8a, 0x43, 0x37, 0xa1, 0xd4, 0xc7, 0xb1, 0x60, 0x2c, 0x11, 0xd1, 0x16, 0xac, 0x9e, 0x9b,
-	0xee, 0x10, 0x2b, 0x32, 0x3b, 0xe3, 0xca, 0x9e, 0x7c, 0x5f, 0xd2, 0x3e, 0x86, 0x1b, 0x8f, 0x30,
-	0x65, 0x04, 0x19, 0xf8, 0x87, 0x21, 0x8e, 0xe8, 0x3c, 0xc6, 0xb5, 0xa7, 0x70, 0x73, 0x62, 0x16,
-	0x05, 0xbe, 0x17, 0x61, 0xb4, 0x07, 0xab, 0x8c, 0x62, 0x66, 0x58, 0x6b, 0xdf, 0x59, 0xa4, 0x09,
-	0x06, 0x87, 0x68, 0x2f, 0x01, 0x1d, 0x32, 0x0e, 0x72, 0x91, 0xbf, 0x7c, 0x0b, 0x8f, 0xa2, 0x29,
-	0xc2, 0xef, 0x37, 0x70, 0x3b, 0xe7, 0x57, 0xa4, 0xfa, 0xee, 0x8e, 0x7f, 0x93, 0x00, 0xbd, 0x60,
-	0x84, 0x5f, 0x6f, 0xc6, 0x68, 0x1f, 0x6a, 0xbc, 0x91, 0xec, 0x71, 0xb1, 0x06, 0xcd, 0xbb, 0x01,
-	0xc7, 0xc9, 0xfb, 0x7b, 0x62, 0x46, 0x7d, 0x43, 0xdc, 0x97, 0x44, 0x4e, 0xca, 0xcd, 0x25, 0x75,
-	0x6d, 0xe5, 0xde, 0x85, 0x5b, 0xa7, 0x24, 0xe2, 0x0d, 0x8f, 0xd2, 0x62, 0x15, 0x58, 0xeb, 0x11,
-	0x97, 0xe2, 0x30, 0x52, 0xa4, 0x46, 0xa9, 0x59, 0x35, 0x52, 0x55, 0x3b, 0x03, 0x94, 0x35, 0x17,
-	0x69, 0x1c, 0x40, 0x85, 0x07, 0x61, 0xe6, 0xcb, 0xe5, 0x21, 0x90, 0xda, 0x03, 0x40, 0x1d, 0xec,
-	0xe2, 0x29, 0xda, 0xe7, 0x0d, 0x05, 0x04, 0xe5, 0x28, 0xf6, 0x2c, 0xc6, 0xe0, 0xba, 0xc1, 0x64,
-	0xed, 0x05, 0x6c, 0x1e, 0x79, 0x56, 0x18, 0x07, 0xf4, 0xd0, 0xf7, 0x7a, 0xc4, 0x41, 0x75, 0x80,
-	0x10, 0x5b, 0x24, 0x20, 0xd8, 0xa3, 0x69, 0x15, 0x99, 0x13, 0x74, 0x07, 0x36, 0x9d, 0xc0, 0x09,
-	0x86, 0xdd, 0x3e, 0x8e, 0x43, 0xe2, 0x39, 0xcc, 0xdb, 0x86, 0x91, 0x3f, 0xd4, 0x9e, 0xc3, 0x7b,
-	0x1d, 0xcc, 0xdc, 0x3e, 0xc6, 0x71, 0xc7, 0xa4, 0x66, 0x42, 0x4d, 0x9f, 0x8b, 0x2c, 0xa7, 0x0d,
-	0x23, 0x55, 0x51, 0x13, 0x6e, 0x08, 0xf1, 0x6b, 0x33, 0x8a, 0x2e, 0xfc, 0xd0, 0x16, 0x3e, 0xa7,
-	0x8f, 0xb5, 0xbf, 0x24, 0xd8, 0x14, 0x6e, 0x45, 0xb6, 0x2f, 0x61, 0xbd, 0x8f, 0xe3, 0x13, 0xfb,
-	0x89, 0x19, 0x08, 0x0a, 0xf7, 0x0a, 0x28, 0xcc, 0xe1, 0xf5, 0xc7, 0x02, 0xcc, 0x67, 0xde, 0xd8,
-	0x97, 0xfa, 0x3d, 0x6c, 0xe6, 0x3e, 0x65, 0x27, 0x46, 0x99, 0x4f, 0x8c, 0xc3, 0xec, 0xc4, 0xa8,
-	0xb5, 0xef, 0x2e, 0x16, 0x57, 0xd0, 0x91, 0x1d, 0x30, 0xbf, 0x4b, 0x70, 0x5b, 0xf4, 0xa0, 0xb0,
-	0x85, 0x0a, 0xac, 0x79, 0xf8, 0xe2, 0x69, 0x72, 0xcc, 0x07, 0x55, 0xaa, 0xa2, 0x07, 0x20, 0x5b,
-	0x96, 0x98, 0xd1, 0x9f, 0x14, 0xe4, 0x92, 0xeb, 0xb8, 0x21, 0x5b, 0x16, 0xda, 0x4e, 0xf6, 0x45,
-	0x9c, 0xdc, 0xdb, 0x72, 0xa3, 0xd4, 0x5c, 0x35, 0x84, 0xa6, 0x9d, 0xc1, 0x56, 0x3e, 0xb5, 0x6b,
-	0x7b, 0x3f, 0x49, 0xd5, 0x82, 0x93, 0x77, 0xab, 0xda, 0x5e, 0xb4, 0xea, 0x5c, 0xe7, 0x0d, 0xd9,
-	0xbe, 0xb2, 0xea, 0x7c, 0x6a, 0xd7, 0x56, 0xf5, 0x31, 0x28, 0xe9, 0x96, 0x38, 0x4d, 0x62, 0x9d,
-	0x78, 0x3d, 0xff, 0xaa, 0xca, 0x27, 0x19, 0xca, 0xb9, 0x0c, 0xff, 0x90, 0xa0, 0x3a, 0x76, 0x80,
-	0xb6, 0x41, 0x26, 0x36, 0xc3, 0x6d, 0x1e, 0x54, 0x46, 0xaf, 0x77, 0xe4, 0x93, 0x8e, 0x21, 0x13,
-	0x3b, 0x41, 0xb3, 0x1b, 0xcd, 0xd1, 0x65, 0x43, 0x68, 0xc9, 0xb9, 0x4d, 0x1c, 0x1c, 0xf1, 0x9d,
-	0x5e, 0x35, 0x84, 0x96, 0xbc, 0x7d, 0xcc, 0xbb, 0x4d, 0x7c, 0x4f, 0x29, 0xb3, 0x6f, 0x99, 0x13,
-	0xa4, 0xc2, 0x7a, 0x8f, 0xb8, 0xf8, 0x19, 0xf9, 0x11, 0x2b, 0xab, 0x0d, 0xa9, 0x59, 0x32, 0xc6,
-	0x7a, 0xf2, 0x2d, 0x70, 0x4d, 0xda, 0xf3, 0xc3, 0x81, 0x52, 0x61, 0xc8, 0xb1, 0xae, 0x59, 0xf0,
-	0xfe, 0x9c, 0xaa, 0x05, 0xa9, 0xc7, 0x50, 0x75, 0xd3, 0x43, 0xf1, 0x86, 0x9b, 0x05, 0xc4, 0x4e,
-	0x9c, 0x4c, 0xa0, 0xed, 0x5f, 0xd6, 0xa0, 0xc2, 0xc7, 0x2b, 0xea, 0x41, 0xe9, 0x11, 0xa6, 0x48,
-	0x2f, 0x70, 0x33, 0xb5, 0xd6, 0xd5, 0xd6, 0xc2, 0xf6, 0x22, 0xf5, 0x3e, 0x94, 0x93, 0xa1, 0x8e,
-	0x8a, 0x7e, 0x5d, 0xcd, 0x2c, 0x0a, 0x75, 0x77, 0x09, 0x84, 0x08, 0xe6, 0x43, 0x85, 0x2f, 0x6e,
-	0x54, 0x04, 0x9e, 0xfd, 0xdd, 0xa0, 0xb6, 0x97, 0x81, 0x4c, 0x02, 0xf2, 0xd5, 0x59, 0x18, 0x70,
-	0x76, 0xed, 0x17, 0x06, 0x9c, 0xb7, 0x94, 0x9f, 0x41, 0x85, 0x6f, 0xb2, 0xc2, 0x80, 0xb3, 0x0b,
-	0x4f, 0xdd, 0x9e, 0xf9, 0x41, 0x70, 0x94, 0xfc, 0x5a, 0x47, 0x17, 0xb0, 0x91, 0x9d, 0x60, 0xa8,
-	0xbd, 0xd8, 0x6c, 0xcc, 0xf9, 0xbe, 0xb7, 0x14, 0x46, 0x54, 0x73, 0x01, 0x1b, 0xd9, 0x21, 0x52,
-	0x18, 0x78, 0xce, 0x30, 0x2c, 0x0c, 0x3c, 0x77, 0x4a, 0xfd, 0x2c, 0xc1, 0xad, 0x99, 0xe7, 0x86,
-	0x3e, 0x5b, 0xf0, 0x72, 0x4f, 0x8f, 0x25, 0xf5, 0xfe, 0xf2, 0x40, 0x9e, 0xc8, 0xc1, 0xd9, 0xe5,
-	0x9b, 0xfa, 0xca, 0xdf, 0x6f, 0xea, 0x2b, 0x3f, 0x8d, 0xea, 0xd2, 0xe5, 0xa8, 0x2e, 0xfd, 0x39,
-	0xaa, 0x4b, 0xff, 0x8e, 0xea, 0xd2, 0xb7, 0x5f, 0xbc, 0xe5, 0x9f, 0xba, 0x7d, 0x2e, 0x9d, 0xad,
-	0x74, 0x2b, 0xac, 0xcd, 0xf7, 0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x33, 0x0f, 0xcb, 0x18, 0x1f,
-	0x0e, 0x00, 0x00,
+	0x10, 0x36, 0xa9, 0x1f, 0x5b, 0x23, 0xbb, 0x49, 0x36, 0x86, 0xc1, 0xb2, 0xa9, 0x2c, 0x10, 0x29,
+	0xa0, 0x43, 0x43, 0xd5, 0xca, 0xa1, 0xa9, 0x1d, 0x14, 0x8d, 0x2d, 0x27, 0x35, 0xe2, 0x04, 0x05,
+	0xf3, 0x53, 0xa3, 0x97, 0x80, 0x26, 0x57, 0xec, 0x56, 0x12, 0xc9, 0x72, 0x57, 0x36, 0xd8, 0x53,
+	0x4f, 0xbd, 0xb6, 0x40, 0x1f, 0xa3, 0x0f, 0xd0, 0x57, 0xf0, 0xb1, 0x40, 0x2f, 0x3d, 0xa5, 0x8d,
+	0x0f, 0x7d, 0x8e, 0x82, 0xbb, 0x4b, 0x8b, 0x94, 0xd4, 0x50, 0x8a, 0x7d, 0x9b, 0x59, 0xce, 0xf7,
+	0xcd, 0xec, 0xb7, 0xbb, 0xb3, 0x4b, 0xe8, 0x7a, 0x84, 0x7d, 0x3b, 0x3a, 0x36, 0x9d, 0x60, 0xd8,
+	0x76, 0x02, 0x9f, 0xd9, 0xc4, 0xc7, 0x91, 0x9b, 0x35, 0xed, 0x90, 0xb4, 0x29, 0x8e, 0x4e, 0x88,
+	0x83, 0x69, 0x9b, 0x0c, 0x6d, 0x0f, 0xd3, 0xf6, 0xc9, 0x96, 0xb4, 0xcc, 0x30, 0x0a, 0x58, 0x80,
+	0x3e, 0x1c, 0xc7, 0x9b, 0x69, 0xac, 0x29, 0x23, 0x4e, 0xb6, 0xf4, 0x75, 0x2f, 0xf0, 0x02, 0x1e,
+	0xd9, 0x4e, 0x2c, 0x01, 0xd2, 0x3f, 0xf0, 0x82, 0xc0, 0x1b, 0xe0, 0x36, 0xf7, 0x8e, 0x47, 0xbd,
+	0x36, 0x1e, 0x86, 0x2c, 0x96, 0x1f, 0x9b, 0x93, 0x1f, 0x7b, 0x04, 0x0f, 0xdc, 0x57, 0x43, 0x9b,
+	0xf6, 0x65, 0xc4, 0xe6, 0x64, 0x04, 0x23, 0x43, 0x4c, 0x99, 0x3d, 0x0c, 0x65, 0xc0, 0xce, 0x5c,
+	0x53, 0x63, 0x71, 0x88, 0x69, 0xdb, 0xc5, 0xd4, 0x89, 0x48, 0xc8, 0x82, 0x48, 0x80, 0x8d, 0x7f,
+	0x55, 0xa8, 0x1c, 0x24, 0x13, 0x40, 0x08, 0xca, 0xbe, 0x3d, 0xc4, 0x9a, 0xd2, 0x54, 0x5a, 0x35,
+	0x8b, 0xdb, 0xe8, 0x4b, 0xa8, 0x0e, 0xec, 0x63, 0x3c, 0xa0, 0x9a, 0xda, 0x2c, 0xb5, 0xea, 0x9d,
+	0x4f, 0xcc, 0xb7, 0x0a, 0x60, 0x72, 0x26, 0xf3, 0x90, 0x43, 0xf6, 0x7d, 0x16, 0xc5, 0x96, 0xc4,
+	0xa3, 0x6d, 0xa8, 0x32, 0x3b, 0xf2, 0x30, 0xd3, 0x4a, 0x4d, 0xa5, 0x55, 0xef, 0xdc, 0xca, 0x32,
+	0xf1, 0xda, 0xcc, 0xee, 0x45, 0x6d, 0xbb, 0xe5, 0xb3, 0xd7, 0x9b, 0x4b, 0x96, 0x44, 0xa0, 0x3d,
+	0x00, 0x27, 0xc2, 0x36, 0xc3, 0xee, 0x2b, 0x9b, 0x69, 0xcb, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33,
+	0x95, 0xc5, 0x7c, 0x9e, 0xca, 0xb2, 0xbb, 0x92, 0xa0, 0x7f, 0xf9, 0x7b, 0x53, 0xb1, 0x6a, 0x12,
+	0xf7, 0x80, 0x93, 0x8c, 0x42, 0x37, 0x25, 0x59, 0x59, 0x84, 0x44, 0xe2, 0x1e, 0x30, 0xfd, 0x33,
+	0xa8, 0x67, 0x26, 0x87, 0xae, 0x43, 0xa9, 0x8f, 0x63, 0xa9, 0x58, 0x62, 0xa2, 0x75, 0xa8, 0x9c,
+	0xd8, 0x83, 0x11, 0xd6, 0x54, 0x3e, 0x26, 0x9c, 0x6d, 0xf5, 0x9e, 0x62, 0x7c, 0x04, 0xd7, 0x1e,
+	0x61, 0xc6, 0x05, 0xb2, 0xf0, 0xf7, 0x23, 0x4c, 0xd9, 0x2c, 0xc5, 0x8d, 0xa7, 0x70, 0x7d, 0x1c,
+	0x46, 0xc3, 0xc0, 0xa7, 0x18, 0x6d, 0x43, 0x85, 0x4b, 0xcc, 0x03, 0xeb, 0x9d, 0xdb, 0xf3, 0x2c,
+	0x82, 0x25, 0x20, 0xc6, 0x4b, 0x40, 0x7b, 0x5c, 0x83, 0x5c, 0xe6, 0x2f, 0xde, 0x81, 0x51, 0x2e,
+	0x8a, 0xe4, 0xfd, 0x1a, 0x6e, 0xe6, 0x78, 0x65, 0xa9, 0x97, 0x27, 0xfe, 0x55, 0x01, 0xf4, 0x82,
+	0x0b, 0x7e, 0xb5, 0x15, 0xa3, 0x1d, 0xa8, 0x8b, 0x85, 0xe4, 0x87, 0x8b, 0x2f, 0xd0, 0xac, 0x1d,
+	0xf0, 0x30, 0x39, 0x7f, 0x4f, 0x6c, 0xda, 0xb7, 0xe4, 0x7e, 0x49, 0xec, 0x64, 0xba, 0xb9, 0xa2,
+	0xae, 0x6c, 0xba, 0x77, 0xe0, 0xc6, 0x21, 0xa1, 0x62, 0xc1, 0x69, 0x3a, 0x59, 0x0d, 0x96, 0x7b,
+	0x64, 0xc0, 0x70, 0x44, 0x35, 0xa5, 0x59, 0x6a, 0xd5, 0xac, 0xd4, 0x35, 0x8e, 0x00, 0x65, 0xc3,
+	0x65, 0x19, 0xbb, 0x50, 0x15, 0x49, 0x78, 0xf8, 0x62, 0x75, 0x48, 0xa4, 0x71, 0x1f, 0x50, 0x17,
+	0x0f, 0xf0, 0x84, 0xec, 0xb3, 0x9a, 0x02, 0x82, 0x32, 0x8d, 0x7d, 0x87, 0x2b, 0xb8, 0x62, 0x71,
+	0xdb, 0x78, 0x01, 0x6b, 0xfb, 0xbe, 0x13, 0xc5, 0x21, 0xdb, 0x0b, 0xfc, 0x1e, 0xf1, 0x50, 0x03,
+	0x20, 0xc2, 0x0e, 0x09, 0x09, 0xf6, 0x59, 0x3a, 0x8b, 0xcc, 0x08, 0xba, 0x0d, 0x6b, 0x5e, 0xe8,
+	0x85, 0xa3, 0xe3, 0x3e, 0x8e, 0x23, 0xe2, 0x7b, 0x9c, 0x6d, 0xd5, 0xca, 0x0f, 0x1a, 0xcf, 0xe1,
+	0xbd, 0x2e, 0xe6, 0xb4, 0x8f, 0x71, 0xdc, 0xb5, 0x99, 0x9d, 0x48, 0xd3, 0x17, 0x26, 0xaf, 0x69,
+	0xd5, 0x4a, 0x5d, 0xd4, 0x82, 0x6b, 0xd2, 0xfc, 0xca, 0xa6, 0xf4, 0x34, 0x88, 0x5c, 0xc9, 0x39,
+	0x39, 0x6c, 0xfc, 0xa9, 0xc0, 0x9a, 0xa4, 0x95, 0xd5, 0xbe, 0x84, 0x95, 0x3e, 0x8e, 0x0f, 0xdc,
+	0x27, 0x76, 0x28, 0x25, 0xdc, 0x2e, 0x90, 0x30, 0x87, 0x37, 0x1f, 0x4b, 0xb0, 0xe8, 0x79, 0x17,
+	0x5c, 0xfa, 0x77, 0xb0, 0x96, 0xfb, 0x94, 0xed, 0x18, 0x65, 0xd1, 0x31, 0xf6, 0xb2, 0x1d, 0xa3,
+	0xde, 0xb9, 0x33, 0x5f, 0x5e, 0x29, 0x47, 0xb6, 0xc1, 0xfc, 0xae, 0xc0, 0x4d, 0xb9, 0x06, 0x85,
+	0x4b, 0xa8, 0xc1, 0xb2, 0x8f, 0x4f, 0x9f, 0x26, 0xc3, 0xa2, 0x51, 0xa5, 0x2e, 0xba, 0x0f, 0xaa,
+	0xe3, 0xc8, 0x1e, 0xfd, 0x71, 0x41, 0x2d, 0xb9, 0x15, 0xb7, 0x54, 0xc7, 0x41, 0x1b, 0xc9, 0x7d,
+	0x11, 0x27, 0xfb, 0xb6, 0xdc, 0x2c, 0xb5, 0x2a, 0x96, 0xf4, 0xd0, 0x2d, 0xa8, 0x85, 0x03, 0x9b,
+	0xf5, 0x82, 0x68, 0x48, 0xb5, 0x0a, 0xdf, 0x0c, 0xe3, 0x01, 0xe3, 0x08, 0xd6, 0xf3, 0x85, 0x5f,
+	0xd9, 0xe9, 0x4a, 0x34, 0x91, 0x8a, 0x5d, 0x4e, 0x13, 0x77, 0x5e, 0x4d, 0x72, 0xfb, 0xc2, 0x52,
+	0xdd, 0x4b, 0x68, 0x92, 0x2f, 0xfc, 0xca, 0x34, 0x71, 0x41, 0x4b, 0x6f, 0x98, 0xc3, 0xa4, 0x92,
+	0x03, 0xbf, 0x17, 0xbc, 0x4d, 0x97, 0x71, 0xfd, 0xea, 0xff, 0xd7, 0x5f, 0x9a, 0xac, 0xff, 0x37,
+	0x05, 0x6a, 0x17, 0xf4, 0x68, 0x03, 0x54, 0xe2, 0x72, 0xd6, 0xb5, 0xdd, 0xea, 0xf9, 0xeb, 0x4d,
+	0xf5, 0xa0, 0x6b, 0xa9, 0xc4, 0x4d, 0xb8, 0xf9, 0x59, 0x11, 0xdc, 0x65, 0x4b, 0x7a, 0xc9, 0xb8,
+	0x4b, 0x3c, 0x4c, 0xc5, 0x6b, 0xa1, 0x66, 0x49, 0x2f, 0xe9, 0x2a, 0x58, 0xec, 0x14, 0x12, 0xf8,
+	0x5a, 0x99, 0x7f, 0xcb, 0x8c, 0x20, 0x1d, 0x56, 0x7a, 0x64, 0x80, 0x9f, 0x91, 0x1f, 0xb0, 0x56,
+	0x69, 0x2a, 0xad, 0x92, 0x75, 0xe1, 0x27, 0xdf, 0xd2, 0xf2, 0xb4, 0x2a, 0x47, 0x5e, 0xf8, 0x86,
+	0x03, 0xef, 0xcf, 0xd0, 0x44, 0x4a, 0xfe, 0x10, 0x6a, 0x83, 0x74, 0x50, 0x76, 0x87, 0x56, 0x81,
+	0xec, 0x63, 0x92, 0x31, 0xb4, 0xf3, 0xf3, 0x32, 0x54, 0x45, 0xe3, 0x46, 0x3d, 0x28, 0x3d, 0xc2,
+	0x0c, 0x99, 0x05, 0x34, 0x13, 0x0f, 0x06, 0xbd, 0x3d, 0x77, 0xbc, 0x2c, 0xbd, 0x0f, 0xe5, 0xe4,
+	0xba, 0x40, 0x45, 0xef, 0xb6, 0xa9, 0x2b, 0x48, 0xdf, 0x5a, 0x00, 0x21, 0x93, 0x05, 0x50, 0x15,
+	0x4f, 0x02, 0x54, 0x04, 0x9e, 0x7e, 0x91, 0xe8, 0x9d, 0x45, 0x20, 0xe3, 0x84, 0xe2, 0x52, 0x2e,
+	0x4c, 0x38, 0xfd, 0xa0, 0x28, 0x4c, 0x38, 0xeb, 0xba, 0x7f, 0x06, 0x55, 0x71, 0x47, 0x16, 0x26,
+	0x9c, 0xbe, 0x4a, 0xf5, 0x8d, 0xa9, 0xa7, 0xc6, 0x7e, 0xf2, 0x1f, 0x80, 0x4e, 0x61, 0x35, 0xdb,
+	0xfd, 0x50, 0x67, 0xbe, 0xae, 0x9b, 0xe3, 0xbe, 0xbb, 0x10, 0x46, 0xce, 0xe6, 0x14, 0x56, 0xb3,
+	0x2d, 0xa6, 0x30, 0xf1, 0x8c, 0x46, 0x5a, 0x98, 0x78, 0x66, 0x0f, 0xfb, 0x49, 0x81, 0x1b, 0x53,
+	0xc7, 0x0d, 0x7d, 0x3a, 0xe7, 0xe6, 0x9e, 0x6c, 0x5a, 0xfa, 0xbd, 0xc5, 0x81, 0xa2, 0x90, 0xdd,
+	0xa3, 0xb3, 0x37, 0x8d, 0xa5, 0xbf, 0xde, 0x34, 0x96, 0x7e, 0x3c, 0x6f, 0x28, 0x67, 0xe7, 0x0d,
+	0xe5, 0x8f, 0xf3, 0x86, 0xf2, 0xcf, 0x79, 0x43, 0xf9, 0xe6, 0xf3, 0x77, 0xfc, 0x5d, 0xdc, 0x11,
+	0xd6, 0xd1, 0xd2, 0x71, 0x95, 0x2f, 0xf3, 0xdd, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x82,
+	0xc8, 0xdb, 0x79, 0x0e, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 46de40d..ef29246 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -151,6 +151,7 @@ message EncryptImageRequest {
 
 	EncryptConfig cc = 3;
 	repeated int32 layers = 4;
+	repeated string platforms = 5;
 }
 
 message EncryptImageResponse {
@@ -163,6 +164,7 @@ message DecryptImageRequest {
 
 	DecryptConfig dc = 3;
 	repeated int32 layers = 4;
+	repeated string platforms = 5;
 }
 
 message DecryptImageResponse {
@@ -172,6 +174,7 @@ message DecryptImageResponse {
 message GetImageLayerInfoRequest {
 	string name = 1;
 	repeated int32 layers = 2;
+	repeated string platforms = 3;
 }
 
 message LayerInfo {
diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 7d36e5d..6103ccb 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -41,6 +41,9 @@ var decryptCommand = cli.Command{
 	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
 		Name:  "layer",
 		Usage: "The layer to decrypt; this must be either the layer number or a negative number starting with -1 for topmost layer",
+	}, cli.StringSliceFlag{
+		Name:  "platform",
+		Usage: "For which platform to decrypt; by default decryption is done for all platforms",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -62,7 +65,7 @@ var decryptCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"))
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"), context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
@@ -74,7 +77,7 @@ var decryptCommand = cli.Command{
 			}
 		}
 		if !isEncrypted {
-			fmt.Printf("The image is not encrypted.\n")
+			fmt.Printf("Nothing to decrypted.\n")
 			return nil
 		}
 
@@ -89,7 +92,7 @@ var decryptCommand = cli.Command{
 					found = true
 					break
 				}
-				// do we have this key
+				// do we have this key?
 				haveKey, _ := HaveGPGPrivateKey(keyid)
 				// this may fail if the key is not here; we ignore the error
 				if !haveKey {
@@ -122,7 +125,7 @@ var decryptCommand = cli.Command{
 			Dc: &images.DecryptConfig {
 				KeyIdMap: keyIdMap,
 			},
-		}, context.IntSlice("layer"))
+		}, context.IntSlice("layer"), context.StringSlice("platform"))
 		return err
 	},
 }
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 878b862..9eec73a 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -36,9 +36,12 @@ var encryptCommand = cli.Command{
 	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
 		Name:  "recipient",
 		Usage: "Recipient of the image is the person who can decrypt it",
-		}, cli.IntSliceFlag{
+	}, cli.IntSliceFlag{
 		Name:  "layer",
 		Usage: "The layer to encrypt; this must be either the layer number or a negative number starting with -1 for topmost layer",
+	}, cli.StringSliceFlag{
+		Name:  "platform",
+		Usage: "For which platform to encrypt; by default encrytion is done for all platforms",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -74,7 +77,7 @@ var encryptCommand = cli.Command{
 				Recipients:     recipients,
 			},
 		}
-		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, context.IntSlice("layer"))
+		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, context.IntSlice("layer"), context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 8616f68..4922109 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -38,6 +38,9 @@ var layerinfoCommand = cli.Command{
 	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
 		Name:  "layer",
 		Usage: "The layer to get info for; this must be either the layer number or a negative number starting with -1 for topmost layer",
+	}, cli.StringSliceFlag{
+		Name:  "platform",
+		Usage: "For which platform to get the layer info; by default info for all platforms is retrieved",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -52,10 +55,14 @@ var layerinfoCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"))
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"), context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
+		if len(LayerInfos) == 0 {
+			return nil
+		}
+
 		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', tabwriter.AlignRight)
 		fmt.Fprintf(w, "#\tDIGEST\tPLATFORM\tSIZE\tENCRYPTION\tKEY IDS\t\n")
 		for _, layer := range LayerInfos {
@@ -73,4 +80,3 @@ var layerinfoCommand = cli.Command{
 	},
 }
 
-
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index 7334d8a..77e37e3 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -105,7 +105,7 @@ var pushCommand = cli.Command{
 					Recipients:     recipients,
 				},
 			}
-			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int{})
+			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int{}, []string{})
 			if err != nil {
 				return err
 			}
diff --git a/image_store.go b/image_store.go
index f7bc0b0..8af4c4e 100644
--- a/image_store.go
+++ b/image_store.go
@@ -18,7 +18,6 @@ package containerd
 
 import (
 	"context"
-	"fmt"
 
 	imagesapi "github.com/containerd/containerd/api/services/images/v1"
 	"github.com/containerd/containerd/api/types"
@@ -50,9 +49,7 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
-	fmt.Printf("image_store.go: EncryptImage() name=%s\n", name);
-
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platforms []string) (images.Image, error) {
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
@@ -61,6 +58,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 		},
 		Layers: layersToLayers32(layers),
+		Platforms: platforms,
 	});
 	if err != nil {
 		return images.Image{}, errdefs.FromGRPC(err)
@@ -69,7 +67,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platforms []string) (images.Image, error) {
 	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
 	for k, v := range cc.Dc.KeyIdMap {
 		keyIdMap[k] = &imagesapi.DecryptKeyData{
@@ -85,6 +83,7 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, c
 			KeyIdMap: keyIdMap,
 		},
 		Layers: layersToLayers32(layers),
+		Platforms: platforms,
 	});
 	if err != nil {
 		return images.Image{}, errdefs.FromGRPC(err)
@@ -102,10 +101,11 @@ func layersToLayers32(layers []int) []int32 {
 	return layers32
 }
 
-func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]images.LayerInfo, error) {
+func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int, platforms []string) ([]images.LayerInfo, error) {
 	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
 		Name:    name,
 		Layers:  layersToLayers32(layers),
+		Platforms: platforms,
 	});
 	if err != nil {
 		return []images.LayerInfo{}, errdefs.FromGRPC(err)
diff --git a/images/image.go b/images/image.go
index ea9b367..91cf41b 100644
--- a/images/image.go
+++ b/images/image.go
@@ -75,6 +75,13 @@ type LayerInfo struct {
 	Platform string
 }
 
+type LayerFilter struct {
+	// IDs of layers to touch
+	Layers []int
+	// Platforms to touch
+	Platforms []ocispec.Platform
+}
+
 // DeleteOptions provide options on image delete
 type DeleteOptions struct {
 	Synchronous bool
@@ -104,9 +111,9 @@ type Store interface {
 
 	Delete(ctx context.Context, name string, opts ...DeleteOpt) error
 
-	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int) (Image, error)
-	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int) (Image, error)
-	GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]LayerInfo, error)
+	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int, platforms []string) (Image, error)
+	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int, platforms []string) (Image, error)
+	GetImageLayerInfo(ctx context.Context, name string, layers []int, platforms []string) ([]LayerInfo, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -472,7 +479,7 @@ func countLayers(desc []ocispec.Descriptor) int {
 	return c
 }
 
-// needModifyLayer checks whether we need to modify this layer given its number
+// isUserSelectedLayer checks whether we need to modify this layer given its number
 // A layer can be described with its (positive) index number or its negative number, which
 // is counted relative to the last one
 func isUserSelectedLayer(layerNum, layersTotal int, layers []int) bool {
@@ -491,8 +498,25 @@ func isUserSelectedLayer(layerNum, layersTotal int, layers []int) bool {
 	return false
 }
 
+// isUserSelectedPlatform determines whether the platform matches one in
+// the array of user provided platforms
+func isUserSelectedPlatform(platform *ocispec.Platform, platformList []ocispec.Platform) bool {
+	if len(platformList) == 0 {
+		// convenience for the user; none given means 'all'
+		return true
+	}
+	matcher := platforms.NewMatcher(*platform)
+
+	for _, platform := range platformList {
+		if matcher.Match(platform) {
+			return true
+		}
+	}
+	return false
+}
+
 // Encrypt all the Children of a given descriptor
-func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, layers []int, encrypt bool) (ocispec.Descriptor, bool, error) {
+func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool, thisPlatform *ocispec.Platform) (ocispec.Descriptor, bool, error) {
 	layerNum := 0
 
 	children, err := Children(ctx, cs, desc)
@@ -514,7 +538,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			config = child
 		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
 			// this one we can only encrypt
-			if encrypt && isUserSelectedLayer(layerNum, layersTotal, layers) {
+			if encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
 				nl, err := cryptLayer(ctx, cs, child, cc, true)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -527,7 +551,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			layerNum = layerNum + 1
 		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
 			// this one we can only decrypt
-			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, layers) {
+			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
 				nl, err := cryptLayer(ctx, cs, child, cc, false)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -572,7 +596,6 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		fmt.Printf("   old desc %s now written as %s\n", desc.Digest, nDesc.Digest)
 
 		ref := fmt.Sprintf("manifest-%s", nDesc.Digest.String())
-		//, content.WithLabels(labels)
 		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), nDesc, content.WithLabels(labels)); err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to write config")
 		}
@@ -583,7 +606,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 }
 
 // cryptManifestList encrypts or decrypts the children of a top level manifest list
-func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, layers []int, encrypt bool) (ocispec.Descriptor, bool, error) {
+func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
 	if desc.MediaType != MediaTypeDockerSchema2ManifestList {
 		return ocispec.Descriptor{}, false, errors.Wrapf(nil, "Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
 	}
@@ -601,14 +624,14 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	var newManifests []ocispec.Descriptor
 	modified := false
 	for _, manifest := range index.Manifests {
-		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, layers, encrypt)
+		newManifest, m, err := cryptChildren(ctx, cs, manifest, cc, lf, encrypt, manifest.Platform)
 		if err != nil {
 			return ocispec.Descriptor{}, false, err
 		}
-		newManifests = append(newManifests, newManifest)
 		if m {
 			modified = true
 		}
+		newManifests = append(newManifests, newManifest)
 	}
 
 	if modified {
@@ -647,11 +670,11 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
-func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, layers []int, layerNum int) ([]LayerInfo, error) {
+func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int) ([]LayerInfo, error) {
 	var (
 		lis      []LayerInfo
 		tmp      []LayerInfo
-		Platform string
+		platform string
 	)
 
 	switch desc.MediaType {
@@ -659,10 +682,10 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
 		if desc.Platform != nil {
-			Platform = desc.Platform.OS + "/" + desc.Platform.Architecture
-			if desc.Platform.Variant != "" {
-				Platform = Platform + "/" + desc.Platform.Variant
+			if !isUserSelectedPlatform(desc.Platform, lf.Platforms) {
+				return []LayerInfo{}, nil
 			}
+			platform = platforms.Format(*desc.Platform)
 		}
 		if err != nil {
 			return []LayerInfo{}, err
@@ -674,21 +697,21 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		for _, child := range children {
 			if isDescriptorALayer(child) {
 				layerNum = layerNum + 1
-				if isUserSelectedLayer(layerNum, layersTotal, layers) {
-					tmp, err = GetImageLayerInfo(ctx, cs, child, layers, layerNum)
+				if isUserSelectedLayer(layerNum, layersTotal, lf.Layers) {
+					tmp, err = GetImageLayerInfo(ctx, cs, child, lf, layerNum)
 				} else {
 					continue
 				}
 			} else {
-				tmp, err = GetImageLayerInfo(ctx, cs, child, layers, -1)
+				tmp, err = GetImageLayerInfo(ctx, cs, child, lf, -1)
 			}
 			if err != nil {
 				return []LayerInfo{}, err
 			}
 
-			for i := 0; i < len(tmp); i++ {
-				if Platform != "" {
-					tmp[i].Platform = Platform
+			if (platform != "") {
+				for i := 0; i < len(tmp); i++ {
+					tmp[i].Platform = platform
 				}
 			}
 			lis = append(lis, tmp...)
diff --git a/metadata/images.go b/metadata/images.go
index 418f956..8d8ac15 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -28,6 +28,7 @@ import (
 	"github.com/containerd/containerd/filters"
 	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/labels"
+	"github.com/containerd/containerd/platforms"
 	"github.com/containerd/containerd/metadata/boltutil"
 	"github.com/containerd/containerd/namespaces"
 	digest "github.com/opencontainers/go-digest"
@@ -79,7 +80,7 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 
 // cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
 // or updates the existing one
-func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, encrypt bool) (images.Image, error) {
+func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string, encrypt bool) (images.Image, error) {
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -112,7 +113,17 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	fmt.Printf("metadata/images.go: cs = %v\n",cs)
 	fmt.Printf("  high level image.Target is of MediaType %s\n", image.Target.MediaType)
 
-	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, layers, encrypt)
+	pl, err := platforms.ParseArray(platformList)
+	if err != nil {
+		return image, err
+	}
+
+	lf := &images.LayerFilter {
+		Layers:    layers,
+		Platforms: pl,
+	}
+
+	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, lf, encrypt)
 	if err != nil {
 		return image, err
 	}
@@ -188,16 +199,15 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	return image, nil
 }
 
-func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, layers, true)
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, platformList, true)
 }
 
-func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, layers, false)
+func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, platformList, false)
 }
 
-func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int) ([]images.LayerInfo, error) {
-	fmt.Printf("metadata/images.go: GetImageLayerInfo() name=%s\n", name)
+func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int, platformList []string) ([]images.LayerInfo, error) {
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -227,7 +237,17 @@ func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers
 	}
 
 	cs := s.db.ContentStore()
-	return images.GetImageLayerInfo(ctx, cs, image.Target, layers, -1)
+
+	pl, err := platforms.ParseArray(platformList)
+	if err != nil {
+		return []images.LayerInfo{}, err
+	}
+	lf := &images.LayerFilter {
+		Layers:    layers,
+		Platforms: pl,
+	}
+
+	return images.GetImageLayerInfo(ctx, cs, image.Target, lf, -1)
 }
 
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
diff --git a/platforms/platforms.go b/platforms/platforms.go
index 2c2cc11..caa5113 100644
--- a/platforms/platforms.go
+++ b/platforms/platforms.go
@@ -231,6 +231,19 @@ func Parse(specifier string) (specs.Platform, error) {
 	return specs.Platform{}, errors.Wrapf(errdefs.ErrInvalidArgument, "%q: cannot parse platform specifier", specifier)
 }
 
+func ParseArray(specifiers []string) ([]specs.Platform, error) {
+	var speclist []specs.Platform
+
+	for _, specifier := range specifiers {
+		spec, err := Parse(specifier)
+		if err != nil {
+			return []specs.Platform{}, err
+		}
+		speclist = append(speclist, spec)
+	}
+	return speclist, nil
+}
+
 // MustParse is like Parses but panics if the specifier cannot be parsed.
 // Simplifies initialization of global variables.
 func MustParse(specifier string) specs.Platform {
diff --git a/services/images/local.go b/services/images/local.go
index 2006019..76f6bc7 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -18,6 +18,7 @@ package images
 
 import (
 	"context"
+	"fmt"
 
 	eventstypes "github.com/containerd/containerd/api/events"
 	imagesapi "github.com/containerd/containerd/api/services/images/v1"
@@ -191,7 +192,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 			Recipients    : req.Cc.Recipients,
 			GPGPubRingFile: req.Cc.Gpgpubkeyring,
 		},
-	}, layers32ToLayers(req.Layers))
+	}, layers32ToLayers(req.Layers), req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -210,6 +211,8 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest, _ ...grpc.CallOption) (*imagesapi.DecryptImageResponse, error) {
 	log.G(ctx).WithField("name", req.Name).Debugf("decrypt image")
 
+	fmt.Printf("req.Platforms: %s\n", req.Platforms)
+
 	var resp   imagesapi.DecryptImageResponse
 
 	keyIdMap := make(map[uint64]images.DecryptKeyData)
@@ -225,7 +228,7 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 		Dc:	&images.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
-	}, layers32ToLayers(req.Layers))
+	}, layers32ToLayers(req.Layers), req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -246,7 +249,7 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 
 	var resp imagesapi.GetImageLayerInfoResponse
 
-	lis, err := l.store.GetImageLayerInfo(ctx, req.Name, layers32ToLayers(req.Layers))
+	lis, err := l.store.GetImageLayerInfo(ctx, req.Name, layers32ToLayers(req.Layers), req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
-- 
2.7.4


From 9e95665350a0d631b98d07b6af0ab52cfe5e3d5e Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Wed, 25 Jul 2018 17:08:46 -0400
Subject: [PATCH 32/79] Updated passphrase prompt with more key information

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 cmd/ctr/commands/images/decrypt.go | 52 ++++++++++++++++++++++++--------------
 1 file changed, 33 insertions(+), 19 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 6103ccb..9ceceae 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -17,9 +17,9 @@
 package images
 
 import (
+	"fmt"
 	"io/ioutil"
 	"os/exec"
-	"fmt"
 	"syscall"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
@@ -47,7 +47,7 @@ var decryptCommand = cli.Command{
 	}),
 	Action: func(context *cli.Context) error {
 		var (
-			local = context.Args().First()
+			local   = context.Args().First()
 			newName = context.Args().Get(1)
 		)
 		fmt.Printf("pl: %s\n", context.StringSlice("platform"))
@@ -57,7 +57,7 @@ var decryptCommand = cli.Command{
 		if newName != "" {
 			fmt.Printf("Decrypting %s to %s\n", local, newName)
 		} else {
-			fmt.Printf("Decrypting %s and replacing it with the decrypted image\n", local);
+			fmt.Printf("Decrypting %s and replacing it with the decrypted image\n", local)
 		}
 		client, ctx, cancel, err := commands.NewClient(context)
 		if err != nil {
@@ -93,13 +93,16 @@ var decryptCommand = cli.Command{
 					break
 				}
 				// do we have this key?
-				haveKey, _ := HaveGPGPrivateKey(keyid)
+				keyinfo, haveKey, err := GetSecretKeyDetails(keyid)
 				// this may fail if the key is not here; we ignore the error
 				if !haveKey {
 					// key not on this system
 					continue
 				}
-				fmt.Printf("Enter password for key with Id 0x%x: ", keyid)
+
+				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
+				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
+
 				password, err := terminal.ReadPassword(int(syscall.Stdin))
 				fmt.Printf("\n")
 				if err != nil {
@@ -122,7 +125,7 @@ var decryptCommand = cli.Command{
 		}
 		fmt.Printf("\n")
 		_, err = client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
-			Dc: &images.DecryptConfig {
+			Dc: &images.DecryptConfig{
 				KeyIdMap: keyIdMap,
 			},
 		}, context.IntSlice("layer"), context.StringSlice("platform"))
@@ -130,43 +133,55 @@ var decryptCommand = cli.Command{
 	},
 }
 
-func HaveGPGPrivateKey(keyid uint64) (bool, error) {
-	args := append([]string{"-K"}, fmt.Sprintf("0x%x", keyid))
+// GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
+func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
+	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
 
 	cmd := exec.Command("gpg2", args...)
 
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, err
+	}
 	if err := cmd.Start(); err != nil {
-		return false, err
+		return nil, err
 	}
 
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
 	if err := cmd.Wait(); err != nil {
-		return false, err
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
-	return true, nil
+
+	return keydata, err2
 }
 
-func GetGPGPrivateKey (keyid uint64, password string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--passphrase", password,"--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+// GetSecretKeyDetails retrives the secret key details of key with keyid.
+// returns a byte array of the details and a bool if the key exists
+func GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
+	args := append([]string{"-K"}, fmt.Sprintf("0x%x", keyid))
 
 	cmd := exec.Command("gpg2", args...)
 
 	stdout, err := cmd.StdoutPipe()
 	stderr, err := cmd.StderrPipe()
 	if err != nil {
-		return nil, err
+		return nil, false, err
 	}
 	if err := cmd.Start(); err != nil {
-		return nil, err
+		return nil, false, err
 	}
 
 	keydata, err2 := ioutil.ReadAll(stdout)
 	message, _ := ioutil.ReadAll(stderr)
 
 	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
+		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
 
-	return keydata, err2
+	return keydata, err2 == nil, err2
 }
 
 func addToSet(set, add []uint64) []uint64 {
@@ -175,7 +190,7 @@ func addToSet(set, add []uint64) []uint64 {
 		for j := 0; j < len(set); j++ {
 			if set[j] == add[i] {
 				found = true
-				break;
+				break
 			}
 		}
 		if !found {
@@ -184,4 +199,3 @@ func addToSet(set, add []uint64) []uint64 {
 	}
 	return set
 }
-
-- 
2.7.4


From 643e60e4c7c768a1d215b8c8f3c084af00438d3c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 25 Jul 2018 19:51:38 -0400
Subject: [PATCH 33/79] Add --remove option to remove recipients as part of
 'images encrypt'

---
 api/next.pb.txt                     |   7 ++
 api/services/images/v1/images.pb.go | 162 +++++++++++++++++++++---------------
 api/services/images/v1/images.proto |   1 +
 cmd/ctr/commands/images/encrypt.go  |  10 +++
 image_store.go                      |   1 +
 images/encryption.go                |  29 ++++++-
 images/image.go                     | 113 ++++++++++++++++++-------
 images/openpgp.go                   |  20 +++++
 services/images/local.go            |   1 +
 9 files changed, 244 insertions(+), 100 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 725868b..341d7b0 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2234,6 +2234,13 @@ file {
       type: TYPE_BYTES
       json_name: "gpgpubkeyring"
     }
+    field {
+      name: "operation"
+      number: 3
+      label: LABEL_OPTIONAL
+      type: TYPE_INT32
+      json_name: "operation"
+    }
   }
   message_type {
     name: "DecryptKeyData"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 239eaf8..d2916ee 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -186,6 +186,7 @@ func (*DeleteImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorI
 type EncryptConfig struct {
 	Recipients    []string `protobuf:"bytes,1,rep,name=recipients" json:"recipients,omitempty"`
 	Gpgpubkeyring []byte   `protobuf:"bytes,2,opt,name=gpgpubkeyring,proto3" json:"gpgpubkeyring,omitempty"`
+	Operation     int32    `protobuf:"varint,3,opt,name=operation,proto3" json:"operation,omitempty"`
 }
 
 func (m *EncryptConfig) Reset()                    { *m = EncryptConfig{} }
@@ -992,6 +993,11 @@ func (m *EncryptConfig) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.Gpgpubkeyring)))
 		i += copy(dAtA[i:], m.Gpgpubkeyring)
 	}
+	if m.Operation != 0 {
+		dAtA[i] = 0x18
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(m.Operation))
+	}
 	return i, nil
 }
 
@@ -1557,6 +1563,9 @@ func (m *EncryptConfig) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
+	if m.Operation != 0 {
+		n += 1 + sovImages(uint64(m.Operation))
+	}
 	return n
 }
 
@@ -1873,6 +1882,7 @@ func (this *EncryptConfig) String() string {
 	s := strings.Join([]string{`&EncryptConfig{`,
 		`Recipients:` + fmt.Sprintf("%v", this.Recipients) + `,`,
 		`Gpgpubkeyring:` + fmt.Sprintf("%v", this.Gpgpubkeyring) + `,`,
+		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -3151,6 +3161,25 @@ func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
 				m.Gpgpubkeyring = []byte{}
 			}
 			iNdEx = postIndex
+		case 3:
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
+			}
+			m.Operation = 0
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				m.Operation |= (int32(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -4668,74 +4697,75 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 1094 bytes of a gzipped FileDescriptorProto
+	// 1107 bytes of a gzipped FileDescriptorProto
 	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
 	0x10, 0x36, 0xa9, 0x1f, 0x5b, 0x23, 0xbb, 0x49, 0x36, 0x86, 0xc1, 0xb2, 0xa9, 0x2c, 0x10, 0x29,
 	0xa0, 0x43, 0x43, 0xd5, 0xca, 0xa1, 0xa9, 0x1d, 0x14, 0x8d, 0x2d, 0x27, 0x35, 0xe2, 0x04, 0x05,
-	0xf3, 0x53, 0xa3, 0x97, 0x80, 0x26, 0x57, 0xec, 0x56, 0x12, 0xc9, 0x72, 0x57, 0x36, 0xd8, 0x53,
+	0x93, 0xa6, 0x46, 0x2f, 0x01, 0x4d, 0xae, 0x58, 0x56, 0x12, 0xc9, 0x72, 0x57, 0x36, 0xd8, 0x53,
 	0x4f, 0xbd, 0xb6, 0x40, 0x1f, 0xa3, 0x0f, 0xd0, 0x57, 0xf0, 0xb1, 0x40, 0x2f, 0x3d, 0xa5, 0x8d,
-	0x0f, 0x7d, 0x8e, 0x82, 0xbb, 0x4b, 0x8b, 0x94, 0xd4, 0x50, 0x8a, 0x7d, 0x9b, 0x59, 0xce, 0xf7,
-	0xcd, 0xec, 0xb7, 0xbb, 0xb3, 0x4b, 0xe8, 0x7a, 0x84, 0x7d, 0x3b, 0x3a, 0x36, 0x9d, 0x60, 0xd8,
-	0x76, 0x02, 0x9f, 0xd9, 0xc4, 0xc7, 0x91, 0x9b, 0x35, 0xed, 0x90, 0xb4, 0x29, 0x8e, 0x4e, 0x88,
-	0x83, 0x69, 0x9b, 0x0c, 0x6d, 0x0f, 0xd3, 0xf6, 0xc9, 0x96, 0xb4, 0xcc, 0x30, 0x0a, 0x58, 0x80,
-	0x3e, 0x1c, 0xc7, 0x9b, 0x69, 0xac, 0x29, 0x23, 0x4e, 0xb6, 0xf4, 0x75, 0x2f, 0xf0, 0x02, 0x1e,
-	0xd9, 0x4e, 0x2c, 0x01, 0xd2, 0x3f, 0xf0, 0x82, 0xc0, 0x1b, 0xe0, 0x36, 0xf7, 0x8e, 0x47, 0xbd,
-	0x36, 0x1e, 0x86, 0x2c, 0x96, 0x1f, 0x9b, 0x93, 0x1f, 0x7b, 0x04, 0x0f, 0xdc, 0x57, 0x43, 0x9b,
-	0xf6, 0x65, 0xc4, 0xe6, 0x64, 0x04, 0x23, 0x43, 0x4c, 0x99, 0x3d, 0x0c, 0x65, 0xc0, 0xce, 0x5c,
-	0x53, 0x63, 0x71, 0x88, 0x69, 0xdb, 0xc5, 0xd4, 0x89, 0x48, 0xc8, 0x82, 0x48, 0x80, 0x8d, 0x7f,
-	0x55, 0xa8, 0x1c, 0x24, 0x13, 0x40, 0x08, 0xca, 0xbe, 0x3d, 0xc4, 0x9a, 0xd2, 0x54, 0x5a, 0x35,
-	0x8b, 0xdb, 0xe8, 0x4b, 0xa8, 0x0e, 0xec, 0x63, 0x3c, 0xa0, 0x9a, 0xda, 0x2c, 0xb5, 0xea, 0x9d,
-	0x4f, 0xcc, 0xb7, 0x0a, 0x60, 0x72, 0x26, 0xf3, 0x90, 0x43, 0xf6, 0x7d, 0x16, 0xc5, 0x96, 0xc4,
-	0xa3, 0x6d, 0xa8, 0x32, 0x3b, 0xf2, 0x30, 0xd3, 0x4a, 0x4d, 0xa5, 0x55, 0xef, 0xdc, 0xca, 0x32,
-	0xf1, 0xda, 0xcc, 0xee, 0x45, 0x6d, 0xbb, 0xe5, 0xb3, 0xd7, 0x9b, 0x4b, 0x96, 0x44, 0xa0, 0x3d,
-	0x00, 0x27, 0xc2, 0x36, 0xc3, 0xee, 0x2b, 0x9b, 0x69, 0xcb, 0x1c, 0xaf, 0x9b, 0x42, 0x16, 0x33,
-	0x95, 0xc5, 0x7c, 0x9e, 0xca, 0xb2, 0xbb, 0x92, 0xa0, 0x7f, 0xf9, 0x7b, 0x53, 0xb1, 0x6a, 0x12,
-	0xf7, 0x80, 0x93, 0x8c, 0x42, 0x37, 0x25, 0x59, 0x59, 0x84, 0x44, 0xe2, 0x1e, 0x30, 0xfd, 0x33,
-	0xa8, 0x67, 0x26, 0x87, 0xae, 0x43, 0xa9, 0x8f, 0x63, 0xa9, 0x58, 0x62, 0xa2, 0x75, 0xa8, 0x9c,
-	0xd8, 0x83, 0x11, 0xd6, 0x54, 0x3e, 0x26, 0x9c, 0x6d, 0xf5, 0x9e, 0x62, 0x7c, 0x04, 0xd7, 0x1e,
-	0x61, 0xc6, 0x05, 0xb2, 0xf0, 0xf7, 0x23, 0x4c, 0xd9, 0x2c, 0xc5, 0x8d, 0xa7, 0x70, 0x7d, 0x1c,
-	0x46, 0xc3, 0xc0, 0xa7, 0x18, 0x6d, 0x43, 0x85, 0x4b, 0xcc, 0x03, 0xeb, 0x9d, 0xdb, 0xf3, 0x2c,
-	0x82, 0x25, 0x20, 0xc6, 0x4b, 0x40, 0x7b, 0x5c, 0x83, 0x5c, 0xe6, 0x2f, 0xde, 0x81, 0x51, 0x2e,
-	0x8a, 0xe4, 0xfd, 0x1a, 0x6e, 0xe6, 0x78, 0x65, 0xa9, 0x97, 0x27, 0xfe, 0x55, 0x01, 0xf4, 0x82,
-	0x0b, 0x7e, 0xb5, 0x15, 0xa3, 0x1d, 0xa8, 0x8b, 0x85, 0xe4, 0x87, 0x8b, 0x2f, 0xd0, 0xac, 0x1d,
-	0xf0, 0x30, 0x39, 0x7f, 0x4f, 0x6c, 0xda, 0xb7, 0xe4, 0x7e, 0x49, 0xec, 0x64, 0xba, 0xb9, 0xa2,
-	0xae, 0x6c, 0xba, 0x77, 0xe0, 0xc6, 0x21, 0xa1, 0x62, 0xc1, 0x69, 0x3a, 0x59, 0x0d, 0x96, 0x7b,
-	0x64, 0xc0, 0x70, 0x44, 0x35, 0xa5, 0x59, 0x6a, 0xd5, 0xac, 0xd4, 0x35, 0x8e, 0x00, 0x65, 0xc3,
-	0x65, 0x19, 0xbb, 0x50, 0x15, 0x49, 0x78, 0xf8, 0x62, 0x75, 0x48, 0xa4, 0x71, 0x1f, 0x50, 0x17,
-	0x0f, 0xf0, 0x84, 0xec, 0xb3, 0x9a, 0x02, 0x82, 0x32, 0x8d, 0x7d, 0x87, 0x2b, 0xb8, 0x62, 0x71,
-	0xdb, 0x78, 0x01, 0x6b, 0xfb, 0xbe, 0x13, 0xc5, 0x21, 0xdb, 0x0b, 0xfc, 0x1e, 0xf1, 0x50, 0x03,
-	0x20, 0xc2, 0x0e, 0x09, 0x09, 0xf6, 0x59, 0x3a, 0x8b, 0xcc, 0x08, 0xba, 0x0d, 0x6b, 0x5e, 0xe8,
-	0x85, 0xa3, 0xe3, 0x3e, 0x8e, 0x23, 0xe2, 0x7b, 0x9c, 0x6d, 0xd5, 0xca, 0x0f, 0x1a, 0xcf, 0xe1,
-	0xbd, 0x2e, 0xe6, 0xb4, 0x8f, 0x71, 0xdc, 0xb5, 0x99, 0x9d, 0x48, 0xd3, 0x17, 0x26, 0xaf, 0x69,
-	0xd5, 0x4a, 0x5d, 0xd4, 0x82, 0x6b, 0xd2, 0xfc, 0xca, 0xa6, 0xf4, 0x34, 0x88, 0x5c, 0xc9, 0x39,
-	0x39, 0x6c, 0xfc, 0xa9, 0xc0, 0x9a, 0xa4, 0x95, 0xd5, 0xbe, 0x84, 0x95, 0x3e, 0x8e, 0x0f, 0xdc,
-	0x27, 0x76, 0x28, 0x25, 0xdc, 0x2e, 0x90, 0x30, 0x87, 0x37, 0x1f, 0x4b, 0xb0, 0xe8, 0x79, 0x17,
-	0x5c, 0xfa, 0x77, 0xb0, 0x96, 0xfb, 0x94, 0xed, 0x18, 0x65, 0xd1, 0x31, 0xf6, 0xb2, 0x1d, 0xa3,
-	0xde, 0xb9, 0x33, 0x5f, 0x5e, 0x29, 0x47, 0xb6, 0xc1, 0xfc, 0xae, 0xc0, 0x4d, 0xb9, 0x06, 0x85,
-	0x4b, 0xa8, 0xc1, 0xb2, 0x8f, 0x4f, 0x9f, 0x26, 0xc3, 0xa2, 0x51, 0xa5, 0x2e, 0xba, 0x0f, 0xaa,
-	0xe3, 0xc8, 0x1e, 0xfd, 0x71, 0x41, 0x2d, 0xb9, 0x15, 0xb7, 0x54, 0xc7, 0x41, 0x1b, 0xc9, 0x7d,
-	0x11, 0x27, 0xfb, 0xb6, 0xdc, 0x2c, 0xb5, 0x2a, 0x96, 0xf4, 0xd0, 0x2d, 0xa8, 0x85, 0x03, 0x9b,
-	0xf5, 0x82, 0x68, 0x48, 0xb5, 0x0a, 0xdf, 0x0c, 0xe3, 0x01, 0xe3, 0x08, 0xd6, 0xf3, 0x85, 0x5f,
-	0xd9, 0xe9, 0x4a, 0x34, 0x91, 0x8a, 0x5d, 0x4e, 0x13, 0x77, 0x5e, 0x4d, 0x72, 0xfb, 0xc2, 0x52,
-	0xdd, 0x4b, 0x68, 0x92, 0x2f, 0xfc, 0xca, 0x34, 0x71, 0x41, 0x4b, 0x6f, 0x98, 0xc3, 0xa4, 0x92,
-	0x03, 0xbf, 0x17, 0xbc, 0x4d, 0x97, 0x71, 0xfd, 0xea, 0xff, 0xd7, 0x5f, 0x9a, 0xac, 0xff, 0x37,
-	0x05, 0x6a, 0x17, 0xf4, 0x68, 0x03, 0x54, 0xe2, 0x72, 0xd6, 0xb5, 0xdd, 0xea, 0xf9, 0xeb, 0x4d,
-	0xf5, 0xa0, 0x6b, 0xa9, 0xc4, 0x4d, 0xb8, 0xf9, 0x59, 0x11, 0xdc, 0x65, 0x4b, 0x7a, 0xc9, 0xb8,
-	0x4b, 0x3c, 0x4c, 0xc5, 0x6b, 0xa1, 0x66, 0x49, 0x2f, 0xe9, 0x2a, 0x58, 0xec, 0x14, 0x12, 0xf8,
-	0x5a, 0x99, 0x7f, 0xcb, 0x8c, 0x20, 0x1d, 0x56, 0x7a, 0x64, 0x80, 0x9f, 0x91, 0x1f, 0xb0, 0x56,
-	0x69, 0x2a, 0xad, 0x92, 0x75, 0xe1, 0x27, 0xdf, 0xd2, 0xf2, 0xb4, 0x2a, 0x47, 0x5e, 0xf8, 0x86,
-	0x03, 0xef, 0xcf, 0xd0, 0x44, 0x4a, 0xfe, 0x10, 0x6a, 0x83, 0x74, 0x50, 0x76, 0x87, 0x56, 0x81,
-	0xec, 0x63, 0x92, 0x31, 0xb4, 0xf3, 0xf3, 0x32, 0x54, 0x45, 0xe3, 0x46, 0x3d, 0x28, 0x3d, 0xc2,
-	0x0c, 0x99, 0x05, 0x34, 0x13, 0x0f, 0x06, 0xbd, 0x3d, 0x77, 0xbc, 0x2c, 0xbd, 0x0f, 0xe5, 0xe4,
-	0xba, 0x40, 0x45, 0xef, 0xb6, 0xa9, 0x2b, 0x48, 0xdf, 0x5a, 0x00, 0x21, 0x93, 0x05, 0x50, 0x15,
-	0x4f, 0x02, 0x54, 0x04, 0x9e, 0x7e, 0x91, 0xe8, 0x9d, 0x45, 0x20, 0xe3, 0x84, 0xe2, 0x52, 0x2e,
-	0x4c, 0x38, 0xfd, 0xa0, 0x28, 0x4c, 0x38, 0xeb, 0xba, 0x7f, 0x06, 0x55, 0x71, 0x47, 0x16, 0x26,
-	0x9c, 0xbe, 0x4a, 0xf5, 0x8d, 0xa9, 0xa7, 0xc6, 0x7e, 0xf2, 0x1f, 0x80, 0x4e, 0x61, 0x35, 0xdb,
-	0xfd, 0x50, 0x67, 0xbe, 0xae, 0x9b, 0xe3, 0xbe, 0xbb, 0x10, 0x46, 0xce, 0xe6, 0x14, 0x56, 0xb3,
-	0x2d, 0xa6, 0x30, 0xf1, 0x8c, 0x46, 0x5a, 0x98, 0x78, 0x66, 0x0f, 0xfb, 0x49, 0x81, 0x1b, 0x53,
-	0xc7, 0x0d, 0x7d, 0x3a, 0xe7, 0xe6, 0x9e, 0x6c, 0x5a, 0xfa, 0xbd, 0xc5, 0x81, 0xa2, 0x90, 0xdd,
-	0xa3, 0xb3, 0x37, 0x8d, 0xa5, 0xbf, 0xde, 0x34, 0x96, 0x7e, 0x3c, 0x6f, 0x28, 0x67, 0xe7, 0x0d,
-	0xe5, 0x8f, 0xf3, 0x86, 0xf2, 0xcf, 0x79, 0x43, 0xf9, 0xe6, 0xf3, 0x77, 0xfc, 0x5d, 0xdc, 0x11,
-	0xd6, 0xd1, 0xd2, 0x71, 0x95, 0x2f, 0xf3, 0xdd, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x82,
-	0xc8, 0xdb, 0x79, 0x0e, 0x00, 0x00,
+	0x0f, 0x7d, 0x8e, 0x62, 0x7f, 0x68, 0x91, 0x92, 0x12, 0x4a, 0xb1, 0x6f, 0x3b, 0xc3, 0xf9, 0x66,
+	0x66, 0xbf, 0xdd, 0xfd, 0x76, 0x09, 0x5d, 0xcf, 0xa7, 0xdf, 0x8d, 0x8e, 0x4d, 0x27, 0x1c, 0xb6,
+	0x9d, 0x30, 0xa0, 0xb6, 0x1f, 0xe0, 0xd8, 0xcd, 0x0e, 0xed, 0xc8, 0x6f, 0x13, 0x1c, 0x9f, 0xf8,
+	0x0e, 0x26, 0x6d, 0x7f, 0x68, 0x7b, 0x98, 0xb4, 0x4f, 0xb6, 0xe4, 0xc8, 0x8c, 0xe2, 0x90, 0x86,
+	0xe8, 0xc3, 0x71, 0xbc, 0x99, 0xc6, 0x9a, 0x32, 0xe2, 0x64, 0x4b, 0x5f, 0xf7, 0x42, 0x2f, 0xe4,
+	0x91, 0x6d, 0x36, 0x12, 0x20, 0xfd, 0x03, 0x2f, 0x0c, 0xbd, 0x01, 0x6e, 0x73, 0xeb, 0x78, 0xd4,
+	0x6b, 0xe3, 0x61, 0x44, 0x13, 0xf9, 0xb1, 0x39, 0xf9, 0xb1, 0xe7, 0xe3, 0x81, 0xfb, 0x72, 0x68,
+	0x93, 0xbe, 0x8c, 0xd8, 0x9c, 0x8c, 0xa0, 0xfe, 0x10, 0x13, 0x6a, 0x0f, 0x23, 0x19, 0xb0, 0x33,
+	0xd7, 0xd4, 0x68, 0x12, 0x61, 0xd2, 0x76, 0x31, 0x71, 0x62, 0x3f, 0xa2, 0x61, 0x2c, 0xc0, 0xc6,
+	0x7f, 0x2a, 0x54, 0x0e, 0xd8, 0x04, 0x10, 0x82, 0x72, 0x60, 0x0f, 0xb1, 0xa6, 0x34, 0x95, 0x56,
+	0xcd, 0xe2, 0x63, 0xf4, 0x25, 0x54, 0x07, 0xf6, 0x31, 0x1e, 0x10, 0x4d, 0x6d, 0x96, 0x5a, 0xf5,
+	0xce, 0x27, 0xe6, 0x5b, 0x09, 0x30, 0x79, 0x26, 0xf3, 0x90, 0x43, 0xf6, 0x03, 0x1a, 0x27, 0x96,
+	0xc4, 0xa3, 0x6d, 0xa8, 0x52, 0x3b, 0xf6, 0x30, 0xd5, 0x4a, 0x4d, 0xa5, 0x55, 0xef, 0xdc, 0xca,
+	0x66, 0xe2, 0xbd, 0x99, 0xdd, 0x8b, 0xde, 0x76, 0xcb, 0x67, 0xaf, 0x36, 0x97, 0x2c, 0x89, 0x40,
+	0x7b, 0x00, 0x4e, 0x8c, 0x6d, 0x8a, 0xdd, 0x97, 0x36, 0xd5, 0x96, 0x39, 0x5e, 0x37, 0x05, 0x2d,
+	0x66, 0x4a, 0x8b, 0xf9, 0x3c, 0xa5, 0x65, 0x77, 0x85, 0xa1, 0x7f, 0xfd, 0x67, 0x53, 0xb1, 0x6a,
+	0x12, 0xf7, 0x80, 0x27, 0x19, 0x45, 0x6e, 0x9a, 0x64, 0x65, 0x91, 0x24, 0x12, 0xf7, 0x80, 0xea,
+	0x9f, 0x41, 0x3d, 0x33, 0x39, 0x74, 0x1d, 0x4a, 0x7d, 0x9c, 0x48, 0xc6, 0xd8, 0x10, 0xad, 0x43,
+	0xe5, 0xc4, 0x1e, 0x8c, 0xb0, 0xa6, 0x72, 0x9f, 0x30, 0xb6, 0xd5, 0x7b, 0x8a, 0xf1, 0x11, 0x5c,
+	0x7b, 0x84, 0x29, 0x27, 0xc8, 0xc2, 0x3f, 0x8c, 0x30, 0xa1, 0xb3, 0x18, 0x37, 0x9e, 0xc2, 0xf5,
+	0x71, 0x18, 0x89, 0xc2, 0x80, 0x60, 0xb4, 0x0d, 0x15, 0x4e, 0x31, 0x0f, 0xac, 0x77, 0x6e, 0xcf,
+	0xb3, 0x08, 0x96, 0x80, 0x18, 0x2f, 0x00, 0xed, 0x71, 0x0e, 0x72, 0x95, 0xbf, 0x78, 0x87, 0x8c,
+	0x72, 0x51, 0x64, 0xde, 0x6f, 0xe0, 0x66, 0x2e, 0xaf, 0x6c, 0xf5, 0xf2, 0x89, 0x7f, 0x53, 0x00,
+	0x7d, 0xcd, 0x09, 0xbf, 0xda, 0x8e, 0xd1, 0x0e, 0xd4, 0xc5, 0x42, 0xf2, 0xc3, 0xc5, 0x17, 0x68,
+	0xd6, 0x0e, 0x78, 0xc8, 0xce, 0xdf, 0x13, 0x9b, 0xf4, 0x2d, 0xb9, 0x5f, 0xd8, 0x98, 0x4d, 0x37,
+	0xd7, 0xd4, 0x95, 0x4d, 0xf7, 0x0e, 0xdc, 0x38, 0xf4, 0x89, 0x58, 0x70, 0x92, 0x4e, 0x56, 0x83,
+	0xe5, 0x9e, 0x3f, 0xa0, 0x38, 0x26, 0x9a, 0xd2, 0x2c, 0xb5, 0x6a, 0x56, 0x6a, 0x1a, 0x47, 0x80,
+	0xb2, 0xe1, 0xb2, 0x8d, 0x5d, 0xa8, 0x8a, 0x22, 0x3c, 0x7c, 0xb1, 0x3e, 0x24, 0xd2, 0xb8, 0x0f,
+	0xa8, 0x8b, 0x07, 0x78, 0x82, 0xf6, 0x59, 0xa2, 0x80, 0xa0, 0x4c, 0x92, 0xc0, 0xe1, 0x0c, 0xae,
+	0x58, 0x7c, 0x6c, 0x10, 0x58, 0xdb, 0x0f, 0x9c, 0x38, 0x89, 0xe8, 0x5e, 0x18, 0xf4, 0x7c, 0x0f,
+	0x35, 0x00, 0x62, 0xec, 0xf8, 0x91, 0x8f, 0x03, 0x9a, 0xce, 0x22, 0xe3, 0x41, 0xb7, 0x61, 0xcd,
+	0x8b, 0xbc, 0x68, 0x74, 0xdc, 0xc7, 0x49, 0xec, 0x07, 0x1e, 0xcf, 0xb6, 0x6a, 0xe5, 0x9d, 0xe8,
+	0x16, 0xd4, 0xc2, 0x08, 0xc7, 0x36, 0xf5, 0xc3, 0x80, 0x0b, 0x47, 0xc5, 0x1a, 0x3b, 0x8c, 0xe7,
+	0xf0, 0x5e, 0x17, 0xf3, 0xa2, 0x8f, 0x71, 0xd2, 0xb5, 0xa9, 0xcd, 0x88, 0xeb, 0x8b, 0x21, 0xef,
+	0x78, 0xd5, 0x4a, 0x4d, 0xd4, 0x82, 0x6b, 0x72, 0xf8, 0x95, 0x4d, 0xc8, 0x69, 0x18, 0xbb, 0xb2,
+	0xe2, 0xa4, 0xdb, 0xf8, 0x4b, 0x81, 0x35, 0x99, 0x56, 0xce, 0xe5, 0x05, 0xac, 0xf4, 0x71, 0x72,
+	0xe0, 0x3e, 0xb1, 0x23, 0x49, 0xf0, 0x76, 0x01, 0xc1, 0x39, 0xbc, 0xf9, 0x58, 0x82, 0x85, 0x22,
+	0x5e, 0xe4, 0xd2, 0xbf, 0x87, 0xb5, 0xdc, 0xa7, 0xac, 0x9e, 0x94, 0x85, 0x9e, 0xec, 0x65, 0xf5,
+	0xa4, 0xde, 0xb9, 0x33, 0x5f, 0x5d, 0x49, 0x47, 0x56, 0x7e, 0xfe, 0x50, 0xe0, 0xa6, 0x5c, 0xa1,
+	0xc2, 0x05, 0xd6, 0x60, 0x39, 0xc0, 0xa7, 0x4f, 0x99, 0x5b, 0xc8, 0x58, 0x6a, 0xa2, 0xfb, 0xa0,
+	0x3a, 0x8e, 0x54, 0xf0, 0x8f, 0x0b, 0x7a, 0xc9, 0xed, 0x07, 0x4b, 0x75, 0x1c, 0xb4, 0xc1, 0x6e,
+	0x93, 0x84, 0xed, 0xea, 0x72, 0xb3, 0xd4, 0xaa, 0x58, 0xd2, 0x62, 0xab, 0x1c, 0x0d, 0x6c, 0xda,
+	0x0b, 0xe3, 0x21, 0xd1, 0x2a, 0x7c, 0xab, 0x8c, 0x1d, 0xc6, 0x11, 0xac, 0xe7, 0x1b, 0xbf, 0xb2,
+	0xb3, 0xc7, 0x38, 0x91, 0x8c, 0x5d, 0x8e, 0x13, 0x77, 0x5e, 0x4e, 0x72, 0xfb, 0xc2, 0x52, 0xdd,
+	0x4b, 0x70, 0x92, 0x6f, 0xfc, 0xca, 0x38, 0x71, 0x41, 0x4b, 0xef, 0x9f, 0x43, 0xd6, 0xc9, 0x41,
+	0xd0, 0x0b, 0xdf, 0xc6, 0xcb, 0xb8, 0x7f, 0xf5, 0xcd, 0xfd, 0x97, 0x26, 0xfb, 0xff, 0x5d, 0x81,
+	0xda, 0x45, 0x7a, 0xb4, 0x01, 0xaa, 0xef, 0xf2, 0xac, 0x6b, 0xbb, 0xd5, 0xf3, 0x57, 0x9b, 0xea,
+	0x41, 0xd7, 0x52, 0x7d, 0x97, 0xe5, 0xe6, 0x67, 0x45, 0xe4, 0x2e, 0x5b, 0xd2, 0x62, 0x7e, 0xd7,
+	0xf7, 0x30, 0x11, 0x6f, 0x89, 0x9a, 0x25, 0x2d, 0xa6, 0x39, 0x58, 0xec, 0x14, 0x26, 0x17, 0x65,
+	0xfe, 0x2d, 0xe3, 0x41, 0x3a, 0xac, 0xf4, 0xfc, 0x01, 0x7e, 0xe6, 0xff, 0x88, 0xb5, 0x4a, 0x53,
+	0x69, 0x95, 0xac, 0x0b, 0x9b, 0x7d, 0x4b, 0xdb, 0xd3, 0xaa, 0x1c, 0x79, 0x61, 0x1b, 0x0e, 0xbc,
+	0x3f, 0x83, 0x13, 0x49, 0xf9, 0x43, 0xa8, 0x0d, 0x52, 0xa7, 0x54, 0x87, 0x56, 0x01, 0xed, 0xe3,
+	0x24, 0x63, 0x68, 0xe7, 0x97, 0x65, 0xa8, 0x0a, 0x59, 0x47, 0x3d, 0x28, 0x3d, 0xc2, 0x14, 0x99,
+	0x05, 0x69, 0x26, 0x9e, 0x13, 0x7a, 0x7b, 0xee, 0x78, 0xd9, 0x7a, 0x1f, 0xca, 0xec, 0x32, 0x41,
+	0x45, 0xaf, 0xba, 0xa9, 0x0b, 0x4a, 0xdf, 0x5a, 0x00, 0x21, 0x8b, 0x85, 0x50, 0x15, 0x0f, 0x06,
+	0x54, 0x04, 0x9e, 0x7e, 0xaf, 0xe8, 0x9d, 0x45, 0x20, 0xe3, 0x82, 0xe2, 0xca, 0x2e, 0x2c, 0x38,
+	0xfd, 0xdc, 0x28, 0x2c, 0x38, 0xeb, 0x31, 0xf0, 0x0c, 0xaa, 0xe2, 0x06, 0x2d, 0x2c, 0x38, 0x7d,
+	0xd1, 0xea, 0x1b, 0x53, 0x0f, 0x91, 0x7d, 0xf6, 0x97, 0x80, 0x4e, 0x61, 0x35, 0xab, 0x7e, 0xa8,
+	0x33, 0x9f, 0xea, 0xe6, 0x72, 0xdf, 0x5d, 0x08, 0x23, 0x67, 0x73, 0x0a, 0xab, 0x59, 0x89, 0x29,
+	0x2c, 0x3c, 0x43, 0x48, 0x0b, 0x0b, 0xcf, 0xd4, 0xb0, 0x9f, 0x15, 0xb8, 0x31, 0x75, 0xdc, 0xd0,
+	0xa7, 0x73, 0x6e, 0xee, 0x49, 0xd1, 0xd2, 0xef, 0x2d, 0x0e, 0x14, 0x8d, 0xec, 0x1e, 0x9d, 0xbd,
+	0x6e, 0x2c, 0xfd, 0xfd, 0xba, 0xb1, 0xf4, 0xd3, 0x79, 0x43, 0x39, 0x3b, 0x6f, 0x28, 0x7f, 0x9e,
+	0x37, 0x94, 0x7f, 0xcf, 0x1b, 0xca, 0xb7, 0x9f, 0xbf, 0xe3, 0xcf, 0xe4, 0x8e, 0x18, 0x1d, 0x2d,
+	0x1d, 0x57, 0xf9, 0x32, 0xdf, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xb0, 0xe3, 0xa2, 0x97,
+	0x0e, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index ef29246..0422309 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -134,6 +134,7 @@ message DeleteImageRequest {
 message EncryptConfig {
 	repeated string recipients = 1;
 	bytes gpgpubkeyring = 2;
+	int32 operation = 3;
 }
 
 message DecryptKeyData {
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 9eec73a..75b38da 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -42,6 +42,9 @@ var encryptCommand = cli.Command{
 	}, cli.StringSliceFlag{
 		Name:  "platform",
 		Usage: "For which platform to encrypt; by default encrytion is done for all platforms",
+	}, cli.BoolFlag{
+		Name:  "remove",
+		Usage: "Remove the given set of recipients",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -71,10 +74,17 @@ var encryptCommand = cli.Command{
 		if err != nil {
 			return err
 		}
+
+		operation := images.OPERATION_ADD_RECIPIENTS
+		if context.Bool("remove") {
+			operation = images.OPERATION_REMOVE_RECIPIENTS
+		}
+
 		cc := &images.CryptoConfig{
 			Ec:	&images.EncryptConfig{
 				GPGPubRingFile: gpgPubRingFile,
 				Recipients:     recipients,
+				Operation:      operation,
 			},
 		}
 		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, context.IntSlice("layer"), context.StringSlice("platform"))
diff --git a/image_store.go b/image_store.go
index 8af4c4e..d786eac 100644
--- a/image_store.go
+++ b/image_store.go
@@ -56,6 +56,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 		Cc:      &imagesapi.EncryptConfig{
 			Recipients   : cc.Ec.Recipients,
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
+			Operation    : cc.Ec.Operation,
 		},
 		Layers: layersToLayers32(layers),
 		Platforms: platforms,
diff --git a/images/encryption.go b/images/encryption.go
index 056a26c..bc8bf8d 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -35,8 +35,14 @@ import (
 type EncryptConfig struct {
 	Recipients     []string
 	GPGPubRingFile []byte
+	Operation      int32
 }
 
+const (
+	OPERATION_ADD_RECIPIENTS    = int32(iota)
+	OPERATION_REMOVE_RECIPIENTS = int32(iota)
+)
+
 // DecryptKeyData stores private key data for decryption and the necessary password
 // for being able to access/decrypt the private key data
 type DecryptKeyData struct {
@@ -126,8 +132,15 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 	return filteredList, nil
 }
 
-// Encrypt encrypts a byte array using data from the CryptoConfig
-func Encrypt(cc *CryptoConfig, data []byte) ([]byte, [][]byte, error) {
+// HandleEncrypt encrypts a byte array using data from the CryptoConfig and also manages
+// the list of recipients' keys
+func HandleEncrypt(cc *CryptoConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
+	var (
+		encBlob []byte
+		wrappedKeys [][]byte
+		err error
+	)
+
 	filteredList, err := createEntityList(cc)
 	if err != nil {
 		return nil, nil, err
@@ -136,7 +149,17 @@ func Encrypt(cc *CryptoConfig, data []byte) ([]byte, [][]byte, error) {
 		return nil, nil, fmt.Errorf("No keys were found to encrypt message to.\n")
 	}
 
-	encBlob, wrappedKeys, err := encryptData(data, filteredList, nil)
+	switch (cc.Ec.Operation) {
+	case OPERATION_ADD_RECIPIENTS:
+		if len(keys) > 0 {
+			return nil, nil, fmt.Errorf("Refusing to encrypt an already encrypted layer.\n")
+		}
+		encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
+	case OPERATION_REMOVE_RECIPIENTS:
+		wrappedKeys, err = removeRecipientsFromKeys(keys, filteredList)
+		encBlob = data
+	}
+
 	if err != nil {
 		return nil, nil, err
 	}
diff --git a/images/image.go b/images/image.go
index 91cf41b..e276620 100644
--- a/images/image.go
+++ b/images/image.go
@@ -348,38 +348,37 @@ func Check(ctx context.Context, provider content.Provider, image ocispec.Descrip
 	return true, required, present, missing, nil
 }
 
-// encryptLayer encryts a single layer and writes the encrypted layer back into storage
-func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
-	data, err := content.ReadBlob(ctx, cs, desc)
-	if err != nil {
-		return ocispec.Descriptor{}, err
-	}
-	//fmt.Printf("   ... read %d bytes of layer %s data\n", len(p), desc.Digest)
-	// now we should encrypt
+// encryptLayer encrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
+// The caller is expected to store the returned encrypted data and OCI Descriptor
+func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
+	var (
+		keys [][]byte
+		size int64
+		d    digest.Digest
+		err  error
+	)
 
-	var p []byte
-	var keys [][]byte
-	if encrypt {
-		p, keys, err = Encrypt(cc, data)
-	} else {
-		p, err = Decrypt(cc, data, desc)
+	if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
+		keys, err = decodeWrappedKeys(v)
+		if err != nil {
+			return ocispec.Descriptor{}, []byte{}, err
+		}
 	}
+
+	p, keys, err := HandleEncrypt(cc, data, keys)
 	if err != nil {
-		return ocispec.Descriptor{}, err
+		return ocispec.Descriptor{}, []byte{}, err
 	}
-
-	size := int64(len(p))
-	d := digest.FromBytes(p)
+	size = int64(len(p))
+	d = digest.FromBytes(p)
 
 	newDesc := ocispec.Descriptor{
 		Digest:   d,
 		Size:     size,
 		Platform: desc.Platform,
 	}
-	if encrypt {
-		newDesc.Annotations = make(map[string]string)
-		newDesc.Annotations["org.opencontainers.image.pgp.keys"] = encodeWrappedKeys(keys)
-	}
+	newDesc.Annotations = make(map[string]string)
+	newDesc.Annotations["org.opencontainers.image.pgp.keys"] = encodeWrappedKeys(keys)
 
 	switch desc.MediaType {
 	case MediaTypeDockerSchema2LayerGzip:
@@ -387,18 +386,71 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	case MediaTypeDockerSchema2Layer:
 		newDesc.MediaType = MediaTypeDockerSchema2LayerPGP
 	case MediaTypeDockerSchema2LayerGzipPGP:
+		newDesc.MediaType = MediaTypeDockerSchema2LayerGzipPGP
+	case MediaTypeDockerSchema2LayerPGP:
+		newDesc.MediaType = MediaTypeDockerSchema2LayerPGP
+	default:
+		return ocispec.Descriptor{}, []byte{}, errors.Wrapf(err, "Encryption: unsupporter layer MediaType: %s\n", desc.MediaType)
+	}
+	return newDesc, p, nil
+}
+
+// decryptLayer decrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
+// The caller is expected to store the returned plain data and OCI Descriptor
+func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
+	p, err := Decrypt(cc, data, desc)
+	if err != nil {
+		return ocispec.Descriptor{}, []byte{}, err
+	}
+	size := int64(len(p))
+	d := digest.FromBytes(p)
+
+	newDesc := ocispec.Descriptor{
+		Digest:   d,
+		Size:     size,
+		Platform: desc.Platform,
+	}
+
+	switch desc.MediaType {
+	case MediaTypeDockerSchema2LayerGzipPGP:
 		newDesc.MediaType = MediaTypeDockerSchema2LayerGzip
 	case MediaTypeDockerSchema2LayerPGP:
 		newDesc.MediaType = MediaTypeDockerSchema2Layer
 	default:
-		return ocispec.Descriptor{}, errors.Wrapf(err, "Unsupporter layer MediaType: %s\n", desc.MediaType)
+		return ocispec.Descriptor{}, []byte{}, errors.Wrapf(err, "Decryption: unsupporter layer MediaType: %s\n", desc.MediaType)
 	}
+	return newDesc, p, nil
+}
+
+// cryptLayer handles the changes due to encryption or decryption of a layer
+func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
+	var (
+		p       []byte
+		newDesc ocispec.Descriptor
+	)
 
-	ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
-	content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc)
+	data, err := content.ReadBlob(ctx, cs, desc)
+	if err != nil {
+		return ocispec.Descriptor{}, err
+	}
 
-	return newDesc, nil
+	if encrypt {
+		newDesc, p, err = encryptLayer(cc, data, desc)
+	} else {
+		newDesc, p, err = decryptLayer(cc, data, desc)
+	}
+	if err != nil {
+		return ocispec.Descriptor{}, err
+	}
+	// some operations, such as adding or removing recipients, may not touch
+	// the layer at all
+	if len(p) > 0 {
+		ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
+		err = content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc)
+	}
+	return newDesc, err
 }
+
 func getWrappedKeys(desc ocispec.Descriptor) ([][]byte, error) {
 	// Parse and decode keys
 	if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
@@ -537,8 +589,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		case MediaTypeDockerSchema2Config:
 			config = child
 		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
-			// this one we can only encrypt
-			if encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
+			if encrypt &&isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
 				nl, err := cryptLayer(ctx, cs, child, cc, true)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -550,9 +601,9 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			}
 			layerNum = layerNum + 1
 		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
-			// this one we can only decrypt
-			if !encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
-				nl, err := cryptLayer(ctx, cs, child, cc, false)
+			// this one can be decrypted but also its recpients list changed
+			if isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
+				nl, err := cryptLayer(ctx, cs, child, cc, encrypt)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
 				}
diff --git a/images/openpgp.go b/images/openpgp.go
index bba0805..afb2ba1 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -50,6 +50,26 @@ func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (enc
 	return encBlob, wrappedKeys, nil
 }
 
+func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList) ([][]byte, error) {
+	var wrappedKeys [][]byte
+
+	for _, ek := range keys {
+		ekbuf := bytes.NewBuffer(ek)
+		p, err := packet.Read(ekbuf)
+		if err != nil {
+			return [][]byte{}, fmt.Errorf("Err reading enc key packet: %v", err)
+		}
+		pek := p.(*packet.EncryptedKey)
+
+		if len(removeRecipients.KeysById(pek.KeyId)) == 0 {
+			// we can keep this key
+			wrappedKeys = append(wrappedKeys, ek)
+		}
+	}
+
+	return wrappedKeys, nil
+}
+
 // decryptData decrypts an openpgp encrypted blob and wrapped keys and returns the decrypted data
 func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList) (data []byte, err error) {
 	// Assemble message by concatenating packets
diff --git a/services/images/local.go b/services/images/local.go
index 76f6bc7..3533059 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -191,6 +191,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 		Ec:	&images.EncryptConfig{
 			Recipients    : req.Cc.Recipients,
 			GPGPubRingFile: req.Cc.Gpgpubkeyring,
+			Operation     : req.Cc.Operation,
 		},
 	}, layers32ToLayers(req.Layers), req.Platforms)
 	if err != nil {
-- 
2.7.4


From b7003cba3d71125f0640dfc0fa4acd97b7f55c8a Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 25 Jul 2018 20:45:35 -0400
Subject: [PATCH 34/79] Refactor some code to use cc.Ec or cc.Dc rather than
 more general 'cc'

---
 images/encryption.go | 19 +++++++++----------
 images/image.go      |  4 ++--
 2 files changed, 11 insertions(+), 12 deletions(-)

diff --git a/images/encryption.go b/images/encryption.go
index bc8bf8d..b774dff 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -79,8 +79,8 @@ func ReadGPGPubRingFile() ([]byte, error) {
 
 // createEntityList creates the opengpg EntityList by reading the KeyRing
 // first and then filtering out recipients' keys
-func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
-	r := bytes.NewReader(cc.Ec.GPGPubRingFile)
+func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
+	r := bytes.NewReader(ec.GPGPubRingFile)
 
 	entityList, err := openpgp.ReadKeyRing(r)
 	if err != nil {
@@ -88,7 +88,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 	}
 
 	rSet := make(map[string]int)
-	for _, r := range cc.Ec.Recipients {
+	for _, r := range ec.Recipients {
 		rSet[r] = 0
 	}
 
@@ -100,7 +100,7 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 			if err != nil {
 				return nil, err
 			}
-			for _, r := range cc.Ec.Recipients {
+			for _, r := range ec.Recipients {
 				if strings.Compare(addr.Name, r) == 0 || strings.Compare(addr.Address, r) == 0 {
 					fmt.Printf(" TAKING key of %s\n", k)
 					filteredList = append(filteredList, entity)
@@ -134,14 +134,14 @@ func createEntityList(cc *CryptoConfig) (openpgp.EntityList, error) {
 
 // HandleEncrypt encrypts a byte array using data from the CryptoConfig and also manages
 // the list of recipients' keys
-func HandleEncrypt(cc *CryptoConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
+func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
 	var (
 		encBlob []byte
 		wrappedKeys [][]byte
 		err error
 	)
 
-	filteredList, err := createEntityList(cc)
+	filteredList, err := createEntityList(ec)
 	if err != nil {
 		return nil, nil, err
 	}
@@ -149,10 +149,10 @@ func HandleEncrypt(cc *CryptoConfig, data []byte, keys [][]byte) ([]byte, [][]by
 		return nil, nil, fmt.Errorf("No keys were found to encrypt message to.\n")
 	}
 
-	switch (cc.Ec.Operation) {
+	switch (ec.Operation) {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
-			return nil, nil, fmt.Errorf("Refusing to encrypt an already encrypted layer.\n")
+			return nil, nil, fmt.Errorf("Support for adding recipients is not implemented.\n")
 		}
 		encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 	case OPERATION_REMOVE_RECIPIENTS:
@@ -168,8 +168,7 @@ func HandleEncrypt(cc *CryptoConfig, data []byte, keys [][]byte) ([]byte, [][]by
 }
 
 // Decrypt decrypts a byte array using data from the CryptoConfig
-func Decrypt(cc *CryptoConfig, encBody []byte, desc ocispec.Descriptor) ([]byte, error) {
-	dc := cc.Dc
+func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor) ([]byte, error) {
 	keyIds, err := GetKeyIds(desc)
 	if err != nil {
 		return nil, err
diff --git a/images/image.go b/images/image.go
index e276620..d8b812a 100644
--- a/images/image.go
+++ b/images/image.go
@@ -365,7 +365,7 @@ func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 		}
 	}
 
-	p, keys, err := HandleEncrypt(cc, data, keys)
+	p, keys, err := HandleEncrypt(cc.Ec, data, keys)
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
@@ -398,7 +398,7 @@ func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 // decryptLayer decrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
 // The caller is expected to store the returned plain data and OCI Descriptor
 func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
-	p, err := Decrypt(cc, data, desc)
+	p, err := Decrypt(cc.Dc, data, desc)
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
-- 
2.7.4


From 4b4c6e79a5aefeea2e2a95284ddc3f8b24e06ac3 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Thu, 26 Jul 2018 11:08:13 -0400
Subject: [PATCH 35/79] Refactor gpg code

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 cmd/ctr/commands/images/decrypt.go | 27 +--------------
 images/encryption.go               | 21 ++----------
 images/gpg.go                      | 68 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 72 insertions(+), 44 deletions(-)
 create mode 100644 images/gpg.go

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 9ceceae..4e73c0d 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -108,7 +108,7 @@ var decryptCommand = cli.Command{
 				if err != nil {
 					return err
 				}
-				keydata, err := GetGPGPrivateKey(keyid, string(password))
+				keydata, err := images.GetGPGPrivateKey(keyid, string(password))
 				if err != nil {
 					return err
 				}
@@ -133,31 +133,6 @@ var decryptCommand = cli.Command{
 	},
 }
 
-// GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
-func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
-
-	cmd := exec.Command("gpg2", args...)
-
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2
-}
-
 // GetSecretKeyDetails retrives the secret key details of key with keyid.
 // returns a byte array of the details and a bool if the key exists
 func GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
diff --git a/images/encryption.go b/images/encryption.go
index b774dff..d0a71c6 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -23,7 +23,6 @@ import (
 	"net/mail"
 	"strings"
 
-	"github.com/mitchellh/go-homedir"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"golang.org/x/crypto/openpgp"
 	"golang.org/x/crypto/openpgp/packet"
@@ -63,20 +62,6 @@ type CryptoConfig struct {
 	Dc *DecryptConfig
 }
 
-// ReadGPGPubRingFile reads the GPG public key ring file
-func ReadGPGPubRingFile() ([]byte, error) {
-	home, err := homedir.Dir()
-	if err != nil {
-		return nil, err
-	}
-	pubring := fmt.Sprintf("%s/.gnupg/pubring.gpg", home)
-	gpgPubRingFile, err := ioutil.ReadFile(pubring)
-	if err != nil {
-		return nil, fmt.Errorf("Could not read Public keyring file %s: %v", pubring, err)
-	}
-	return gpgPubRingFile, nil
-}
-
 // createEntityList creates the opengpg EntityList by reading the KeyRing
 // first and then filtering out recipients' keys
 func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
@@ -136,9 +121,9 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 // the list of recipients' keys
 func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
 	var (
-		encBlob []byte
+		encBlob     []byte
 		wrappedKeys [][]byte
-		err error
+		err         error
 	)
 
 	filteredList, err := createEntityList(ec)
@@ -149,7 +134,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 		return nil, nil, fmt.Errorf("No keys were found to encrypt message to.\n")
 	}
 
-	switch (ec.Operation) {
+	switch ec.Operation {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
 			return nil, nil, fmt.Errorf("Support for adding recipients is not implemented.\n")
diff --git a/images/gpg.go b/images/gpg.go
new file mode 100644
index 0000000..e7a39e4
--- /dev/null
+++ b/images/gpg.go
@@ -0,0 +1,68 @@
+package images
+
+import (
+	"fmt"
+	"io/ioutil"
+	"os/exec"
+
+	"github.com/mitchellh/go-homedir"
+)
+
+// GPGVersion enum representing the versino of GPG client to use.
+type GPGVersion int
+
+const (
+	GPGv2 GPGVersion = iota
+	GPGv1
+	GPGVersionUndetermined
+)
+
+type GPGClient interface {
+	ReadGPGPubRingFile() ([]byte, error)
+	GetGPGPrivateKey(keyid uint64, password string) ([]byte, error)
+}
+
+// GuessGPGVersion guesses the version of gpg. Defaults to gpg2 if exists, if
+// not defaults to regular gpg.
+func GuessGPGVersion() (GPGVersion, error) {
+	return GPGVersionUndetermined, nil
+}
+
+// GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
+func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
+	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--  export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, err
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
+	}
+
+	return keydata, err2
+}
+
+// ReadGPGPubRingFile reads the GPG public key ring file
+func ReadGPGPubRingFile() ([]byte, error) {
+	home, err := homedir.Dir()
+	if err != nil {
+		return nil, err
+	}
+	pubring := fmt.Sprintf("%s/.gnupg/pubring.gpg", home)
+	gpgPubRingFile, err := ioutil.ReadFile(pubring)
+	if err != nil {
+		return nil, fmt.Errorf("Could not read Public keyring file %s: %v", pubring, err)
+	}
+	return gpgPubRingFile, nil
+}
-- 
2.7.4


From 80d2d3dbdf31cedf0739b30357c96832865902c8 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 10:11:20 -0400
Subject: [PATCH 36/79] Change layers to be int32[] to require less conversion

---
 cmd/ctr/commands/images/decrypt.go   |  6 ++++--
 cmd/ctr/commands/images/encrypt.go   |  4 +++-
 cmd/ctr/commands/images/layerinfo.go |  4 +++-
 cmd/ctr/commands/images/push.go      |  2 +-
 image_store.go                       | 23 +++++++----------------
 images/image.go                      | 20 ++++++++++----------
 metadata/images.go                   |  8 ++++----
 services/images/local.go             | 14 +++-----------
 8 files changed, 35 insertions(+), 46 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 4e73c0d..78cc412 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -65,7 +65,9 @@ var decryptCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"), context.StringSlice("platform"))
+		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
+
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
@@ -128,7 +130,7 @@ var decryptCommand = cli.Command{
 			Dc: &images.DecryptConfig{
 				KeyIdMap: keyIdMap,
 			},
-		}, context.IntSlice("layer"), context.StringSlice("platform"))
+		}, layers32, context.StringSlice("platform"))
 		return err
 	},
 }
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 75b38da..5fb2d45 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -87,7 +87,9 @@ var encryptCommand = cli.Command{
 				Operation:      operation,
 			},
 		}
-		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, context.IntSlice("layer"), context.StringSlice("platform"))
+		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
+
+		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, layers32, context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 4922109..1ed5bfa 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -55,7 +55,9 @@ var layerinfoCommand = cli.Command{
 		}
 		defer cancel()
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, context.IntSlice("layer"), context.StringSlice("platform"))
+		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
+
+		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index 77e37e3..e001c22 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -105,7 +105,7 @@ var pushCommand = cli.Command{
 					Recipients:     recipients,
 				},
 			}
-			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int{}, []string{})
+			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int32{}, []string{})
 			if err != nil {
 				return err
 			}
diff --git a/image_store.go b/image_store.go
index d786eac..5125541 100644
--- a/image_store.go
+++ b/image_store.go
@@ -49,7 +49,7 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platforms []string) (images.Image, error) {
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
@@ -58,7 +58,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 			Operation    : cc.Ec.Operation,
 		},
-		Layers: layersToLayers32(layers),
+		Layers: layers,
 		Platforms: platforms,
 	});
 	if err != nil {
@@ -68,7 +68,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platforms []string) (images.Image, error) {
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
 	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
 	for k, v := range cc.Dc.KeyIdMap {
 		keyIdMap[k] = &imagesapi.DecryptKeyData{
@@ -83,7 +83,7 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, c
 		Dc:      &imagesapi.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
-		Layers: layersToLayers32(layers),
+		Layers: layers,
 		Platforms: platforms,
 	});
 	if err != nil {
@@ -93,19 +93,10 @@ func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, c
 	return imageFromProto(&resp.Image), nil
 }
 
-func layersToLayers32(layers []int) []int32 {
-	var layers32 [] int32
-
-	for _, layer := range layers {
-		layers32 = append(layers32, int32(layer))
-	}
-	return layers32
-}
-
-func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int, platforms []string) ([]images.LayerInfo, error) {
+func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platforms []string) ([]images.LayerInfo, error) {
 	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
-		Name:    name,
-		Layers:  layersToLayers32(layers),
+		Name:      name,
+		Layers:    layers,
 		Platforms: platforms,
 	});
 	if err != nil {
diff --git a/images/image.go b/images/image.go
index d8b812a..29bd4f9 100644
--- a/images/image.go
+++ b/images/image.go
@@ -77,7 +77,7 @@ type LayerInfo struct {
 
 type LayerFilter struct {
 	// IDs of layers to touch
-	Layers []int
+	Layers []int32
 	// Platforms to touch
 	Platforms []ocispec.Platform
 }
@@ -111,9 +111,9 @@ type Store interface {
 
 	Delete(ctx context.Context, name string, opts ...DeleteOpt) error
 
-	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int, platforms []string) (Image, error)
-	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int, platforms []string) (Image, error)
-	GetImageLayerInfo(ctx context.Context, name string, layers []int, platforms []string) ([]LayerInfo, error)
+	EncryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int32, platforms []string) (Image, error)
+	DecryptImage(ctx context.Context, name, newName string, ec *CryptoConfig, layers []int32, platforms []string) (Image, error)
+	GetImageLayerInfo(ctx context.Context, name string, layers []int32, platforms []string) ([]LayerInfo, error)
 }
 
 // TODO(stevvooe): Many of these functions make strong platform assumptions,
@@ -520,8 +520,8 @@ func isDescriptorALayer(desc ocispec.Descriptor) bool {
 }
 
 // countLayers counts the number of layer OCI descriptors in the given array
-func countLayers(desc []ocispec.Descriptor) int {
-	c := 0
+func countLayers(desc []ocispec.Descriptor) int32 {
+	c := int32(0)
 
 	for _, d := range desc {
 		if isDescriptorALayer(d) {
@@ -534,7 +534,7 @@ func countLayers(desc []ocispec.Descriptor) int {
 // isUserSelectedLayer checks whether we need to modify this layer given its number
 // A layer can be described with its (positive) index number or its negative number, which
 // is counted relative to the last one
-func isUserSelectedLayer(layerNum, layersTotal int, layers []int) bool {
+func isUserSelectedLayer(layerNum, layersTotal int32, layers []int32) bool {
 	if len(layers) == 0 {
 		// convenience for the user; none given means 'all'
 		return true
@@ -569,7 +569,7 @@ func isUserSelectedPlatform(platform *ocispec.Platform, platformList []ocispec.P
 
 // Encrypt all the Children of a given descriptor
 func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool, thisPlatform *ocispec.Platform) (ocispec.Descriptor, bool, error) {
-	layerNum := 0
+	layerNum := int32(0)
 
 	children, err := Children(ctx, cs, desc)
 	if err != nil {
@@ -721,7 +721,7 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
-func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int) ([]LayerInfo, error) {
+func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32) ([]LayerInfo, error) {
 	var (
 		lis      []LayerInfo
 		tmp      []LayerInfo
@@ -743,7 +743,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 
 		layersTotal := countLayers(children)
-		layerNum := -1
+		layerNum := int32(-1)
 
 		for _, child := range children {
 			if isDescriptorALayer(child) {
diff --git a/metadata/images.go b/metadata/images.go
index 8d8ac15..c81b977 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -80,7 +80,7 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 
 // cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
 // or updates the existing one
-func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string, encrypt bool) (images.Image, error) {
+func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string, encrypt bool) (images.Image, error) {
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -199,15 +199,15 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 	return image, nil
 }
 
-func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string) (images.Image, error) {
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
 	return s.cryptImage(ctx, name, newName, cc, layers, platformList, true)
 }
 
-func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int, platformList []string) (images.Image, error) {
+func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
 	return s.cryptImage(ctx, name, newName, cc, layers, platformList, false)
 }
 
-func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int, platformList []string) ([]images.LayerInfo, error) {
+func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platformList []string) ([]images.LayerInfo, error) {
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
diff --git a/services/images/local.go b/services/images/local.go
index 3533059..b3f5fbb 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -193,7 +193,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 			GPGPubRingFile: req.Cc.Gpgpubkeyring,
 			Operation     : req.Cc.Operation,
 		},
-	}, layers32ToLayers(req.Layers), req.Platforms)
+	}, req.Layers, req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -229,7 +229,7 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 		Dc:	&images.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
-	}, layers32ToLayers(req.Layers), req.Platforms)
+	}, req.Layers, req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -250,7 +250,7 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 
 	var resp imagesapi.GetImageLayerInfoResponse
 
-	lis, err := l.store.GetImageLayerInfo(ctx, req.Name, layers32ToLayers(req.Layers), req.Platforms)
+	lis, err := l.store.GetImageLayerInfo(ctx, req.Name, req.Layers, req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
@@ -270,11 +270,3 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	return &resp, nil
 }
 
-func layers32ToLayers(layers []int32) []int {
-	var l []int
-
-	for _, layer := range layers{
-		l = append(l, int(layer))
-	}
-	return l;
-}
-- 
2.7.4


From 4fed8c9bdb92b1197b0a35adfdf977452d98ed27 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 09:57:32 -0400
Subject: [PATCH 37/79] Refactoring, simplification, documenting, and gofmt

---
 api/services/images/v1/images.proto |   5 +-
 image_store.go                      | 134 +++++++-------
 images/encryption.go                |  10 +-
 images/image.go                     | 199 ++++++++++-----------
 metadata/images.go                  | 343 ++++++++++++++++++------------------
 services/images/local.go            |  17 +-
 6 files changed, 351 insertions(+), 357 deletions(-)

diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 0422309..8b1f0a3 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -130,18 +130,21 @@ message DeleteImageRequest {
 	bool sync = 2;
 }
 
-// CryptConfig serves to pass keys used for encryption and decryption
+// EncryptConfig holds recipients' identifiers and the gpg public key ring
 message EncryptConfig {
 	repeated string recipients = 1;
 	bytes gpgpubkeyring = 2;
 	int32 operation = 3;
 }
 
+// DecryptKeyData holds the private key data and the password for the private key
 message DecryptKeyData {
 	bytes keyData = 1;
 	bytes keyDataPassword = 2;
 }
 
+// DecrypConfig holds the Ids of public keys and their corresponding private keys
+// needed for decrypting data
 message DecryptConfig {
 	map<uint64, DecryptKeyData> keyIdMap = 1;
 }
diff --git a/image_store.go b/image_store.go
index 5125541..d815307 100644
--- a/image_store.go
+++ b/image_store.go
@@ -49,73 +49,6 @@ func (s *remoteImages) Get(ctx context.Context, name string) (images.Image, erro
 	return imageFromProto(resp.Image), nil
 }
 
-func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
-	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
-		Name:    name,
-		NewName: newName,
-		Cc:      &imagesapi.EncryptConfig{
-			Recipients   : cc.Ec.Recipients,
-			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
-			Operation    : cc.Ec.Operation,
-		},
-		Layers: layers,
-		Platforms: platforms,
-	});
-	if err != nil {
-		return images.Image{}, errdefs.FromGRPC(err)
-	}
-
-	return imageFromProto(&resp.Image), nil
-}
-
-func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
-	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
-	for k, v := range cc.Dc.KeyIdMap {
-		keyIdMap[k] = &imagesapi.DecryptKeyData{
-			KeyData:         v.KeyData,
-			KeyDataPassword: v.KeyDataPassword,
-		}
-	}
-
-	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
-		Name:    name,
-		NewName: newName,
-		Dc:      &imagesapi.DecryptConfig{
-			KeyIdMap: keyIdMap,
-		},
-		Layers: layers,
-		Platforms: platforms,
-	});
-	if err != nil {
-		return images.Image{}, errdefs.FromGRPC(err)
-	}
-
-	return imageFromProto(&resp.Image), nil
-}
-
-func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platforms []string) ([]images.LayerInfo, error) {
-	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
-		Name:      name,
-		Layers:    layers,
-		Platforms: platforms,
-	});
-	if err != nil {
-		return []images.LayerInfo{}, errdefs.FromGRPC(err)
-	}
-
-	li := make([]images.LayerInfo, len(resp.LayerInfo))
-	for i := 0; i < len(resp.LayerInfo); i++ {
-		li[i].Id = resp.LayerInfo[i].ID
-		li[i].KeyIds = resp.LayerInfo[i].KeyIds
-		li[i].Digest = resp.LayerInfo[i].Digest
-		li[i].Encryption = resp.LayerInfo[i].Encryption
-		li[i].FileSize = resp.LayerInfo[i].FileSize
-		li[i].Platform = resp.LayerInfo[i].Platform
-	}
-
-	return li, nil
-}
-
 func (s *remoteImages) List(ctx context.Context, filters ...string) ([]images.Image, error) {
 	resp, err := s.client.List(ctx, &imagesapi.ListImagesRequest{
 		Filters: filters,
@@ -192,6 +125,73 @@ func imageFromProto(imagepb *imagesapi.Image) images.Image {
 	}
 }
 
+func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
+	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
+		Name:    name,
+		NewName: newName,
+		Cc: &imagesapi.EncryptConfig{
+			Recipients:    cc.Ec.Recipients,
+			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
+			Operation:     cc.Ec.Operation,
+		},
+		Layers:    layers,
+		Platforms: platforms,
+	})
+	if err != nil {
+		return images.Image{}, errdefs.FromGRPC(err)
+	}
+
+	return imageFromProto(&resp.Image), nil
+}
+
+func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
+	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
+	for k, v := range cc.Dc.KeyIdMap {
+		keyIdMap[k] = &imagesapi.DecryptKeyData{
+			KeyData:         v.KeyData,
+			KeyDataPassword: v.KeyDataPassword,
+		}
+	}
+
+	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
+		Name:    name,
+		NewName: newName,
+		Dc: &imagesapi.DecryptConfig{
+			KeyIdMap: keyIdMap,
+		},
+		Layers:    layers,
+		Platforms: platforms,
+	})
+	if err != nil {
+		return images.Image{}, errdefs.FromGRPC(err)
+	}
+
+	return imageFromProto(&resp.Image), nil
+}
+
+func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platforms []string) ([]images.LayerInfo, error) {
+	resp, err := s.client.GetImageLayerInfo(ctx, &imagesapi.GetImageLayerInfoRequest{
+		Name:      name,
+		Layers:    layers,
+		Platforms: platforms,
+	})
+	if err != nil {
+		return []images.LayerInfo{}, errdefs.FromGRPC(err)
+	}
+
+	li := make([]images.LayerInfo, len(resp.LayerInfo))
+	for i := 0; i < len(resp.LayerInfo); i++ {
+		li[i].Id = resp.LayerInfo[i].ID
+		li[i].KeyIds = resp.LayerInfo[i].KeyIds
+		li[i].Digest = resp.LayerInfo[i].Digest
+		li[i].Encryption = resp.LayerInfo[i].Encryption
+		li[i].FileSize = resp.LayerInfo[i].FileSize
+		li[i].Platform = resp.LayerInfo[i].Platform
+	}
+
+	return li, nil
+}
+
 func imagesFromProto(imagespb []imagesapi.Image) []images.Image {
 	var images []images.Image
 
diff --git a/images/encryption.go b/images/encryption.go
index d0a71c6..f98799d 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -79,15 +79,13 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 
 	var filteredList openpgp.EntityList
 	for _, entity := range entityList {
-		for k, _ := range entity.Identities {
-			fmt.Printf("k = %s\n", k)
+		for k := range entity.Identities {
 			addr, err := mail.ParseAddress(k)
 			if err != nil {
 				return nil, err
 			}
 			for _, r := range ec.Recipients {
 				if strings.Compare(addr.Name, r) == 0 || strings.Compare(addr.Address, r) == 0 {
-					fmt.Printf(" TAKING key of %s\n", k)
 					filteredList = append(filteredList, entity)
 					rSet[r] = rSet[r] + 1
 				}
@@ -117,7 +115,7 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 	return filteredList, nil
 }
 
-// HandleEncrypt encrypts a byte array using data from the CryptoConfig and also manages
+// HandleEncrypt encrypts a byte array using data from the EncryptConfig and also manages
 // the list of recipients' keys
 func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
 	var (
@@ -142,7 +140,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 		encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 	case OPERATION_REMOVE_RECIPIENTS:
 		wrappedKeys, err = removeRecipientsFromKeys(keys, filteredList)
-		encBlob = data
+		// encBlob stays empty to indicate it wasn't touched
 	}
 
 	if err != nil {
@@ -152,7 +150,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 	return encBlob, wrappedKeys, nil
 }
 
-// Decrypt decrypts a byte array using data from the CryptoConfig
+// Decrypt decrypts a byte array using data from the DecryptConfig
 func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor) ([]byte, error) {
 	keyIds, err := GetKeyIds(desc)
 	if err != nil {
diff --git a/images/image.go b/images/image.go
index 29bd4f9..a5fd6f3 100644
--- a/images/image.go
+++ b/images/image.go
@@ -348,7 +348,91 @@ func Check(ctx context.Context, provider content.Provider, image ocispec.Descrip
 	return true, required, present, missing, nil
 }
 
+// Children returns the immediate children of content described by the descriptor.
+func Children(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
+	var descs []ocispec.Descriptor
+	switch desc.MediaType {
+	case MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
+		p, err := content.ReadBlob(ctx, provider, desc)
+		if err != nil {
+			return nil, err
+		}
+
+		// TODO(stevvooe): We just assume oci manifest, for now. There may be
+		// subtle differences from the docker version.
+		var manifest ocispec.Manifest
+		if err := json.Unmarshal(p, &manifest); err != nil {
+			return nil, err
+		}
+
+		descs = append(descs, manifest.Config)
+		descs = append(descs, manifest.Layers...)
+	case MediaTypeDockerSchema2ManifestList, ocispec.MediaTypeImageIndex:
+		p, err := content.ReadBlob(ctx, provider, desc)
+		if err != nil {
+			return nil, err
+		}
+
+		var index ocispec.Index
+		if err := json.Unmarshal(p, &index); err != nil {
+			return nil, err
+		}
+
+		descs = append(descs, index.Manifests...)
+	case MediaTypeDockerSchema2Layer, MediaTypeDockerSchema2LayerGzip,
+		MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP,
+		MediaTypeDockerSchema2LayerForeign, MediaTypeDockerSchema2LayerForeignGzip,
+		MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig,
+		ocispec.MediaTypeImageLayer, ocispec.MediaTypeImageLayerGzip,
+		ocispec.MediaTypeImageLayerNonDistributable, ocispec.MediaTypeImageLayerNonDistributableGzip,
+		MediaTypeContainerd1Checkpoint, MediaTypeContainerd1CheckpointConfig:
+		// childless data types.
+		return nil, nil
+	default:
+		log.G(ctx).Warnf("encountered unknown type %v; children may not be fetched", desc.MediaType)
+	}
+
+	return descs, nil
+}
+
+// RootFS returns the unpacked diffids that make up and images rootfs.
+//
+// These are used to verify that a set of layers unpacked to the expected
+// values.
+func RootFS(ctx context.Context, provider content.Provider, configDesc ocispec.Descriptor) ([]digest.Digest, error) {
+	p, err := content.ReadBlob(ctx, provider, configDesc)
+	if err != nil {
+		return nil, err
+	}
+
+	var config ocispec.Image
+	if err := json.Unmarshal(p, &config); err != nil {
+		return nil, err
+	}
+	return config.RootFS.DiffIDs, nil
+}
+
+// IsCompressedDiff returns true if mediaType is a known compressed diff media type.
+// It returns false if the media type is a diff, but not compressed. If the media type
+// is not a known diff type, it returns errdefs.ErrNotImplemented
+func IsCompressedDiff(ctx context.Context, mediaType string) (bool, error) {
+	switch mediaType {
+	case ocispec.MediaTypeImageLayer, MediaTypeDockerSchema2Layer:
+	case ocispec.MediaTypeImageLayerGzip, MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2LayerGzipPGP:
+		return true, nil
+	default:
+		// Still apply all generic media types *.tar[.+]gzip and *.tar
+		if strings.HasSuffix(mediaType, ".tar.gzip") || strings.HasSuffix(mediaType, ".tar+gzip") {
+			return true, nil
+		} else if !strings.HasSuffix(mediaType, ".tar") {
+			return false, errdefs.ErrNotImplemented
+		}
+	}
+	return false, nil
+}
+
 // encryptLayer encrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
+// A call to this function may also only manipulate the wrapped keys list.
 // The caller is expected to store the returned encrypted data and OCI Descriptor
 func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
 	var (
@@ -358,19 +442,24 @@ func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 		err  error
 	)
 
-	if v, ok := desc.Annotations["org.opencontainers.image.pgp.keys"]; ok {
-		keys, err = decodeWrappedKeys(v)
-		if err != nil {
-			return ocispec.Descriptor{}, []byte{}, err
-		}
+	keys, err = getWrappedKeys(desc)
+	if err != nil {
+		return ocispec.Descriptor{}, []byte{}, err
 	}
 
 	p, keys, err := HandleEncrypt(cc.Ec, data, keys)
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
-	size = int64(len(p))
-	d = digest.FromBytes(p)
+
+	// were data touched ?
+	if len(p) > 0 {
+		size = int64(len(p))
+		d = digest.FromBytes(p)
+	} else {
+		size = desc.Size
+		d = desc.Digest
+	}
 
 	newDesc := ocispec.Descriptor{
 		Digest:   d,
@@ -402,12 +491,10 @@ func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
-	size := int64(len(p))
-	d := digest.FromBytes(p)
 
 	newDesc := ocispec.Descriptor{
-		Digest:   d,
-		Size:     size,
+		Digest:   digest.FromBytes(p),
+		Size:     int64(len(p)),
 		Platform: desc.Platform,
 	}
 
@@ -442,8 +529,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	if err != nil {
 		return ocispec.Descriptor{}, err
 	}
-	// some operations, such as adding or removing recipients, may not touch
-	// the layer at all
+	// some operations, such as changing recipients, may not touch the layer at all
 	if len(p) > 0 {
 		ref := fmt.Sprintf("layer-%s", newDesc.Digest.String())
 		err = content.WriteBlob(ctx, cs, ref, bytes.NewReader(p), newDesc)
@@ -589,7 +675,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		case MediaTypeDockerSchema2Config:
 			config = child
 		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
-			if encrypt &&isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
+			if encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
 				nl, err := cryptLayer(ctx, cs, child, cc, true)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
@@ -760,7 +846,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 				return []LayerInfo{}, err
 			}
 
-			if (platform != "") {
+			if platform != "" {
 				for i := 0; i < len(tmp); i++ {
 					tmp[i].Platform = platform
 				}
@@ -796,86 +882,3 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 
 	return lis, nil
 }
-
-// Children returns the immediate children of content described by the descriptor.
-func Children(ctx context.Context, provider content.Provider, desc ocispec.Descriptor) ([]ocispec.Descriptor, error) {
-	var descs []ocispec.Descriptor
-	switch desc.MediaType {
-	case MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
-		p, err := content.ReadBlob(ctx, provider, desc)
-		if err != nil {
-			return nil, err
-		}
-
-		// TODO(stevvooe): We just assume oci manifest, for now. There may be
-		// subtle differences from the docker version.
-		var manifest ocispec.Manifest
-		if err := json.Unmarshal(p, &manifest); err != nil {
-			return nil, err
-		}
-
-		descs = append(descs, manifest.Config)
-		descs = append(descs, manifest.Layers...)
-	case MediaTypeDockerSchema2ManifestList, ocispec.MediaTypeImageIndex:
-		p, err := content.ReadBlob(ctx, provider, desc)
-		if err != nil {
-			return nil, err
-		}
-
-		var index ocispec.Index
-		if err := json.Unmarshal(p, &index); err != nil {
-			return nil, err
-		}
-
-		descs = append(descs, index.Manifests...)
-	case MediaTypeDockerSchema2Layer, MediaTypeDockerSchema2LayerGzip,
-		MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP,
-		MediaTypeDockerSchema2LayerForeign, MediaTypeDockerSchema2LayerForeignGzip,
-		MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig,
-		ocispec.MediaTypeImageLayer, ocispec.MediaTypeImageLayerGzip,
-		ocispec.MediaTypeImageLayerNonDistributable, ocispec.MediaTypeImageLayerNonDistributableGzip,
-		MediaTypeContainerd1Checkpoint, MediaTypeContainerd1CheckpointConfig:
-		// childless data types.
-		return nil, nil
-	default:
-		log.G(ctx).Warnf("encountered unknown type %v; children may not be fetched", desc.MediaType)
-	}
-
-	return descs, nil
-}
-
-// RootFS returns the unpacked diffids that make up and images rootfs.
-//
-// These are used to verify that a set of layers unpacked to the expected
-// values.
-func RootFS(ctx context.Context, provider content.Provider, configDesc ocispec.Descriptor) ([]digest.Digest, error) {
-	p, err := content.ReadBlob(ctx, provider, configDesc)
-	if err != nil {
-		return nil, err
-	}
-
-	var config ocispec.Image
-	if err := json.Unmarshal(p, &config); err != nil {
-		return nil, err
-	}
-	return config.RootFS.DiffIDs, nil
-}
-
-// IsCompressedDiff returns true if mediaType is a known compressed diff media type.
-// It returns false if the media type is a diff, but not compressed. If the media type
-// is not a known diff type, it returns errdefs.ErrNotImplemented
-func IsCompressedDiff(ctx context.Context, mediaType string) (bool, error) {
-	switch mediaType {
-	case ocispec.MediaTypeImageLayer, MediaTypeDockerSchema2Layer:
-	case ocispec.MediaTypeImageLayerGzip, MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2LayerGzipPGP:
-		return true, nil
-	default:
-		// Still apply all generic media types *.tar[.+]gzip and *.tar
-		if strings.HasSuffix(mediaType, ".tar.gzip") || strings.HasSuffix(mediaType, ".tar+gzip") {
-			return true, nil
-		} else if !strings.HasSuffix(mediaType, ".tar") {
-			return false, errdefs.ErrNotImplemented
-		}
-	}
-	return false, nil
-}
diff --git a/metadata/images.go b/metadata/images.go
index c81b977..899fad1 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -28,9 +28,9 @@ import (
 	"github.com/containerd/containerd/filters"
 	"github.com/containerd/containerd/images"
 	"github.com/containerd/containerd/labels"
-	"github.com/containerd/containerd/platforms"
 	"github.com/containerd/containerd/metadata/boltutil"
 	"github.com/containerd/containerd/namespaces"
+	"github.com/containerd/containerd/platforms"
 	digest "github.com/opencontainers/go-digest"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/pkg/errors"
@@ -46,7 +46,7 @@ func NewImageStore(db *DB) images.Store {
 }
 
 func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error) {
-	fmt.Printf("metadata/images.go: Get() name=%s\n",name)
+	fmt.Printf("metadata/images.go: Get() name=%s\n", name)
 	var image images.Image
 
 	namespace, err := namespaces.NamespaceRequired(ctx)
@@ -78,178 +78,6 @@ func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error)
 	return image, nil
 }
 
-// cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
-// or updates the existing one
-func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string, encrypt bool) (images.Image, error) {
-	var image images.Image
-
-	namespace, err := namespaces.NamespaceRequired(ctx)
-	if err != nil {
-		return images.Image{}, err
-	}
-
-	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
-		bkt := getImagesBucket(tx, namespace)
-		if bkt == nil {
-			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		}
-
-		ibkt := bkt.Bucket([]byte(name))
-		if ibkt == nil {
-			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		}
-
-		image.Name = name
-		if err := readImage(&image, ibkt); err != nil {
-			return errors.Wrapf(err, "image %q", name)
-		}
-
-		return nil
-	}); err != nil {
-		return image, err
-	}
-
-	cs := s.db.ContentStore()
-	fmt.Printf("metadata/images.go: cs = %v\n",cs)
-	fmt.Printf("  high level image.Target is of MediaType %s\n", image.Target.MediaType)
-
-	pl, err := platforms.ParseArray(platformList)
-	if err != nil {
-		return image, err
-	}
-
-	lf := &images.LayerFilter {
-		Layers:    layers,
-		Platforms: pl,
-	}
-
-	newSpec, modified, err := images.CryptManifestList(ctx, cs, image.Target, cc, lf, encrypt)
-	if err != nil {
-		return image, err
-	}
-	if !modified {
-		return image, nil
-	}
-
-	// if newName is either empty or equal to the existing name, it's an update
-	if (newName == "" || strings.Compare(image.Name, newName) == 0) {
-		if err := update(ctx, s.db, func(tx *bolt.Tx) error {
-			bkt, err := createImagesBucket(tx, namespace)
-			if err != nil {
-				return err
-			}
-
-			ibkt := bkt.Bucket([]byte(image.Name))
-			if ibkt == nil {
-				return errors.Wrapf(errdefs.ErrNotFound, "image %q", image.Name)
-			}
-
-			if err := validateImage(&image); err != nil {
-				return err
-			}
-
-			image.UpdatedAt = time.Now().UTC()
-			image.Target = newSpec
-			if err := writeImage(ibkt, &image); err != nil {
-				return err
-			}
-			// A reference to a piece of content has been removed,
-			// mark content store as dirty for triggering garbage
-			// collection
-			s.db.dirtyL.Lock()
-			s.db.dirtyCS = true
-			s.db.dirtyL.Unlock()
-
-			return nil
-		}); err != nil {
-			return image, err
-		}
-		return image, nil
-	}
-
-	if err := update(ctx, s.db, func(tx *bolt.Tx) error {
-		image.Target = newSpec
-		image.Name = newName
-		image.UpdatedAt = time.Now().UTC()
-
-		if err := validateImage(&image); err != nil {
-			return err
-		}
-
-		bkt, err := createImagesBucket(tx, namespace)
-		if err != nil {
-			return err
-		}
-
-		ibkt, err := bkt.CreateBucket([]byte(image.Name))
-		if err != nil {
-			if err != bolt.ErrBucketExists {
-				return err
-			}
-
-			return errors.Wrapf(errdefs.ErrAlreadyExists, "image %q", image.Name)
-		}
-
-		return writeImage(ibkt, &image)
-	}); err != nil {
-		return image, err
-	}
-	fmt.Printf("updated spec: %v, modified: %v\n", newSpec, modified)
-
-	return image, nil
-}
-
-func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, layers, platformList, true)
-}
-
-func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
-	return s.cryptImage(ctx, name, newName, cc, layers, platformList, false)
-}
-
-func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platformList []string) ([]images.LayerInfo, error) {
-	var image images.Image
-
-	namespace, err := namespaces.NamespaceRequired(ctx)
-	if err != nil {
-		return []images.LayerInfo{}, err
-	}
-
-	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
-		bkt := getImagesBucket(tx, namespace)
-		if bkt == nil {
-			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		}
-
-		ibkt := bkt.Bucket([]byte(name))
-		if ibkt == nil {
-			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
-		}
-
-		image.Name = name
-		if err := readImage(&image, ibkt); err != nil {
-			return errors.Wrapf(err, "image %q", name)
-		}
-
-		return nil
-	}); err != nil {
-		return []images.LayerInfo{}, err
-	}
-
-	cs := s.db.ContentStore()
-
-	pl, err := platforms.ParseArray(platformList)
-	if err != nil {
-		return []images.LayerInfo{}, err
-	}
-	lf := &images.LayerFilter {
-		Layers:    layers,
-		Platforms: pl,
-	}
-
-	return images.GetImageLayerInfo(ctx, cs, image.Target, lf, -1)
-}
-
 func (s *imageStore) List(ctx context.Context, fs ...string) ([]images.Image, error) {
 	namespace, err := namespaces.NamespaceRequired(ctx)
 	if err != nil {
@@ -319,7 +147,7 @@ func (s *imageStore) Create(ctx context.Context, image images.Image) (images.Ima
 
 		image.CreatedAt = time.Now().UTC()
 		image.UpdatedAt = image.CreatedAt
-		return writeImage(ibkt, &image);
+		return writeImage(ibkt, &image)
 	}); err != nil {
 		return images.Image{}, err
 	}
@@ -429,6 +257,171 @@ func (s *imageStore) Delete(ctx context.Context, name string, opts ...images.Del
 	})
 }
 
+// cryptImage encrypts or decrypts an image with the given name and stores it either under the newName
+// or updates the existing one
+func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string, encrypt bool) (images.Image, error) {
+	var image images.Image
+
+	namespace, err := namespaces.NamespaceRequired(ctx)
+	if err != nil {
+		return images.Image{}, err
+	}
+
+	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
+		bkt := getImagesBucket(tx, namespace)
+		if bkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		ibkt := bkt.Bucket([]byte(name))
+		if ibkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		image.Name = name
+		if err := readImage(&image, ibkt); err != nil {
+			return errors.Wrapf(err, "image %q", name)
+		}
+
+		return nil
+	}); err != nil {
+		return image, err
+	}
+
+	pl, err := platforms.ParseArray(platformList)
+	if err != nil {
+		return image, err
+	}
+
+	lf := &images.LayerFilter{
+		Layers:    layers,
+		Platforms: pl,
+	}
+
+	newSpec, modified, err := images.CryptManifestList(ctx, s.db.ContentStore(), image.Target, cc, lf, encrypt)
+	if err != nil {
+		return image, err
+	}
+	if !modified {
+		return image, nil
+	}
+
+	// if newName is either empty or equal to the existing name, it's an update
+	if newName == "" || strings.Compare(image.Name, newName) == 0 {
+		if err := update(ctx, s.db, func(tx *bolt.Tx) error {
+			bkt, err := createImagesBucket(tx, namespace)
+			if err != nil {
+				return err
+			}
+
+			ibkt := bkt.Bucket([]byte(image.Name))
+			if ibkt == nil {
+				return errors.Wrapf(errdefs.ErrNotFound, "image %q", image.Name)
+			}
+
+			if err := validateImage(&image); err != nil {
+				return err
+			}
+
+			image.UpdatedAt = time.Now().UTC()
+			image.Target = newSpec
+			if err := writeImage(ibkt, &image); err != nil {
+				return err
+			}
+			// A reference to a piece of content has been removed,
+			// mark content store as dirty for triggering garbage
+			// collection
+			s.db.dirtyL.Lock()
+			s.db.dirtyCS = true
+			s.db.dirtyL.Unlock()
+
+			return nil
+		}); err != nil {
+			return image, err
+		}
+		return image, nil
+	}
+
+	if err := update(ctx, s.db, func(tx *bolt.Tx) error {
+		image.Target = newSpec
+		image.Name = newName
+		image.UpdatedAt = time.Now().UTC()
+
+		if err := validateImage(&image); err != nil {
+			return err
+		}
+
+		bkt, err := createImagesBucket(tx, namespace)
+		if err != nil {
+			return err
+		}
+
+		ibkt, err := bkt.CreateBucket([]byte(image.Name))
+		if err != nil {
+			if err != bolt.ErrBucketExists {
+				return err
+			}
+
+			return errors.Wrapf(errdefs.ErrAlreadyExists, "image %q", image.Name)
+		}
+
+		return writeImage(ibkt, &image)
+	}); err != nil {
+		return image, err
+	}
+
+	return image, nil
+}
+
+func (s *imageStore) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, platformList, true)
+}
+
+func (s *imageStore) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platformList []string) (images.Image, error) {
+	return s.cryptImage(ctx, name, newName, cc, layers, platformList, false)
+}
+
+func (s *imageStore) GetImageLayerInfo(ctx context.Context, name string, layers []int32, platformList []string) ([]images.LayerInfo, error) {
+	var image images.Image
+
+	namespace, err := namespaces.NamespaceRequired(ctx)
+	if err != nil {
+		return []images.LayerInfo{}, err
+	}
+
+	if err := view(ctx, s.db, func(tx *bolt.Tx) error {
+		bkt := getImagesBucket(tx, namespace)
+		if bkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		ibkt := bkt.Bucket([]byte(name))
+		if ibkt == nil {
+			return errors.Wrapf(errdefs.ErrNotFound, "image %q", name)
+		}
+
+		image.Name = name
+		if err := readImage(&image, ibkt); err != nil {
+			return errors.Wrapf(err, "image %q", name)
+		}
+
+		return nil
+	}); err != nil {
+		return []images.LayerInfo{}, err
+	}
+
+	pl, err := platforms.ParseArray(platformList)
+	if err != nil {
+		return []images.LayerInfo{}, err
+	}
+	lf := &images.LayerFilter{
+		Layers:    layers,
+		Platforms: pl,
+	}
+
+	return images.GetImageLayerInfo(ctx, s.db.ContentStore(), image.Target, lf, -1)
+}
+
 func validateImage(image *images.Image) error {
 	if image.Name == "" {
 		return errors.Wrapf(errdefs.ErrInvalidArgument, "image name must not be empty")
diff --git a/services/images/local.go b/services/images/local.go
index b3f5fbb..858055e 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -18,7 +18,6 @@ package images
 
 import (
 	"context"
-	"fmt"
 
 	eventstypes "github.com/containerd/containerd/api/events"
 	imagesapi "github.com/containerd/containerd/api/services/images/v1"
@@ -185,18 +184,19 @@ func (l *local) Delete(ctx context.Context, req *imagesapi.DeleteImageRequest, _
 func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageRequest, _ ...grpc.CallOption) (*imagesapi.EncryptImageResponse, error) {
 	log.G(ctx).WithField("name", req.Name).Debugf("encrypt image")
 
-	var resp   imagesapi.EncryptImageResponse
+	var resp imagesapi.EncryptImageResponse
 
 	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
-		Ec:	&images.EncryptConfig{
-			Recipients    : req.Cc.Recipients,
+		Ec: &images.EncryptConfig{
+			Recipients:     req.Cc.Recipients,
 			GPGPubRingFile: req.Cc.Gpgpubkeyring,
-			Operation     : req.Cc.Operation,
+			Operation:      req.Cc.Operation,
 		},
 	}, req.Layers, req.Platforms)
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
+
 	resp.Image = imageToProto(&encrypted)
 
 	if err := l.publisher.Publish(ctx, "/images/update", &eventstypes.ImageUpdate{
@@ -212,9 +212,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageRequest, _ ...grpc.CallOption) (*imagesapi.DecryptImageResponse, error) {
 	log.G(ctx).WithField("name", req.Name).Debugf("decrypt image")
 
-	fmt.Printf("req.Platforms: %s\n", req.Platforms)
-
-	var resp   imagesapi.DecryptImageResponse
+	var resp imagesapi.DecryptImageResponse
 
 	keyIdMap := make(map[uint64]images.DecryptKeyData)
 
@@ -226,7 +224,7 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 	}
 
 	encrypted, err := l.store.DecryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
-		Dc:	&images.DecryptConfig{
+		Dc: &images.DecryptConfig{
 			KeyIdMap: keyIdMap,
 		},
 	}, req.Layers, req.Platforms)
@@ -269,4 +267,3 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 
 	return &resp, nil
 }
-
-- 
2.7.4


From de24802bd0c5cdb596e6940a8eb6327d1da99108 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 11:15:46 -0400
Subject: [PATCH 38/79] Add missing file

---
 cmd/ctr/commands/utils.go | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)
 create mode 100644 cmd/ctr/commands/utils.go

diff --git a/cmd/ctr/commands/utils.go b/cmd/ctr/commands/utils.go
new file mode 100644
index 0000000..0cb8a0b
--- /dev/null
+++ b/cmd/ctr/commands/utils.go
@@ -0,0 +1,27 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package commands
+
+func IntToInt32Array(in []int) []int32 {
+	var ret []int32
+
+	for _, v := range in{
+		ret = append(ret, int32(v))
+	}
+	return ret
+}
+
-- 
2.7.4


From 0178003550f1f13ad432de9a4e9aca221a51e2e0 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 11:22:30 -0400
Subject: [PATCH 39/79] Fixing typo with 2 spaces in command line

---
 images/gpg.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/images/gpg.go b/images/gpg.go
index e7a39e4..1074296 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -30,7 +30,7 @@ func GuessGPGVersion() (GPGVersion, error) {
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
 func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--  export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
 
 	cmd := exec.Command("gpg2", args...)
 
-- 
2.7.4


From b2fa200abc382b12442ead4d4563c1d4c4500bea Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Thu, 26 Jul 2018 12:54:05 -0400
Subject: [PATCH 40/79] Made gpg clients as objects

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 cmd/ctr/commands/images/decrypt.go   |  64 +++++++-------
 cmd/ctr/commands/images/encrypt.go   |  46 ++++++++--
 cmd/ctr/commands/images/layerinfo.go |  10 ++-
 cmd/ctr/commands/images/push.go      |  22 -----
 images/encryption.go                 |  11 +--
 images/gpg.go                        | 167 +++++++++++++++++++++++++++++++++--
 images/image.go                      |  56 ++++++------
 images/openpgp.go                    |  10 ++-
 8 files changed, 274 insertions(+), 112 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 78cc412..0343106 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -18,8 +18,6 @@ package images
 
 import (
 	"fmt"
-	"io/ioutil"
-	"os/exec"
 	"syscall"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
@@ -34,9 +32,12 @@ var decryptCommand = cli.Command{
 	Name:      "decrypt",
 	Usage:     "decrypt an image locally",
 	ArgsUsage: "[flags] <local> <new name>",
-	Description: `Encrypt and image.
+	Description: `Decrypt an image locally.
 
-	XYZ
+	Decrypt an image using private keys managed by GPG.
+	The user has contol over which layers to decrypt and for which platform.
+	If no payers or platforms are specified, all layers for all platforms are
+	decrypted.
 `,
 	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
 		Name:  "layer",
@@ -44,6 +45,12 @@ var decryptCommand = cli.Command{
 	}, cli.StringSliceFlag{
 		Name:  "platform",
 		Usage: "For which platform to decrypt; by default decryption is done for all platforms",
+	}, cli.StringFlag{
+		Name:  "gpg-homedir",
+		Usage: "The GPG homedir to use; by default gpg uses ~/.gnupg",
+	}, cli.StringFlag{
+		Name:  "gpg-version",
+		Usage: "The GPG version (\"v1\" or \"v2\"), default will make an educated guess",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -65,6 +72,22 @@ var decryptCommand = cli.Command{
 		}
 		defer cancel()
 
+		// Create gpg client
+		gpgVersion := context.String("gpg-version")
+		v := new(images.GPGVersion)
+		switch gpgVersion {
+		case "v1":
+			*v = images.GPGv1
+		case "v2":
+			*v = images.GPGv2
+		default:
+			v = nil
+		}
+		gpgClient, err := images.NewGPGClient(v, context.String("gpg-homedir"))
+		if err != nil {
+			return errors.New("Unable to create GPG Client")
+		}
+
 		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
 
 		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
@@ -95,7 +118,7 @@ var decryptCommand = cli.Command{
 					break
 				}
 				// do we have this key?
-				keyinfo, haveKey, err := GetSecretKeyDetails(keyid)
+				keyinfo, haveKey, err := gpgClient.GetSecretKeyDetails(keyid)
 				// this may fail if the key is not here; we ignore the error
 				if !haveKey {
 					// key not on this system
@@ -110,7 +133,8 @@ var decryptCommand = cli.Command{
 				if err != nil {
 					return err
 				}
-				keydata, err := images.GetGPGPrivateKey(keyid, string(password))
+
+				keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
 				if err != nil {
 					return err
 				}
@@ -122,7 +146,7 @@ var decryptCommand = cli.Command{
 				break
 			}
 			if !found && len(LayerInfo.KeyIds) > 0 {
-				return fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %s\n", LayerInfo.Id, LayerInfo.Platform, LayerInfo.KeyIds)
+				return fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", LayerInfo.Id, LayerInfo.Platform, LayerInfo.KeyIds)
 			}
 		}
 		fmt.Printf("\n")
@@ -135,32 +159,6 @@ var decryptCommand = cli.Command{
 	},
 }
 
-// GetSecretKeyDetails retrives the secret key details of key with keyid.
-// returns a byte array of the details and a bool if the key exists
-func GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
-	args := append([]string{"-K"}, fmt.Sprintf("0x%x", keyid))
-
-	cmd := exec.Command("gpg2", args...)
-
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, false, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, false, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2 == nil, err2
-}
-
 func addToSet(set, add []uint64) []uint64 {
 	for i := 0; i < len(add); i++ {
 		found := false
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 5fb2d45..88ad45e 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -29,9 +29,18 @@ var encryptCommand = cli.Command{
 	Name:      "encrypt",
 	Usage:     "encrypt an image locally",
 	ArgsUsage: "[flags] <local> <new name>",
-	Description: `Encrypt and image.
+	Description: `Encrypt an image locally.
 
-	XYZ
+	Encrypt an image using public keys managed by GPG.
+	The user must provide recpients who will be able to decrypt the image using
+	their GPG-managed private key. For this the user's GPG keyring must hold the public
+	keys of the recipients.
+	The user has control over the individual layers and the platforms they are
+	associated with and can encrypt them separately. If no layers or platforms are
+	specified, all layers for all platforms will be encrypted.
+	This tool also allows management of the recipients of the image through changes
+	to the list of recipients.
+	Once the image has been encrypted it may be pushed to a registry.
 `,
 	Flags: append(commands.RegistryFlags, cli.StringSliceFlag{
 		Name:  "recipient",
@@ -45,10 +54,16 @@ var encryptCommand = cli.Command{
 	}, cli.BoolFlag{
 		Name:  "remove",
 		Usage: "Remove the given set of recipients",
+	}, cli.StringFlag{
+		Name:  "gpg-homedir",
+		Usage: "The GPG homedir to use; by default gpg uses ~/.gnupg",
+	}, cli.StringFlag{
+		Name:  "gpg-version",
+		Usage: "The GPG version (\"v1\" or \"v2\"), default will make an educated guess",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
-			local = context.Args().First()
+			local   = context.Args().First()
 			newName = context.Args().Get(1)
 		)
 		if local == "" {
@@ -57,7 +72,7 @@ var encryptCommand = cli.Command{
 		if newName != "" {
 			fmt.Printf("Encrypting %s to %s\n", local, newName)
 		} else {
-			fmt.Printf("Encrypting %s and replacing it with the encrypted image\n", local);
+			fmt.Printf("Encrypting %s and replacing it with the encrypted image\n", local)
 		}
 		client, ctx, cancel, err := commands.NewClient(context)
 		if err != nil {
@@ -67,10 +82,26 @@ var encryptCommand = cli.Command{
 
 		recipients := context.StringSlice("recipient")
 		if len(recipients) == 0 {
-			return errors.New("no recipients given -- nothing to do")			
+			return errors.New("no recipients given -- nothing to do")
 		}
 
-		gpgPubRingFile, err := images.ReadGPGPubRingFile()
+		// Create gpg client
+		gpgVersion := context.String("gpg-version")
+		v := new(images.GPGVersion)
+		switch gpgVersion {
+		case "v1":
+			*v = images.GPGv1
+		case "v2":
+			*v = images.GPGv2
+		default:
+			v = nil
+		}
+		gpgClient, err := images.NewGPGClient(v, context.String("gpg-homedir"))
+		if err != nil {
+			return errors.New("Unable to create GPG Client")
+		}
+
+		gpgPubRingFile, err := gpgClient.ReadGPGPubRingFile()
 		if err != nil {
 			return err
 		}
@@ -81,7 +112,7 @@ var encryptCommand = cli.Command{
 		}
 
 		cc := &images.CryptoConfig{
-			Ec:	&images.EncryptConfig{
+			Ec: &images.EncryptConfig{
 				GPGPubRingFile: gpgPubRingFile,
 				Recipients:     recipients,
 				Operation:      operation,
@@ -96,4 +127,3 @@ var encryptCommand = cli.Command{
 		return nil
 	},
 }
-
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 1ed5bfa..0cfa41c 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -29,11 +29,16 @@ import (
 
 var layerinfoCommand = cli.Command{
 	Name:      "layerinfo",
-	Usage:     "get infomration about an image's layers",
+	Usage:     "get information about an image's layers",
 	ArgsUsage: "[flags] <local>",
 	Description: `Get encryption information about the layers of an image.
 
-	XYZ
+	Get information about the layers of an image and display with which
+	encryption technology the individual layers are encrypted with.
+	The user has control over the individual layers and the platforms they are
+	associated with and can retrieve information for them separately. If no
+	layers or platforms are specified, infomration for all layers and all
+	platforms will be retrieved.
 `,
 	Flags: append(commands.RegistryFlags, cli.IntSliceFlag{
 		Name:  "layer",
@@ -81,4 +86,3 @@ var layerinfoCommand = cli.Command{
 		return nil
 	},
 }
-
diff --git a/cmd/ctr/commands/images/push.go b/cmd/ctr/commands/images/push.go
index e001c22..f6d19e6 100644
--- a/cmd/ctr/commands/images/push.go
+++ b/cmd/ctr/commands/images/push.go
@@ -18,7 +18,6 @@ package images
 
 import (
 	gocontext "context"
-	"fmt"
 	"os"
 	"sync"
 	"text/tabwriter"
@@ -59,9 +58,6 @@ var pushCommand = cli.Command{
 		Name:  "manifest-type",
 		Usage: "media type of manifest digest",
 		Value: ocispec.MediaTypeImageManifest,
-	}, cli.StringSliceFlag{
-		Name:  "recipient",
-		Usage: "Recipient of the image is the person who can decrypt it",
 	}),
 	Action: func(context *cli.Context) error {
 		var (
@@ -94,24 +90,6 @@ var pushCommand = cli.Command{
 			desc = img.Target
 		}
 
-		if recipients := context.StringSlice("recipient"); len(recipients) > 0 {
-			gpgPubRingFile, err := images.ReadGPGPubRingFile()
-			if err != nil {
-				return err
-			}
-			cc := &images.CryptoConfig{
-				Ec:	&images.EncryptConfig{
-					GPGPubRingFile: gpgPubRingFile,
-					Recipients:     recipients,
-				},
-			}
-			img, err := client.ImageService().EncryptImage(ctx, local, local, cc, []int32{}, []string{})
-			if err != nil {
-				return err
-			}
-			fmt.Printf("local: %s,  img.Name: %s", local, img.Name)
-		}
-
 		resolver, err := commands.GetResolver(ctx, context)
 		if err != nil {
 			return err
diff --git a/images/encryption.go b/images/encryption.go
index f98799d..0f665f0 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -18,12 +18,13 @@ package images
 
 import (
 	"bytes"
-	"fmt"
 	"io/ioutil"
 	"net/mail"
 	"strings"
 
+	"github.com/containerd/containerd/errdefs"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
+	"github.com/pkg/errors"
 	"golang.org/x/crypto/openpgp"
 	"golang.org/x/crypto/openpgp/packet"
 )
@@ -109,7 +110,7 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 	}
 
 	if notFound {
-		return nil, fmt.Errorf(buffer.String())
+		return nil, errors.Wrapf(errdefs.ErrNotFound, buffer.String())
 	}
 
 	return filteredList, nil
@@ -129,13 +130,13 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 		return nil, nil, err
 	}
 	if len(filteredList) == 0 {
-		return nil, nil, fmt.Errorf("No keys were found to encrypt message to.\n")
+		return nil, nil, errors.Wrapf(errdefs.ErrInvalidArgument, "No keys were found to encrypt message to.\n")
 	}
 
 	switch ec.Operation {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
-			return nil, nil, fmt.Errorf("Support for adding recipients is not implemented.\n")
+			return nil, nil, errors.Wrapf(errdefs.ErrNotImplemented, "Support for adding recipients is not implemented.\n")
 		}
 		encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 	case OPERATION_REMOVE_RECIPIENTS:
@@ -183,7 +184,7 @@ func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor) ([]byte
 			return ioutil.ReadAll(md.UnverifiedBody)
 		}
 	}
-	return []byte{}, fmt.Errorf("No suitable decryption key was found.")
+	return []byte{}, errors.Wrapf(errdefs.ErrNotFound, "No suitable decryption key was found.")
 }
 
 // GetKeyIds gets the Key IDs for which the data are encrypted
diff --git a/images/gpg.go b/images/gpg.go
index 1074296..c069fd0 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -5,32 +5,84 @@ import (
 	"io/ioutil"
 	"os/exec"
 
+	"github.com/containerd/containerd/errdefs"
 	"github.com/mitchellh/go-homedir"
+	"github.com/pkg/errors"
 )
 
 // GPGVersion enum representing the versino of GPG client to use.
 type GPGVersion int
 
 const (
+	// GPGv2 signifies gpgv2+
 	GPGv2 GPGVersion = iota
+	// GPGv2 signifies gpgv1+
 	GPGv1
+	// GPGVersionUndetermined signifies gpg client version undetermined
 	GPGVersionUndetermined
 )
 
+// GPG
 type GPGClient interface {
+	// ReadGPGPubRingFile gets the byte sequence of the gpg public keyring
 	ReadGPGPubRingFile() ([]byte, error)
-	GetGPGPrivateKey(keyid uint64, password string) ([]byte, error)
+	// GetGPGPrivateKey gets the private key bytes of a keyid given a passphrase
+	GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error)
+	// GetSecretKeyDetails gets the details of a secret key
+	GetSecretKeyDetails(keyid uint64) ([]byte, bool, error)
+}
+
+// TODO: add comment and make private
+type gpgClient struct {
+	gpgHomeDir string
+}
+type gpgv2Client struct {
+	gpgClient
+}
+
+type gpgv1Client struct {
+	gpgClient
 }
 
 // GuessGPGVersion guesses the version of gpg. Defaults to gpg2 if exists, if
 // not defaults to regular gpg.
-func GuessGPGVersion() (GPGVersion, error) {
-	return GPGVersionUndetermined, nil
+func GuessGPGVersion() GPGVersion {
+	if err := exec.Command("gpg2", "--version").Run(); err == nil {
+		return GPGv2
+	} else if err := exec.Command("gpg", "--version").Run(); err == nil {
+		return GPGv1
+	} else {
+		return GPGVersionUndetermined
+	}
+}
+
+func NewGPGClient(version *GPGVersion, homedir string) (GPGClient, error) {
+	var gpgVersion GPGVersion
+	if version != nil {
+		gpgVersion = *version
+	} else {
+		gpgVersion = GuessGPGVersion()
+	}
+
+	switch gpgVersion {
+	case GPGv1:
+		return &gpgv1Client{
+			gpgClient: gpgClient{gpgHomeDir: homedir},
+		}, nil
+	case GPGv2:
+		return &gpgv2Client{
+			gpgClient: gpgClient{gpgHomeDir: homedir},
+		}, nil
+	case GPGVersionUndetermined:
+		return nil, fmt.Errorf("Unable to determine GPG version")
+	default:
+		return nil, fmt.Errorf("Unhandled case: NewGPGClient")
+	}
 }
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
-func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", password, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+func (_ *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
+	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", passphrase, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
 
 	cmd := exec.Command("gpg2", args...)
 
@@ -54,7 +106,7 @@ func GetGPGPrivateKey(keyid uint64, password string) ([]byte, error) {
 }
 
 // ReadGPGPubRingFile reads the GPG public key ring file
-func ReadGPGPubRingFile() ([]byte, error) {
+func (_ *gpgv2Client) ReadGPGPubRingFile() ([]byte, error) {
 	home, err := homedir.Dir()
 	if err != nil {
 		return nil, err
@@ -66,3 +118,106 @@ func ReadGPGPubRingFile() ([]byte, error) {
 	}
 	return gpgPubRingFile, nil
 }
+
+// GetSecretKeyDetails retrives the secret key details of key with keyid.
+// returns a byte array of the details and a bool if the key exists
+func (gc *gpgv2Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
+	var args []string
+
+	if gc.gpgHomeDir != "" {
+		args = append([]string{"--homedir", gc.gpgHomeDir})
+	}
+	args = append(args, "-K", fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, false, err
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, false, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
+	}
+
+	return keydata, err2 == nil, err2
+}
+
+// GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
+func (_ *gpgv1Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
+	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", passphrase, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, err
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, errors.Wrapf(errdefs.ErrUnknown, "Error from gpg2: %s\n", message)
+	}
+
+	return keydata, err2
+}
+
+// ReadGPGPubRingFile reads the GPG public key ring file
+func (_ *gpgv1Client) ReadGPGPubRingFile() ([]byte, error) {
+	var pubringfn string
+	home, err := homedir.Dir()
+	if err != nil {
+		return nil, err
+		pubringfn = fmt.Sprintf("%s/.gnupg/pubring.gpg", home)
+	}
+
+	gpgPubRingFile, err := ioutil.ReadFile(pubringfn)
+	if err != nil {
+		return nil, errors.Wrapf(errdefs.ErrInvalidArgument, "Could not read Public keyring file %s: %v", pubringfn, err)
+	}
+	return gpgPubRingFile, nil
+}
+
+// GetSecretKeyDetails retrives the secret key details of key with keyid.
+// returns a byte array of the details and a bool if the key exists
+func (gc *gpgv1Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
+	var args []string
+
+	if gc.gpgHomeDir != "" {
+		args = append([]string{"--homedir", gc.gpgHomeDir})
+	}
+	args = append(args, "-K", fmt.Sprintf("0x%x", keyid))
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, false, err
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, false, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
+	}
+
+	return keydata, err2 == nil, err2
+}
diff --git a/images/image.go b/images/image.go
index a5fd6f3..3f719f9 100644
--- a/images/image.go
+++ b/images/image.go
@@ -67,7 +67,7 @@ type LayerInfo struct {
 	KeyIds []uint64
 	// The Digest of the layer
 	Digest string
-	// The Encryption algorithm used for encrypting the layer
+	// The Encryption method used for encrypting the layer
 	Encryption string
 	// The size of the layer file
 	FileSize int64
@@ -76,9 +76,10 @@ type LayerInfo struct {
 }
 
 type LayerFilter struct {
-	// IDs of layers to touch
+	// IDs of layers to touch; may be negative number to start from topmost layer
+	// empty array means 'all layers'
 	Layers []int32
-	// Platforms to touch
+	// Platforms to touch; empty array means 'all platforms'
 	Platforms []ocispec.Platform
 }
 
@@ -566,16 +567,13 @@ func assembleEncryptedMessage(encBody []byte, keys [][]byte) []byte {
 // encodeWrappedKeys encodes wrapped openpgp keys to a string readable ','
 // separated base64 strings.
 func encodeWrappedKeys(keys [][]byte) string {
-	keyString := ""
+	var keyArray []string
+
 	for _, k := range keys {
-		if keyString == "" {
-			keyString += base64.StdEncoding.EncodeToString(k)
-		} else {
-			keyString += "," + base64.StdEncoding.EncodeToString(k)
-		}
+		keyArray = append(keyArray, base64.StdEncoding.EncodeToString(k))
 	}
 
-	return keyString
+	return strings.Join(keyArray, ",")
 }
 
 // decodeWrappedKeys decodes wrapped openpgp keys from string readable ','
@@ -595,7 +593,7 @@ func decodeWrappedKeys(keys string) ([][]byte, error) {
 	return keyBytes, nil
 }
 
-// isDecriptorALayer determines whether the given Descriptor describes a layer
+// isDecriptorALayer determines whether the given Descriptor describes an image layer
 func isDescriptorALayer(desc ocispec.Descriptor) bool {
 	switch desc.MediaType {
 	case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer,
@@ -617,16 +615,15 @@ func countLayers(desc []ocispec.Descriptor) int32 {
 	return c
 }
 
-// isUserSelectedLayer checks whether we need to modify this layer given its number
+// isUserSelectedLayer checks whether the a layer is user selected given its number
 // A layer can be described with its (positive) index number or its negative number, which
-// is counted relative to the last one
+// is counted relative to the topmost one (-1)
 func isUserSelectedLayer(layerNum, layersTotal int32, layers []int32) bool {
 	if len(layers) == 0 {
 		// convenience for the user; none given means 'all'
 		return true
 	}
 	negNumber := layerNum - layersTotal
-	fmt.Printf("%d vs %d\n", layerNum, negNumber)
 
 	for _, l := range layers {
 		if l == negNumber || l == layerNum {
@@ -664,7 +661,6 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 
 	layersTotal := countLayers(children)
 
-	//fmt.Printf("metadata/image.go EncryptChildren(): got %d children\n", len(children))
 	var newLayers []ocispec.Descriptor
 	var config ocispec.Descriptor
 	modified := false
@@ -705,7 +701,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	}
 
 	if modified && len(newLayers) > 0 {
-		nM := ocispec.Manifest{
+		newManifest := ocispec.Manifest{
 			Versioned: specs.Versioned{
 				SchemaVersion: 2,
 			},
@@ -713,30 +709,29 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			Layers: newLayers,
 		}
 
-		mb, err := json.MarshalIndent(nM, "", "   ")
+		mb, err := json.MarshalIndent(newManifest, "", "   ")
 		if err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to marshal image")
 		}
 
-		nDesc := ocispec.Descriptor{
-			MediaType: MediaTypeDockerSchema2Manifest, //ocispec.MediaTypeImageManifest,//MediaTypeDockerSchema2Manifest,
+		newDesc := ocispec.Descriptor{
+			MediaType: MediaTypeDockerSchema2Manifest,
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
 			Platform:  desc.Platform,
 		}
+
 		labels := map[string]string{}
-		labels["containerd.io/gc.ref.content.0"] = nM.Config.Digest.String()
-		for i, ch := range nM.Layers {
+		labels["containerd.io/gc.ref.content.0"] = newManifest.Config.Digest.String()
+		for i, ch := range newManifest.Layers {
 			labels[fmt.Sprintf("containerd.io/gc.ref.content.%d", i+1)] = ch.Digest.String()
 		}
 
-		fmt.Printf("   old desc %s now written as %s\n", desc.Digest, nDesc.Digest)
-
-		ref := fmt.Sprintf("manifest-%s", nDesc.Digest.String())
-		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), nDesc, content.WithLabels(labels)); err != nil {
+		ref := fmt.Sprintf("manifest-%s", newDesc.Digest.String())
+		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to write config")
 		}
-		return nDesc, true, nil
+		return newDesc, true, nil
 	}
 
 	return desc, modified, nil
@@ -787,7 +782,6 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
 		}
-		fmt.Printf("   old Index %s now written as %s\n", desc.Digest, nDesc.Digest)
 
 		labels := map[string]string{}
 		for i, m := range newIndex.Manifests {
@@ -864,20 +858,20 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP:
-		kids, err := GetKeyIds(desc)
+		keyIds, err := GetKeyIds(desc)
 		if err != nil {
 			return []LayerInfo{}, err
 		}
 		li := LayerInfo{
-			KeyIds:     kids,
+			KeyIds:     keyIds,
 			Digest:     desc.Digest.String(),
-			Encryption: "gpg",
+			Encryption: "pgp",
 			FileSize:   desc.Size,
 			Id:         uint32(layerNum),
 		}
 		lis = append(lis, li)
 	default:
-		return []LayerInfo{}, errors.Wrapf(nil, "GetImageLayerInfo: Unhandled media type %s", desc.MediaType)
+		return []LayerInfo{}, errors.Wrapf(errdefs.ErrInvalidArgument, "GetImageLayerInfo: Unhandled media type %s", desc.MediaType)
 	}
 
 	return lis, nil
diff --git a/images/openpgp.go b/images/openpgp.go
index afb2ba1..0ec9301 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -10,6 +10,8 @@ import (
 
 	"crypto"
 	"crypto/rand"
+	"github.com/containerd/containerd/errdefs"
+	"github.com/pkg/errors"
 	"golang.org/x/crypto/openpgp"
 	"golang.org/x/crypto/openpgp/packet"
 )
@@ -57,7 +59,7 @@ func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList
 		ekbuf := bytes.NewBuffer(ek)
 		p, err := packet.Read(ekbuf)
 		if err != nil {
-			return [][]byte{}, fmt.Errorf("Err reading enc key packet: %v", err)
+			return [][]byte{}, errors.Wrapf(errdefs.ErrInvalidArgument, "Err reading enc key packet: %v", err)
 		}
 		pek := p.(*packet.EncryptedKey)
 
@@ -97,7 +99,7 @@ func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList)
 	promptFunc := func(key []openpgp.Key, symm bool) ([]byte, error) {
 		for _, k := range key {
 			if symm {
-				return nil, fmt.Errorf("Not handled")
+				return nil, errors.Wrapf(errdefs.ErrNotImplemented, "Not handled")
 			} else {
 				k.PrivateKey.Decrypt([]byte("hidden!"))
 			}
@@ -107,12 +109,12 @@ func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList)
 	messageIn := bytes.NewBuffer(message)
 	md, err := openpgp.ReadMessage(messageIn, kring, promptFunc, DefaultEncryptConfig)
 	if err != nil {
-		return nil, fmt.Errorf("Unable to read message: %v", err)
+		return nil, errors.Wrapf(err, "Unable to read message: %v", err)
 	}
 
 	plaintext, err := ioutil.ReadAll(md.UnverifiedBody)
 	if err != nil {
-		return nil, fmt.Errorf("error reading encrypted contents: %s", err)
+		return nil, errors.Wrapf(err, "error reading encrypted contents: %s", err)
 	}
 
 	return plaintext, nil
-- 
2.7.4


From ff35ee070d46e4dc917274ae0ef5f3118dd6a6fc Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 15:33:44 -0400
Subject: [PATCH 41/79] Move some code gathering private keys into their own
 function for reuse

---
 cmd/ctr/commands/images/decrypt.go | 101 ++++++++++++++++++++-----------------
 1 file changed, 55 insertions(+), 46 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 0343106..93cd01d 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -90,14 +90,14 @@ var decryptCommand = cli.Command{
 
 		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
 
-		LayerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
+		layerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
 		if err != nil {
 			return err
 		}
 
 		isEncrypted := false
-		for i := 0; i < len(LayerInfos); i++ {
-			if len(LayerInfos[i].KeyIds) > 0 {
+		for i := 0; i < len(layerInfos); i++ {
+			if len(layerInfos[i].KeyIds) > 0 {
 				isEncrypted = true
 			}
 		}
@@ -106,49 +106,8 @@ var decryptCommand = cli.Command{
 			return nil
 		}
 
-		keyIdMap := make(map[uint64]images.DecryptKeyData)
-
-		// we need one key per encrypted layer
-		for _, LayerInfo := range LayerInfos {
-			found := false
-			for _, keyid := range LayerInfo.KeyIds {
-				if _, ok := keyIdMap[keyid]; ok {
-					// password already there
-					found = true
-					break
-				}
-				// do we have this key?
-				keyinfo, haveKey, err := gpgClient.GetSecretKeyDetails(keyid)
-				// this may fail if the key is not here; we ignore the error
-				if !haveKey {
-					// key not on this system
-					continue
-				}
-
-				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
-				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
-
-				password, err := terminal.ReadPassword(int(syscall.Stdin))
-				fmt.Printf("\n")
-				if err != nil {
-					return err
-				}
-
-				keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
-				if err != nil {
-					return err
-				}
-				keyIdMap[keyid] = images.DecryptKeyData{
-					KeyData:         keydata,
-					KeyDataPassword: password,
-				}
-				found = true
-				break
-			}
-			if !found && len(LayerInfo.KeyIds) > 0 {
-				return fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", LayerInfo.Id, LayerInfo.Platform, LayerInfo.KeyIds)
-			}
-		}
+		keyIdMap, err := getPrivateKeys(layerInfos, gpgClient)
+
 		fmt.Printf("\n")
 		_, err = client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
 			Dc: &images.DecryptConfig{
@@ -174,3 +133,53 @@ func addToSet(set, add []uint64) []uint64 {
 	}
 	return set
 }
+
+// getPrivateKeys walks the list of layerInfos and determines which keys are on this system
+// and prompts for the passwords for those that are available. If one layer does not have
+// a private key an error is thrown.
+func getPrivateKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (map[uint64]images.DecryptKeyData, error) {
+	keyIdMap := make(map[uint64]images.DecryptKeyData)
+
+	// we need one key per encrypted layer
+	for _, layerInfo := range layerInfos {
+		found := false
+		for _, keyid := range layerInfo.KeyIds {
+			if _, ok := keyIdMap[keyid]; ok {
+				// password already there
+				found = true
+				break
+			}
+			// do we have this key?
+			keyinfo, haveKey, err := gpgClient.GetSecretKeyDetails(keyid)
+			// this may fail if the key is not here; we ignore the error
+			if !haveKey {
+				// key not on this system
+				continue
+			}
+
+			fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
+			fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
+
+			password, err := terminal.ReadPassword(int(syscall.Stdin))
+			fmt.Printf("\n")
+			if err != nil {
+				return keyIdMap, err
+			}
+
+			keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
+			if err != nil {
+				return keyIdMap, err
+			}
+			keyIdMap[keyid] = images.DecryptKeyData{
+				KeyData:         keydata,
+				KeyDataPassword: password,
+			}
+			found = true
+			break
+		}
+		if !found && len(layerInfo.KeyIds) > 0 {
+			return keyIdMap, fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, layerInfo.KeyIds)
+		}
+	}
+	return keyIdMap, nil
+}
-- 
2.7.4


From a4e0daf0759c64f16921d8631edbd5d60deee5d7 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 16:05:51 -0400
Subject: [PATCH 42/79] Also passing DecrytConfig through as part of encryption
 so we can add recipients

---
 api/next.pb.txt                     |  12 +-
 api/services/images/v1/images.pb.go | 306 +++++++++++++++++++++---------------
 api/services/images/v1/images.proto |   4 +-
 cmd/ctr/commands/images/encrypt.go  |  15 +-
 image_store.go                      |  15 +-
 images/encryption.go                |   9 +-
 images/openpgp.go                   |   4 +
 services/images/local.go            |  18 ++-
 8 files changed, 246 insertions(+), 137 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 341d7b0..8bd1bb1 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2241,6 +2241,14 @@ file {
       type: TYPE_INT32
       json_name: "operation"
     }
+    field {
+      name: "dc"
+      number: 4
+      label: LABEL_OPTIONAL
+      type: TYPE_MESSAGE
+      type_name: ".containerd.services.images.v1.DecryptConfig"
+      json_name: "dc"
+    }
   }
   message_type {
     name: "DecryptKeyData"
@@ -2308,12 +2316,12 @@ file {
       json_name: "newName"
     }
     field {
-      name: "cc"
+      name: "ec"
       number: 3
       label: LABEL_OPTIONAL
       type: TYPE_MESSAGE
       type_name: ".containerd.services.images.v1.EncryptConfig"
-      json_name: "cc"
+      json_name: "ec"
     }
     field {
       name: "layers"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index d2916ee..9170ae4 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -182,17 +182,19 @@ func (m *DeleteImageRequest) Reset()                    { *m = DeleteImageReques
 func (*DeleteImageRequest) ProtoMessage()               {}
 func (*DeleteImageRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{9} }
 
-// CryptConfig serves to pass keys used for encryption and decryption
+// EncryptConfig holds recipients' identifiers and the gpg public key ring
 type EncryptConfig struct {
-	Recipients    []string `protobuf:"bytes,1,rep,name=recipients" json:"recipients,omitempty"`
-	Gpgpubkeyring []byte   `protobuf:"bytes,2,opt,name=gpgpubkeyring,proto3" json:"gpgpubkeyring,omitempty"`
-	Operation     int32    `protobuf:"varint,3,opt,name=operation,proto3" json:"operation,omitempty"`
+	Recipients    []string       `protobuf:"bytes,1,rep,name=recipients" json:"recipients,omitempty"`
+	Gpgpubkeyring []byte         `protobuf:"bytes,2,opt,name=gpgpubkeyring,proto3" json:"gpgpubkeyring,omitempty"`
+	Operation     int32          `protobuf:"varint,3,opt,name=operation,proto3" json:"operation,omitempty"`
+	Dc            *DecryptConfig `protobuf:"bytes,4,opt,name=dc" json:"dc,omitempty"`
 }
 
 func (m *EncryptConfig) Reset()                    { *m = EncryptConfig{} }
 func (*EncryptConfig) ProtoMessage()               {}
 func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{10} }
 
+// DecryptKeyData holds the private key data and the password for the private key
 type DecryptKeyData struct {
 	KeyData         []byte `protobuf:"bytes,1,opt,name=keyData,proto3" json:"keyData,omitempty"`
 	KeyDataPassword []byte `protobuf:"bytes,2,opt,name=keyDataPassword,proto3" json:"keyDataPassword,omitempty"`
@@ -202,6 +204,8 @@ func (m *DecryptKeyData) Reset()                    { *m = DecryptKeyData{} }
 func (*DecryptKeyData) ProtoMessage()               {}
 func (*DecryptKeyData) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{11} }
 
+// DecrypConfig holds the Ids of public keys and their corresponding private keys
+// needed for decrypting data
 type DecryptConfig struct {
 	KeyIdMap map[uint64]*DecryptKeyData `protobuf:"bytes,1,rep,name=keyIdMap" json:"keyIdMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
 }
@@ -213,7 +217,7 @@ func (*DecryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages
 type EncryptImageRequest struct {
 	Name      string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
 	NewName   string         `protobuf:"bytes,2,opt,name=newName,proto3" json:"newName,omitempty"`
-	Cc        *EncryptConfig `protobuf:"bytes,3,opt,name=cc" json:"cc,omitempty"`
+	Ec        *EncryptConfig `protobuf:"bytes,3,opt,name=ec" json:"ec,omitempty"`
 	Layers    []int32        `protobuf:"varint,4,rep,packed,name=layers" json:"layers,omitempty"`
 	Platforms []string       `protobuf:"bytes,5,rep,name=platforms" json:"platforms,omitempty"`
 }
@@ -998,6 +1002,16 @@ func (m *EncryptConfig) MarshalTo(dAtA []byte) (int, error) {
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.Operation))
 	}
+	if m.Dc != nil {
+		dAtA[i] = 0x22
+		i++
+		i = encodeVarintImages(dAtA, i, uint64(m.Dc.Size()))
+		n10, err := m.Dc.MarshalTo(dAtA[i:])
+		if err != nil {
+			return 0, err
+		}
+		i += n10
+	}
 	return i, nil
 }
 
@@ -1065,11 +1079,11 @@ func (m *DecryptConfig) MarshalTo(dAtA []byte) (int, error) {
 				dAtA[i] = 0x12
 				i++
 				i = encodeVarintImages(dAtA, i, uint64(v.Size()))
-				n10, err := v.MarshalTo(dAtA[i:])
+				n11, err := v.MarshalTo(dAtA[i:])
 				if err != nil {
 					return 0, err
 				}
-				i += n10
+				i += n11
 			}
 		}
 	}
@@ -1103,33 +1117,33 @@ func (m *EncryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(len(m.NewName)))
 		i += copy(dAtA[i:], m.NewName)
 	}
-	if m.Cc != nil {
+	if m.Ec != nil {
 		dAtA[i] = 0x1a
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(m.Cc.Size()))
-		n11, err := m.Cc.MarshalTo(dAtA[i:])
+		i = encodeVarintImages(dAtA, i, uint64(m.Ec.Size()))
+		n12, err := m.Ec.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n11
+		i += n12
 	}
 	if len(m.Layers) > 0 {
-		dAtA13 := make([]byte, len(m.Layers)*10)
-		var j12 int
+		dAtA14 := make([]byte, len(m.Layers)*10)
+		var j13 int
 		for _, num1 := range m.Layers {
 			num := uint64(num1)
 			for num >= 1<<7 {
-				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j12++
+				j13++
 			}
-			dAtA13[j12] = uint8(num)
-			j12++
+			dAtA14[j13] = uint8(num)
+			j13++
 		}
 		dAtA[i] = 0x22
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j12))
-		i += copy(dAtA[i:], dAtA13[:j12])
+		i = encodeVarintImages(dAtA, i, uint64(j13))
+		i += copy(dAtA[i:], dAtA14[:j13])
 	}
 	if len(m.Platforms) > 0 {
 		for _, s := range m.Platforms {
@@ -1167,11 +1181,11 @@ func (m *EncryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n14, err := m.Image.MarshalTo(dAtA[i:])
+	n15, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n14
+	i += n15
 	return i, nil
 }
 
@@ -1206,29 +1220,29 @@ func (m *DecryptImageRequest) MarshalTo(dAtA []byte) (int, error) {
 		dAtA[i] = 0x1a
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.Dc.Size()))
-		n15, err := m.Dc.MarshalTo(dAtA[i:])
+		n16, err := m.Dc.MarshalTo(dAtA[i:])
 		if err != nil {
 			return 0, err
 		}
-		i += n15
+		i += n16
 	}
 	if len(m.Layers) > 0 {
-		dAtA17 := make([]byte, len(m.Layers)*10)
-		var j16 int
+		dAtA18 := make([]byte, len(m.Layers)*10)
+		var j17 int
 		for _, num1 := range m.Layers {
 			num := uint64(num1)
 			for num >= 1<<7 {
-				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j16++
+				j17++
 			}
-			dAtA17[j16] = uint8(num)
-			j16++
+			dAtA18[j17] = uint8(num)
+			j17++
 		}
 		dAtA[i] = 0x22
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j16))
-		i += copy(dAtA[i:], dAtA17[:j16])
+		i = encodeVarintImages(dAtA, i, uint64(j17))
+		i += copy(dAtA[i:], dAtA18[:j17])
 	}
 	if len(m.Platforms) > 0 {
 		for _, s := range m.Platforms {
@@ -1266,11 +1280,11 @@ func (m *DecryptImageResponse) MarshalTo(dAtA []byte) (int, error) {
 	dAtA[i] = 0xa
 	i++
 	i = encodeVarintImages(dAtA, i, uint64(m.Image.Size()))
-	n18, err := m.Image.MarshalTo(dAtA[i:])
+	n19, err := m.Image.MarshalTo(dAtA[i:])
 	if err != nil {
 		return 0, err
 	}
-	i += n18
+	i += n19
 	return i, nil
 }
 
@@ -1296,22 +1310,22 @@ func (m *GetImageLayerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
 		i += copy(dAtA[i:], m.Name)
 	}
 	if len(m.Layers) > 0 {
-		dAtA20 := make([]byte, len(m.Layers)*10)
-		var j19 int
+		dAtA21 := make([]byte, len(m.Layers)*10)
+		var j20 int
 		for _, num1 := range m.Layers {
 			num := uint64(num1)
 			for num >= 1<<7 {
-				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j19++
+				j20++
 			}
-			dAtA20[j19] = uint8(num)
-			j19++
+			dAtA21[j20] = uint8(num)
+			j20++
 		}
 		dAtA[i] = 0x12
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j19))
-		i += copy(dAtA[i:], dAtA20[:j19])
+		i = encodeVarintImages(dAtA, i, uint64(j20))
+		i += copy(dAtA[i:], dAtA21[:j20])
 	}
 	if len(m.Platforms) > 0 {
 		for _, s := range m.Platforms {
@@ -1352,21 +1366,21 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 		i = encodeVarintImages(dAtA, i, uint64(m.ID))
 	}
 	if len(m.KeyIds) > 0 {
-		dAtA22 := make([]byte, len(m.KeyIds)*10)
-		var j21 int
+		dAtA23 := make([]byte, len(m.KeyIds)*10)
+		var j22 int
 		for _, num := range m.KeyIds {
 			for num >= 1<<7 {
-				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
+				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
 				num >>= 7
-				j21++
+				j22++
 			}
-			dAtA22[j21] = uint8(num)
-			j21++
+			dAtA23[j22] = uint8(num)
+			j22++
 		}
 		dAtA[i] = 0x12
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(j21))
-		i += copy(dAtA[i:], dAtA22[:j21])
+		i = encodeVarintImages(dAtA, i, uint64(j22))
+		i += copy(dAtA[i:], dAtA23[:j22])
 	}
 	if len(m.Digest) > 0 {
 		dAtA[i] = 0x1a
@@ -1566,6 +1580,10 @@ func (m *EncryptConfig) Size() (n int) {
 	if m.Operation != 0 {
 		n += 1 + sovImages(uint64(m.Operation))
 	}
+	if m.Dc != nil {
+		l = m.Dc.Size()
+		n += 1 + l + sovImages(uint64(l))
+	}
 	return n
 }
 
@@ -1613,8 +1631,8 @@ func (m *EncryptImageRequest) Size() (n int) {
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
-	if m.Cc != nil {
-		l = m.Cc.Size()
+	if m.Ec != nil {
+		l = m.Ec.Size()
 		n += 1 + l + sovImages(uint64(l))
 	}
 	if len(m.Layers) > 0 {
@@ -1883,6 +1901,7 @@ func (this *EncryptConfig) String() string {
 		`Recipients:` + fmt.Sprintf("%v", this.Recipients) + `,`,
 		`Gpgpubkeyring:` + fmt.Sprintf("%v", this.Gpgpubkeyring) + `,`,
 		`Operation:` + fmt.Sprintf("%v", this.Operation) + `,`,
+		`Dc:` + strings.Replace(fmt.Sprintf("%v", this.Dc), "DecryptConfig", "DecryptConfig", 1) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1925,7 +1944,7 @@ func (this *EncryptImageRequest) String() string {
 	s := strings.Join([]string{`&EncryptImageRequest{`,
 		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
 		`NewName:` + fmt.Sprintf("%v", this.NewName) + `,`,
-		`Cc:` + strings.Replace(fmt.Sprintf("%v", this.Cc), "EncryptConfig", "EncryptConfig", 1) + `,`,
+		`Ec:` + strings.Replace(fmt.Sprintf("%v", this.Ec), "EncryptConfig", "EncryptConfig", 1) + `,`,
 		`Layers:` + fmt.Sprintf("%v", this.Layers) + `,`,
 		`Platforms:` + fmt.Sprintf("%v", this.Platforms) + `,`,
 		`}`,
@@ -3180,6 +3199,39 @@ func (m *EncryptConfig) Unmarshal(dAtA []byte) error {
 					break
 				}
 			}
+		case 4:
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field Dc", wireType)
+			}
+			var msglen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
+				}
+				if iNdEx >= l {
+					return io.ErrUnexpectedEOF
+				}
+				b := dAtA[iNdEx]
+				iNdEx++
+				msglen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
+				}
+			}
+			if msglen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + msglen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			if m.Dc == nil {
+				m.Dc = &DecryptConfig{}
+			}
+			if err := m.Dc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+				return err
+			}
+			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3564,7 +3616,7 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field Cc", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field Ec", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -3588,10 +3640,10 @@ func (m *EncryptImageRequest) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.Cc == nil {
-				m.Cc = &EncryptConfig{}
+			if m.Ec == nil {
+				m.Ec = &EncryptConfig{}
 			}
-			if err := m.Cc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
+			if err := m.Ec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
 				return err
 			}
 			iNdEx = postIndex
@@ -4697,75 +4749,75 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 1107 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
-	0x10, 0x36, 0xa9, 0x1f, 0x5b, 0x23, 0xbb, 0x49, 0x36, 0x86, 0xc1, 0xb2, 0xa9, 0x2c, 0x10, 0x29,
-	0xa0, 0x43, 0x43, 0xd5, 0xca, 0xa1, 0xa9, 0x1d, 0x14, 0x8d, 0x2d, 0x27, 0x35, 0xe2, 0x04, 0x05,
-	0x93, 0xa6, 0x46, 0x2f, 0x01, 0x4d, 0xae, 0x58, 0x56, 0x12, 0xc9, 0x72, 0x57, 0x36, 0xd8, 0x53,
-	0x4f, 0xbd, 0xb6, 0x40, 0x1f, 0xa3, 0x0f, 0xd0, 0x57, 0xf0, 0xb1, 0x40, 0x2f, 0x3d, 0xa5, 0x8d,
-	0x0f, 0x7d, 0x8e, 0x62, 0x7f, 0x68, 0x91, 0x92, 0x12, 0x4a, 0xb1, 0x6f, 0x3b, 0xc3, 0xf9, 0x66,
-	0x66, 0xbf, 0xdd, 0xfd, 0x76, 0x09, 0x5d, 0xcf, 0xa7, 0xdf, 0x8d, 0x8e, 0x4d, 0x27, 0x1c, 0xb6,
-	0x9d, 0x30, 0xa0, 0xb6, 0x1f, 0xe0, 0xd8, 0xcd, 0x0e, 0xed, 0xc8, 0x6f, 0x13, 0x1c, 0x9f, 0xf8,
-	0x0e, 0x26, 0x6d, 0x7f, 0x68, 0x7b, 0x98, 0xb4, 0x4f, 0xb6, 0xe4, 0xc8, 0x8c, 0xe2, 0x90, 0x86,
-	0xe8, 0xc3, 0x71, 0xbc, 0x99, 0xc6, 0x9a, 0x32, 0xe2, 0x64, 0x4b, 0x5f, 0xf7, 0x42, 0x2f, 0xe4,
-	0x91, 0x6d, 0x36, 0x12, 0x20, 0xfd, 0x03, 0x2f, 0x0c, 0xbd, 0x01, 0x6e, 0x73, 0xeb, 0x78, 0xd4,
-	0x6b, 0xe3, 0x61, 0x44, 0x13, 0xf9, 0xb1, 0x39, 0xf9, 0xb1, 0xe7, 0xe3, 0x81, 0xfb, 0x72, 0x68,
-	0x93, 0xbe, 0x8c, 0xd8, 0x9c, 0x8c, 0xa0, 0xfe, 0x10, 0x13, 0x6a, 0x0f, 0x23, 0x19, 0xb0, 0x33,
-	0xd7, 0xd4, 0x68, 0x12, 0x61, 0xd2, 0x76, 0x31, 0x71, 0x62, 0x3f, 0xa2, 0x61, 0x2c, 0xc0, 0xc6,
-	0x7f, 0x2a, 0x54, 0x0e, 0xd8, 0x04, 0x10, 0x82, 0x72, 0x60, 0x0f, 0xb1, 0xa6, 0x34, 0x95, 0x56,
-	0xcd, 0xe2, 0x63, 0xf4, 0x25, 0x54, 0x07, 0xf6, 0x31, 0x1e, 0x10, 0x4d, 0x6d, 0x96, 0x5a, 0xf5,
-	0xce, 0x27, 0xe6, 0x5b, 0x09, 0x30, 0x79, 0x26, 0xf3, 0x90, 0x43, 0xf6, 0x03, 0x1a, 0x27, 0x96,
-	0xc4, 0xa3, 0x6d, 0xa8, 0x52, 0x3b, 0xf6, 0x30, 0xd5, 0x4a, 0x4d, 0xa5, 0x55, 0xef, 0xdc, 0xca,
-	0x66, 0xe2, 0xbd, 0x99, 0xdd, 0x8b, 0xde, 0x76, 0xcb, 0x67, 0xaf, 0x36, 0x97, 0x2c, 0x89, 0x40,
-	0x7b, 0x00, 0x4e, 0x8c, 0x6d, 0x8a, 0xdd, 0x97, 0x36, 0xd5, 0x96, 0x39, 0x5e, 0x37, 0x05, 0x2d,
-	0x66, 0x4a, 0x8b, 0xf9, 0x3c, 0xa5, 0x65, 0x77, 0x85, 0xa1, 0x7f, 0xfd, 0x67, 0x53, 0xb1, 0x6a,
-	0x12, 0xf7, 0x80, 0x27, 0x19, 0x45, 0x6e, 0x9a, 0x64, 0x65, 0x91, 0x24, 0x12, 0xf7, 0x80, 0xea,
-	0x9f, 0x41, 0x3d, 0x33, 0x39, 0x74, 0x1d, 0x4a, 0x7d, 0x9c, 0x48, 0xc6, 0xd8, 0x10, 0xad, 0x43,
-	0xe5, 0xc4, 0x1e, 0x8c, 0xb0, 0xa6, 0x72, 0x9f, 0x30, 0xb6, 0xd5, 0x7b, 0x8a, 0xf1, 0x11, 0x5c,
-	0x7b, 0x84, 0x29, 0x27, 0xc8, 0xc2, 0x3f, 0x8c, 0x30, 0xa1, 0xb3, 0x18, 0x37, 0x9e, 0xc2, 0xf5,
-	0x71, 0x18, 0x89, 0xc2, 0x80, 0x60, 0xb4, 0x0d, 0x15, 0x4e, 0x31, 0x0f, 0xac, 0x77, 0x6e, 0xcf,
-	0xb3, 0x08, 0x96, 0x80, 0x18, 0x2f, 0x00, 0xed, 0x71, 0x0e, 0x72, 0x95, 0xbf, 0x78, 0x87, 0x8c,
-	0x72, 0x51, 0x64, 0xde, 0x6f, 0xe0, 0x66, 0x2e, 0xaf, 0x6c, 0xf5, 0xf2, 0x89, 0x7f, 0x53, 0x00,
-	0x7d, 0xcd, 0x09, 0xbf, 0xda, 0x8e, 0xd1, 0x0e, 0xd4, 0xc5, 0x42, 0xf2, 0xc3, 0xc5, 0x17, 0x68,
-	0xd6, 0x0e, 0x78, 0xc8, 0xce, 0xdf, 0x13, 0x9b, 0xf4, 0x2d, 0xb9, 0x5f, 0xd8, 0x98, 0x4d, 0x37,
-	0xd7, 0xd4, 0x95, 0x4d, 0xf7, 0x0e, 0xdc, 0x38, 0xf4, 0x89, 0x58, 0x70, 0x92, 0x4e, 0x56, 0x83,
-	0xe5, 0x9e, 0x3f, 0xa0, 0x38, 0x26, 0x9a, 0xd2, 0x2c, 0xb5, 0x6a, 0x56, 0x6a, 0x1a, 0x47, 0x80,
-	0xb2, 0xe1, 0xb2, 0x8d, 0x5d, 0xa8, 0x8a, 0x22, 0x3c, 0x7c, 0xb1, 0x3e, 0x24, 0xd2, 0xb8, 0x0f,
-	0xa8, 0x8b, 0x07, 0x78, 0x82, 0xf6, 0x59, 0xa2, 0x80, 0xa0, 0x4c, 0x92, 0xc0, 0xe1, 0x0c, 0xae,
-	0x58, 0x7c, 0x6c, 0x10, 0x58, 0xdb, 0x0f, 0x9c, 0x38, 0x89, 0xe8, 0x5e, 0x18, 0xf4, 0x7c, 0x0f,
-	0x35, 0x00, 0x62, 0xec, 0xf8, 0x91, 0x8f, 0x03, 0x9a, 0xce, 0x22, 0xe3, 0x41, 0xb7, 0x61, 0xcd,
-	0x8b, 0xbc, 0x68, 0x74, 0xdc, 0xc7, 0x49, 0xec, 0x07, 0x1e, 0xcf, 0xb6, 0x6a, 0xe5, 0x9d, 0xe8,
-	0x16, 0xd4, 0xc2, 0x08, 0xc7, 0x36, 0xf5, 0xc3, 0x80, 0x0b, 0x47, 0xc5, 0x1a, 0x3b, 0x8c, 0xe7,
-	0xf0, 0x5e, 0x17, 0xf3, 0xa2, 0x8f, 0x71, 0xd2, 0xb5, 0xa9, 0xcd, 0x88, 0xeb, 0x8b, 0x21, 0xef,
-	0x78, 0xd5, 0x4a, 0x4d, 0xd4, 0x82, 0x6b, 0x72, 0xf8, 0x95, 0x4d, 0xc8, 0x69, 0x18, 0xbb, 0xb2,
-	0xe2, 0xa4, 0xdb, 0xf8, 0x4b, 0x81, 0x35, 0x99, 0x56, 0xce, 0xe5, 0x05, 0xac, 0xf4, 0x71, 0x72,
-	0xe0, 0x3e, 0xb1, 0x23, 0x49, 0xf0, 0x76, 0x01, 0xc1, 0x39, 0xbc, 0xf9, 0x58, 0x82, 0x85, 0x22,
-	0x5e, 0xe4, 0xd2, 0xbf, 0x87, 0xb5, 0xdc, 0xa7, 0xac, 0x9e, 0x94, 0x85, 0x9e, 0xec, 0x65, 0xf5,
-	0xa4, 0xde, 0xb9, 0x33, 0x5f, 0x5d, 0x49, 0x47, 0x56, 0x7e, 0xfe, 0x50, 0xe0, 0xa6, 0x5c, 0xa1,
-	0xc2, 0x05, 0xd6, 0x60, 0x39, 0xc0, 0xa7, 0x4f, 0x99, 0x5b, 0xc8, 0x58, 0x6a, 0xa2, 0xfb, 0xa0,
-	0x3a, 0x8e, 0x54, 0xf0, 0x8f, 0x0b, 0x7a, 0xc9, 0xed, 0x07, 0x4b, 0x75, 0x1c, 0xb4, 0xc1, 0x6e,
-	0x93, 0x84, 0xed, 0xea, 0x72, 0xb3, 0xd4, 0xaa, 0x58, 0xd2, 0x62, 0xab, 0x1c, 0x0d, 0x6c, 0xda,
-	0x0b, 0xe3, 0x21, 0xd1, 0x2a, 0x7c, 0xab, 0x8c, 0x1d, 0xc6, 0x11, 0xac, 0xe7, 0x1b, 0xbf, 0xb2,
-	0xb3, 0xc7, 0x38, 0x91, 0x8c, 0x5d, 0x8e, 0x13, 0x77, 0x5e, 0x4e, 0x72, 0xfb, 0xc2, 0x52, 0xdd,
-	0x4b, 0x70, 0x92, 0x6f, 0xfc, 0xca, 0x38, 0x71, 0x41, 0x4b, 0xef, 0x9f, 0x43, 0xd6, 0xc9, 0x41,
-	0xd0, 0x0b, 0xdf, 0xc6, 0xcb, 0xb8, 0x7f, 0xf5, 0xcd, 0xfd, 0x97, 0x26, 0xfb, 0xff, 0x5d, 0x81,
-	0xda, 0x45, 0x7a, 0xb4, 0x01, 0xaa, 0xef, 0xf2, 0xac, 0x6b, 0xbb, 0xd5, 0xf3, 0x57, 0x9b, 0xea,
-	0x41, 0xd7, 0x52, 0x7d, 0x97, 0xe5, 0xe6, 0x67, 0x45, 0xe4, 0x2e, 0x5b, 0xd2, 0x62, 0x7e, 0xd7,
-	0xf7, 0x30, 0x11, 0x6f, 0x89, 0x9a, 0x25, 0x2d, 0xa6, 0x39, 0x58, 0xec, 0x14, 0x26, 0x17, 0x65,
-	0xfe, 0x2d, 0xe3, 0x41, 0x3a, 0xac, 0xf4, 0xfc, 0x01, 0x7e, 0xe6, 0xff, 0x88, 0xb5, 0x4a, 0x53,
-	0x69, 0x95, 0xac, 0x0b, 0x9b, 0x7d, 0x4b, 0xdb, 0xd3, 0xaa, 0x1c, 0x79, 0x61, 0x1b, 0x0e, 0xbc,
-	0x3f, 0x83, 0x13, 0x49, 0xf9, 0x43, 0xa8, 0x0d, 0x52, 0xa7, 0x54, 0x87, 0x56, 0x01, 0xed, 0xe3,
-	0x24, 0x63, 0x68, 0xe7, 0x97, 0x65, 0xa8, 0x0a, 0x59, 0x47, 0x3d, 0x28, 0x3d, 0xc2, 0x14, 0x99,
-	0x05, 0x69, 0x26, 0x9e, 0x13, 0x7a, 0x7b, 0xee, 0x78, 0xd9, 0x7a, 0x1f, 0xca, 0xec, 0x32, 0x41,
-	0x45, 0xaf, 0xba, 0xa9, 0x0b, 0x4a, 0xdf, 0x5a, 0x00, 0x21, 0x8b, 0x85, 0x50, 0x15, 0x0f, 0x06,
-	0x54, 0x04, 0x9e, 0x7e, 0xaf, 0xe8, 0x9d, 0x45, 0x20, 0xe3, 0x82, 0xe2, 0xca, 0x2e, 0x2c, 0x38,
-	0xfd, 0xdc, 0x28, 0x2c, 0x38, 0xeb, 0x31, 0xf0, 0x0c, 0xaa, 0xe2, 0x06, 0x2d, 0x2c, 0x38, 0x7d,
-	0xd1, 0xea, 0x1b, 0x53, 0x0f, 0x91, 0x7d, 0xf6, 0x97, 0x80, 0x4e, 0x61, 0x35, 0xab, 0x7e, 0xa8,
-	0x33, 0x9f, 0xea, 0xe6, 0x72, 0xdf, 0x5d, 0x08, 0x23, 0x67, 0x73, 0x0a, 0xab, 0x59, 0x89, 0x29,
-	0x2c, 0x3c, 0x43, 0x48, 0x0b, 0x0b, 0xcf, 0xd4, 0xb0, 0x9f, 0x15, 0xb8, 0x31, 0x75, 0xdc, 0xd0,
-	0xa7, 0x73, 0x6e, 0xee, 0x49, 0xd1, 0xd2, 0xef, 0x2d, 0x0e, 0x14, 0x8d, 0xec, 0x1e, 0x9d, 0xbd,
-	0x6e, 0x2c, 0xfd, 0xfd, 0xba, 0xb1, 0xf4, 0xd3, 0x79, 0x43, 0x39, 0x3b, 0x6f, 0x28, 0x7f, 0x9e,
-	0x37, 0x94, 0x7f, 0xcf, 0x1b, 0xca, 0xb7, 0x9f, 0xbf, 0xe3, 0xcf, 0xe4, 0x8e, 0x18, 0x1d, 0x2d,
-	0x1d, 0x57, 0xf9, 0x32, 0xdf, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xb0, 0xe3, 0xa2, 0x97,
-	0x0e, 0x00, 0x00,
+	// 1119 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x73, 0xdb, 0x44,
+	0x14, 0x8f, 0xe4, 0x8f, 0xc4, 0xcf, 0x09, 0x6d, 0xb7, 0x99, 0x8c, 0x10, 0xc5, 0xf1, 0x68, 0xca,
+	0x8c, 0x0f, 0x54, 0x26, 0xee, 0x81, 0x92, 0x74, 0x18, 0x9a, 0x38, 0x2d, 0x99, 0xa6, 0x1d, 0x46,
+	0x2d, 0x25, 0xc3, 0xa5, 0xa3, 0x48, 0x6b, 0xb1, 0xd8, 0x96, 0x84, 0x76, 0x9d, 0x8c, 0x39, 0x71,
+	0xe2, 0x0a, 0x33, 0xfc, 0x19, 0x9c, 0x38, 0xf1, 0x2f, 0xe4, 0xc8, 0x0c, 0x17, 0x4e, 0x85, 0xe6,
+	0xc0, 0xdf, 0xc1, 0xec, 0x87, 0x62, 0xf9, 0x83, 0xca, 0x4e, 0x73, 0xdb, 0xf7, 0xf4, 0x3e, 0x7e,
+	0xef, 0xf7, 0x76, 0xdf, 0xae, 0xa0, 0x1d, 0x10, 0xf6, 0xcd, 0xe0, 0xd8, 0xf6, 0xa2, 0x7e, 0xd3,
+	0x8b, 0x42, 0xe6, 0x92, 0x10, 0x27, 0x7e, 0x76, 0xe9, 0xc6, 0xa4, 0x49, 0x71, 0x72, 0x42, 0x3c,
+	0x4c, 0x9b, 0xa4, 0xef, 0x06, 0x98, 0x36, 0x4f, 0xb6, 0xd4, 0xca, 0x8e, 0x93, 0x88, 0x45, 0xe8,
+	0xfd, 0x91, 0xbd, 0x9d, 0xda, 0xda, 0xca, 0xe2, 0x64, 0xcb, 0x5c, 0x0f, 0xa2, 0x20, 0x12, 0x96,
+	0x4d, 0xbe, 0x92, 0x4e, 0xe6, 0x7b, 0x41, 0x14, 0x05, 0x3d, 0xdc, 0x14, 0xd2, 0xf1, 0xa0, 0xd3,
+	0xc4, 0xfd, 0x98, 0x0d, 0xd5, 0xc7, 0xfa, 0xe4, 0xc7, 0x0e, 0xc1, 0x3d, 0xff, 0x65, 0xdf, 0xa5,
+	0x5d, 0x65, 0xb1, 0x39, 0x69, 0xc1, 0x48, 0x1f, 0x53, 0xe6, 0xf6, 0x63, 0x65, 0xb0, 0x33, 0x57,
+	0x69, 0x6c, 0x18, 0x63, 0xda, 0xf4, 0x31, 0xf5, 0x12, 0x12, 0xb3, 0x28, 0x91, 0xce, 0xd6, 0xbf,
+	0x3a, 0x94, 0x0e, 0x78, 0x01, 0x08, 0x41, 0x31, 0x74, 0xfb, 0xd8, 0xd0, 0xea, 0x5a, 0xa3, 0xe2,
+	0x88, 0x35, 0xfa, 0x1c, 0xca, 0x3d, 0xf7, 0x18, 0xf7, 0xa8, 0xa1, 0xd7, 0x0b, 0x8d, 0x6a, 0xeb,
+	0x23, 0xfb, 0x8d, 0x04, 0xd8, 0x22, 0x92, 0x7d, 0x28, 0x5c, 0xf6, 0x43, 0x96, 0x0c, 0x1d, 0xe5,
+	0x8f, 0xb6, 0xa1, 0xcc, 0xdc, 0x24, 0xc0, 0xcc, 0x28, 0xd4, 0xb5, 0x46, 0xb5, 0x75, 0x2b, 0x1b,
+	0x49, 0x60, 0xb3, 0xdb, 0x17, 0xd8, 0x76, 0x8b, 0x67, 0xaf, 0x36, 0x97, 0x1c, 0xe5, 0x81, 0xf6,
+	0x00, 0xbc, 0x04, 0xbb, 0x0c, 0xfb, 0x2f, 0x5d, 0x66, 0x2c, 0x0b, 0x7f, 0xd3, 0x96, 0xb4, 0xd8,
+	0x29, 0x2d, 0xf6, 0xf3, 0x94, 0x96, 0xdd, 0x15, 0xee, 0xfd, 0xf3, 0xdf, 0x9b, 0x9a, 0x53, 0x51,
+	0x7e, 0x0f, 0x44, 0x90, 0x41, 0xec, 0xa7, 0x41, 0x56, 0x16, 0x09, 0xa2, 0xfc, 0x1e, 0x30, 0xf3,
+	0x13, 0xa8, 0x66, 0x8a, 0x43, 0xd7, 0xa1, 0xd0, 0xc5, 0x43, 0xc5, 0x18, 0x5f, 0xa2, 0x75, 0x28,
+	0x9d, 0xb8, 0xbd, 0x01, 0x36, 0x74, 0xa1, 0x93, 0xc2, 0xb6, 0x7e, 0x4f, 0xb3, 0x3e, 0x80, 0x6b,
+	0x8f, 0x30, 0x13, 0x04, 0x39, 0xf8, 0xbb, 0x01, 0xa6, 0x6c, 0x16, 0xe3, 0xd6, 0x53, 0xb8, 0x3e,
+	0x32, 0xa3, 0x71, 0x14, 0x52, 0x8c, 0xb6, 0xa1, 0x24, 0x28, 0x16, 0x86, 0xd5, 0xd6, 0xed, 0x79,
+	0x9a, 0xe0, 0x48, 0x17, 0xeb, 0x05, 0xa0, 0x3d, 0xc1, 0xc1, 0x58, 0xe6, 0xcf, 0x2e, 0x11, 0x51,
+	0x35, 0x45, 0xc5, 0xfd, 0x0a, 0x6e, 0x8e, 0xc5, 0x55, 0x50, 0xdf, 0x3e, 0xf0, 0x2f, 0x1a, 0xa0,
+	0x2f, 0x05, 0xe1, 0x57, 0x8b, 0x18, 0xed, 0x40, 0x55, 0x36, 0x52, 0x1c, 0x2e, 0xd1, 0xa0, 0x59,
+	0x3b, 0xe0, 0x21, 0x3f, 0x7f, 0x4f, 0x5c, 0xda, 0x75, 0xd4, 0x7e, 0xe1, 0x6b, 0x5e, 0xee, 0x18,
+	0xa8, 0x2b, 0x2b, 0xf7, 0x0e, 0xdc, 0x38, 0x24, 0x54, 0x36, 0x9c, 0xa6, 0xc5, 0x1a, 0xb0, 0xdc,
+	0x21, 0x3d, 0x86, 0x13, 0x6a, 0x68, 0xf5, 0x42, 0xa3, 0xe2, 0xa4, 0xa2, 0x75, 0x04, 0x28, 0x6b,
+	0xae, 0x60, 0xec, 0x42, 0x59, 0x26, 0x11, 0xe6, 0x8b, 0xe1, 0x50, 0x9e, 0xd6, 0x7d, 0x40, 0x6d,
+	0xdc, 0xc3, 0x13, 0xb4, 0xcf, 0x1a, 0x0a, 0x08, 0x8a, 0x74, 0x18, 0x7a, 0x82, 0xc1, 0x15, 0x47,
+	0xac, 0xad, 0xdf, 0x34, 0x58, 0xdb, 0x0f, 0xbd, 0x64, 0x18, 0xb3, 0xbd, 0x28, 0xec, 0x90, 0x00,
+	0xd5, 0x00, 0x12, 0xec, 0x91, 0x98, 0xe0, 0x90, 0xa5, 0x65, 0x64, 0x34, 0xe8, 0x36, 0xac, 0x05,
+	0x71, 0x10, 0x0f, 0x8e, 0xbb, 0x78, 0x98, 0x90, 0x30, 0x10, 0xe1, 0x56, 0x9d, 0x71, 0x25, 0xba,
+	0x05, 0x95, 0x28, 0xc6, 0x89, 0xcb, 0x48, 0x14, 0x8a, 0xc9, 0x51, 0x72, 0x46, 0x0a, 0x74, 0x1f,
+	0x74, 0xdf, 0x33, 0x8a, 0x82, 0xfb, 0x0f, 0x73, 0x6a, 0x6e, 0xe3, 0x0c, 0x3a, 0x47, 0xf7, 0x3d,
+	0xeb, 0x39, 0xbc, 0xa3, 0x94, 0x8f, 0xf1, 0xb0, 0xed, 0x32, 0x97, 0xf3, 0xde, 0x95, 0x4b, 0x51,
+	0xf0, 0xaa, 0x93, 0x8a, 0xa8, 0x01, 0xd7, 0xd4, 0xf2, 0x0b, 0x97, 0xd2, 0xd3, 0x28, 0xf1, 0x15,
+	0xde, 0x49, 0xb5, 0xf5, 0xa7, 0x06, 0x6b, 0x63, 0xb9, 0xd0, 0x0b, 0x58, 0xe9, 0xe2, 0xe1, 0x81,
+	0xff, 0xc4, 0x8d, 0x55, 0x7f, 0xb6, 0x17, 0xc1, 0x6a, 0x3f, 0x56, 0xce, 0x72, 0xa0, 0x5e, 0xc4,
+	0x32, 0xbf, 0x85, 0xb5, 0xb1, 0x4f, 0xd9, 0x71, 0x54, 0x94, 0xe3, 0x68, 0x2f, 0x3b, 0x8e, 0xaa,
+	0xad, 0x3b, 0xf3, 0xe5, 0x55, 0x74, 0x64, 0xa7, 0xd7, 0xef, 0x1a, 0xdc, 0x54, 0xfd, 0xcd, 0xdd,
+	0x1f, 0x06, 0x2c, 0x87, 0xf8, 0xf4, 0x29, 0x57, 0xcb, 0x29, 0x98, 0x8a, 0xbc, 0x5f, 0xd8, 0x53,
+	0x17, 0x40, 0x5e, 0xbf, 0xc6, 0x76, 0x93, 0xa3, 0x63, 0x0f, 0x6d, 0xf0, 0xcb, 0x68, 0xc8, 0x0f,
+	0x45, 0xb1, 0x5e, 0x68, 0x94, 0x1c, 0x25, 0xf1, 0x3d, 0x12, 0xf7, 0x5c, 0xd6, 0x89, 0x92, 0x3e,
+	0x35, 0x4a, 0x62, 0xa3, 0x8d, 0x14, 0xd6, 0x11, 0xac, 0x8f, 0x03, 0xbf, 0xb2, 0xa3, 0xcb, 0x39,
+	0x51, 0x8c, 0xbd, 0x1d, 0x27, 0xfe, 0xbc, 0x9c, 0x4c, 0xed, 0xe1, 0xcb, 0x73, 0x32, 0x0e, 0xfc,
+	0xca, 0x38, 0xf1, 0xc1, 0x48, 0xaf, 0xaf, 0x43, 0x8e, 0xe4, 0x20, 0xec, 0x44, 0x6f, 0xe2, 0x65,
+	0x84, 0x5f, 0xff, 0x7f, 0xfc, 0x85, 0x49, 0xfc, 0xbf, 0x6a, 0x50, 0xb9, 0x08, 0x8f, 0x36, 0x40,
+	0x27, 0xbe, 0x88, 0xba, 0xb6, 0x5b, 0x3e, 0x7f, 0xb5, 0xa9, 0x1f, 0xb4, 0x1d, 0x9d, 0xf8, 0x3c,
+	0xb6, 0x38, 0x2b, 0x32, 0x76, 0xd1, 0x51, 0x12, 0xd7, 0xfb, 0x24, 0xc0, 0x54, 0x3e, 0x45, 0x2a,
+	0x8e, 0x92, 0xf8, 0xc4, 0xc2, 0x72, 0xa7, 0xf0, 0x61, 0x53, 0x14, 0xdf, 0x32, 0x1a, 0x64, 0xc2,
+	0x4a, 0x87, 0xf4, 0xf0, 0x33, 0xf2, 0x3d, 0x36, 0x4a, 0x75, 0xad, 0x51, 0x70, 0x2e, 0x64, 0xfe,
+	0x2d, 0x85, 0x67, 0x94, 0x85, 0xe7, 0x85, 0x6c, 0x79, 0xf0, 0xee, 0x0c, 0x4e, 0x14, 0xe5, 0x0f,
+	0xa1, 0xd2, 0x4b, 0x95, 0x6a, 0x3a, 0x34, 0x72, 0x68, 0x1f, 0x05, 0x19, 0xb9, 0xb6, 0x7e, 0x5a,
+	0x86, 0xb2, 0xbc, 0x15, 0x50, 0x07, 0x0a, 0x8f, 0x30, 0x43, 0x76, 0x4e, 0x98, 0x89, 0xd7, 0x88,
+	0xd9, 0x9c, 0xdb, 0x5e, 0x41, 0xef, 0x42, 0x91, 0xdf, 0x45, 0x28, 0xef, 0x51, 0x38, 0x75, 0xbf,
+	0x99, 0x5b, 0x0b, 0x78, 0xa8, 0x64, 0x11, 0x94, 0xe5, 0x7b, 0x03, 0xe5, 0x39, 0x4f, 0x3f, 0x77,
+	0xcc, 0xd6, 0x22, 0x2e, 0xa3, 0x84, 0xf2, 0xc6, 0xcf, 0x4d, 0x38, 0xfd, 0x5a, 0xc9, 0x4d, 0x38,
+	0xeb, 0x2d, 0xf1, 0x0c, 0xca, 0xf2, 0x02, 0xce, 0x4d, 0x38, 0x7d, 0x4f, 0x9b, 0x1b, 0x53, 0xef,
+	0x98, 0x7d, 0xfe, 0x93, 0x81, 0x4e, 0x61, 0x35, 0x3b, 0xfd, 0x50, 0x6b, 0xbe, 0xa9, 0x3b, 0x16,
+	0xfb, 0xee, 0x42, 0x3e, 0xaa, 0x9a, 0x53, 0x58, 0xcd, 0x8e, 0x98, 0xdc, 0xc4, 0x33, 0x06, 0x69,
+	0x6e, 0xe2, 0x99, 0x33, 0xec, 0x47, 0x0d, 0x6e, 0x4c, 0x1d, 0x37, 0xf4, 0xf1, 0x9c, 0x9b, 0x7b,
+	0x72, 0x68, 0x99, 0xf7, 0x16, 0x77, 0x94, 0x40, 0x76, 0x8f, 0xce, 0x5e, 0xd7, 0x96, 0xfe, 0x7a,
+	0x5d, 0x5b, 0xfa, 0xe1, 0xbc, 0xa6, 0x9d, 0x9d, 0xd7, 0xb4, 0x3f, 0xce, 0x6b, 0xda, 0x3f, 0xe7,
+	0x35, 0xed, 0xeb, 0x4f, 0x2f, 0xf9, 0x2f, 0xba, 0x23, 0x57, 0x47, 0x4b, 0xc7, 0x65, 0xd1, 0xe6,
+	0xbb, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x86, 0x1e, 0xbb, 0x8e, 0xd6, 0x0e, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 8b1f0a3..c51793d 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -135,6 +135,8 @@ message EncryptConfig {
 	repeated string recipients = 1;
 	bytes gpgpubkeyring = 2;
 	int32 operation = 3;
+
+	DecryptConfig dc = 4;
 }
 
 // DecryptKeyData holds the private key data and the password for the private key
@@ -153,7 +155,7 @@ message EncryptImageRequest {
 	string name = 1;
 	string newName = 2;
 
-	EncryptConfig cc = 3;
+	EncryptConfig ec = 3;
 	repeated int32 layers = 4;
 	repeated string platforms = 5;
 }
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 88ad45e..f3716c3 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -111,14 +111,27 @@ var encryptCommand = cli.Command{
 			operation = images.OPERATION_REMOVE_RECIPIENTS
 		}
 
+		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
+
+		keyIdMap := make(map[uint64]images.DecryptKeyData)
+		if operation == images.OPERATION_ADD_RECIPIENTS {
+			layerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
+			if err != nil {
+				return err
+			}
+			keyIdMap, err = getPrivateKeys(layerInfos, gpgClient)
+		}
+
 		cc := &images.CryptoConfig{
 			Ec: &images.EncryptConfig{
 				GPGPubRingFile: gpgPubRingFile,
 				Recipients:     recipients,
 				Operation:      operation,
+				Dc: images.DecryptConfig{
+					KeyIdMap: keyIdMap,
+				},
 			},
 		}
-		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
 
 		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, layers32, context.StringSlice("platform"))
 		if err != nil {
diff --git a/image_store.go b/image_store.go
index d815307..4b9347d 100644
--- a/image_store.go
+++ b/image_store.go
@@ -126,13 +126,26 @@ func imageFromProto(imagepb *imagesapi.Image) images.Image {
 }
 
 func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
+	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
+	if cc.Dc != nil {
+		for k, v := range cc.Dc.KeyIdMap {
+			keyIdMap[k] = &imagesapi.DecryptKeyData{
+				KeyData:         v.KeyData,
+				KeyDataPassword: v.KeyDataPassword,
+			}
+		}
+	}
+
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
 		NewName: newName,
-		Cc: &imagesapi.EncryptConfig{
+		Ec: &imagesapi.EncryptConfig{
 			Recipients:    cc.Ec.Recipients,
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 			Operation:     cc.Ec.Operation,
+			Dc: &imagesapi.DecryptConfig{
+				KeyIdMap: keyIdMap,
+			},
 		},
 		Layers:    layers,
 		Platforms: platforms,
diff --git a/images/encryption.go b/images/encryption.go
index 0f665f0..56788e9 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -36,6 +36,10 @@ type EncryptConfig struct {
 	Recipients     []string
 	GPGPubRingFile []byte
 	Operation      int32
+	// for adding recipients on an already encrypted image we need the
+	// private keys for the layers to get to the symmetric key so we can
+	// (re)wrap it with the recpient's public key
+	Dc DecryptConfig
 }
 
 const (
@@ -136,9 +140,10 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 	switch ec.Operation {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
-			return nil, nil, errors.Wrapf(errdefs.ErrNotImplemented, "Support for adding recipients is not implemented.\n")
+			wrappedKeys, err = addRecipientsToKeys(keys, filteredList, ec.Dc.KeyIdMap)
+		} else {
+			encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 		}
-		encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 	case OPERATION_REMOVE_RECIPIENTS:
 		wrappedKeys, err = removeRecipientsFromKeys(keys, filteredList)
 		// encBlob stays empty to indicate it wasn't touched
diff --git a/images/openpgp.go b/images/openpgp.go
index 0ec9301..3f46ce9 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -52,6 +52,10 @@ func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (enc
 	return encBlob, wrappedKeys, nil
 }
 
+func addRecipientsToKeys(keys [][]byte, newRecipients openpgp.EntityList, keyIdMap map[uint64]DecryptKeyData) ([][]byte, error) {
+	return [][]byte{}, errors.Wrapf(errdefs.ErrNotImplemented, "Adding recipients is not supported\n")
+}
+
 func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList) ([][]byte, error) {
 	var wrappedKeys [][]byte
 
diff --git a/services/images/local.go b/services/images/local.go
index 858055e..ee38c66 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -186,11 +186,23 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 
 	var resp imagesapi.EncryptImageResponse
 
+	keyIdMap := make(map[uint64]images.DecryptKeyData)
+
+	for k, v := range req.Ec.Dc.KeyIdMap {
+		keyIdMap[k] = images.DecryptKeyData{
+			KeyData:         v.KeyData,
+			KeyDataPassword: v.KeyDataPassword,
+		}
+	}
+
 	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
 		Ec: &images.EncryptConfig{
-			Recipients:     req.Cc.Recipients,
-			GPGPubRingFile: req.Cc.Gpgpubkeyring,
-			Operation:      req.Cc.Operation,
+			Recipients:     req.Ec.Recipients,
+			GPGPubRingFile: req.Ec.Gpgpubkeyring,
+			Operation:      req.Ec.Operation,
+			Dc: images.DecryptConfig{
+				KeyIdMap: keyIdMap,
+			},
 		},
 	}, req.Layers, req.Platforms)
 	if err != nil {
-- 
2.7.4


From 0891ee5a49824e6ac4ee3fe1bc40c19a9ab568b9 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 17:01:35 -0400
Subject: [PATCH 43/79] remove empty line at end of file

---
 api/services/images/v1/images.proto | 1 -
 1 file changed, 1 deletion(-)

diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index c51793d..14645d5 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -195,4 +195,3 @@ message LayerInfo {
 message GetImageLayerInfoResponse {
 	repeated LayerInfo layerInfo = 1;
 }
-
-- 
2.7.4


From 2354bc23d8d1aaa5cc12345f2578dcaeec227c5c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 26 Jul 2018 17:02:02 -0400
Subject: [PATCH 44/79] Some nits

---
 cmd/ctr/commands/images/decrypt.go | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 93cd01d..99a1fa6 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -21,6 +21,7 @@ import (
 	"syscall"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/images"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
@@ -135,8 +136,8 @@ func addToSet(set, add []uint64) []uint64 {
 }
 
 // getPrivateKeys walks the list of layerInfos and determines which keys are on this system
-// and prompts for the passwords for those that are available. If one layer does not have
-// a private key an error is thrown.
+// and prompts for the passwords for those that are available. If we do not find a private
+// key on the system for a layer then an error is displayed.
 func getPrivateKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (map[uint64]images.DecryptKeyData, error) {
 	keyIdMap := make(map[uint64]images.DecryptKeyData)
 
@@ -178,7 +179,7 @@ func getPrivateKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (
 			break
 		}
 		if !found && len(layerInfo.KeyIds) > 0 {
-			return keyIdMap, fmt.Errorf("Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, layerInfo.KeyIds)
+			return keyIdMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, layerInfo.KeyIds)
 		}
 	}
 	return keyIdMap, nil
-- 
2.7.4


From a80c3610624a181137e9d02edb3372a207f5a335 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Fri, 27 Jul 2018 11:14:13 -0400
Subject: [PATCH 45/79] Another round of cleanups

---
 cmd/ctr/commands/images/decrypt.go   | 16 ++++++++--------
 cmd/ctr/commands/images/encrypt.go   | 14 +++++---------
 cmd/ctr/commands/images/layerinfo.go |  4 +---
 images/image.go                      |  8 ++++----
 4 files changed, 18 insertions(+), 24 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 99a1fa6..568fa84 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -54,14 +54,12 @@ var decryptCommand = cli.Command{
 		Usage: "The GPG version (\"v1\" or \"v2\"), default will make an educated guess",
 	}),
 	Action: func(context *cli.Context) error {
-		var (
-			local   = context.Args().First()
-			newName = context.Args().Get(1)
-		)
-		fmt.Printf("pl: %s\n", context.StringSlice("platform"))
+		local := context.Args().First()
 		if local == "" {
 			return errors.New("please provide the name of an image to decrypt")
 		}
+
+		newName := context.Args().Get(1)
 		if newName != "" {
 			fmt.Printf("Decrypting %s to %s\n", local, newName)
 		} else {
@@ -108,13 +106,15 @@ var decryptCommand = cli.Command{
 		}
 
 		keyIdMap, err := getPrivateKeys(layerInfos, gpgClient)
-
 		fmt.Printf("\n")
-		_, err = client.ImageService().DecryptImage(ctx, local, newName, &images.CryptoConfig{
+
+		cc := &images.CryptoConfig{
 			Dc: &images.DecryptConfig{
 				KeyIdMap: keyIdMap,
 			},
-		}, layers32, context.StringSlice("platform"))
+		}
+		_, err = client.ImageService().DecryptImage(ctx, local, newName, cc, layers32, context.StringSlice("platform"))
+
 		return err
 	},
 }
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index f3716c3..eb0aa4d 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -62,13 +62,12 @@ var encryptCommand = cli.Command{
 		Usage: "The GPG version (\"v1\" or \"v2\"), default will make an educated guess",
 	}),
 	Action: func(context *cli.Context) error {
-		var (
-			local   = context.Args().First()
-			newName = context.Args().Get(1)
-		)
+		local := context.Args().First()
 		if local == "" {
 			return errors.New("please provide the name of an image to encrypt")
 		}
+
+		newName := context.Args().Get(1)
 		if newName != "" {
 			fmt.Printf("Encrypting %s to %s\n", local, newName)
 		} else {
@@ -132,11 +131,8 @@ var encryptCommand = cli.Command{
 				},
 			},
 		}
-
 		_, err = client.ImageService().EncryptImage(ctx, local, newName, cc, layers32, context.StringSlice("platform"))
-		if err != nil {
-			return err
-		}
-		return nil
+
+		return err
 	},
 }
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 0cfa41c..fdbd144 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -48,9 +48,7 @@ var layerinfoCommand = cli.Command{
 		Usage: "For which platform to get the layer info; by default info for all platforms is retrieved",
 	}),
 	Action: func(context *cli.Context) error {
-		var (
-			local = context.Args().First()
-		)
+		local := context.Args().First()
 		if local == "" {
 			return errors.New("please provide the name of an image to decrypt")
 		}
diff --git a/images/image.go b/images/image.go
index 3f719f9..72e9f7e 100644
--- a/images/image.go
+++ b/images/image.go
@@ -777,7 +777,7 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to marshal index")
 		}
 
-		nDesc := ocispec.Descriptor{
+		newDesc := ocispec.Descriptor{
 			MediaType: desc.MediaType,
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
@@ -788,11 +788,11 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 			labels[fmt.Sprintf("containerd.io/gc.ref.content.%d", i)] = m.Digest.String()
 		}
 
-		ref := fmt.Sprintf("index-%s", nDesc.Digest.String())
-		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), nDesc, content.WithLabels(labels)); err != nil {
+		ref := fmt.Sprintf("index-%s", newDesc.Digest.String())
+		if err := content.WriteBlob(ctx, cs, ref, bytes.NewReader(mb), newDesc, content.WithLabels(labels)); err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to write index")
 		}
-		return nDesc, true, nil
+		return newDesc, true, nil
 	}
 
 	return desc, false, nil
-- 
2.7.4


From d502ce6edb05add11c75cd179cc7a773522b44d3 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Fri, 27 Jul 2018 14:34:22 -0400
Subject: [PATCH 46/79] Support gpg2 and gpg clients with --gpg-version flag

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/gpg.go | 92 +++++++++++++++++++++++++++++++++++++++++------------------
 1 file changed, 64 insertions(+), 28 deletions(-)

diff --git a/images/gpg.go b/images/gpg.go
index c069fd0..2f64d87 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -4,10 +4,6 @@ import (
 	"fmt"
 	"io/ioutil"
 	"os/exec"
-
-	"github.com/containerd/containerd/errdefs"
-	"github.com/mitchellh/go-homedir"
-	"github.com/pkg/errors"
 )
 
 // GPGVersion enum representing the versino of GPG client to use.
@@ -32,14 +28,17 @@ type GPGClient interface {
 	GetSecretKeyDetails(keyid uint64) ([]byte, bool, error)
 }
 
-// TODO: add comment and make private
+// gpgClient contains generic gpg client information
 type gpgClient struct {
 	gpgHomeDir string
 }
+
+// gpgv2Client is a gpg2 client
 type gpgv2Client struct {
 	gpgClient
 }
 
+// gpgv1Client is a gpg client
 type gpgv1Client struct {
 	gpgClient
 }
@@ -81,8 +80,13 @@ func NewGPGClient(version *GPGVersion, homedir string) (GPGClient, error) {
 }
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
-func (_ *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", passphrase, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+func (gc *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
+	args := []string{}
+	if gc.gpgHomeDir != "" {
+		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
+	}
+
+	args = append(args, []string{"--pinentry-mode", "loopback", "--batch", "--passphrase", passphrase, "--export-secret-key", fmt.Sprintf("0x%x", keyid)}...)
 
 	cmd := exec.Command("gpg2", args...)
 
@@ -106,17 +110,32 @@ func (_ *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte,
 }
 
 // ReadGPGPubRingFile reads the GPG public key ring file
-func (_ *gpgv2Client) ReadGPGPubRingFile() ([]byte, error) {
-	home, err := homedir.Dir()
+func (gc *gpgv2Client) ReadGPGPubRingFile() ([]byte, error) {
+	args := []string{}
+	if gc.gpgHomeDir != "" {
+		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
+	}
+	args = append(args, []string{"--batch", "--export"}...)
+
+	cmd := exec.Command("gpg2", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
 	if err != nil {
 		return nil, err
 	}
-	pubring := fmt.Sprintf("%s/.gnupg/pubring.gpg", home)
-	gpgPubRingFile, err := ioutil.ReadFile(pubring)
-	if err != nil {
-		return nil, fmt.Errorf("Could not read Public keyring file %s: %v", pubring, err)
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
-	return gpgPubRingFile, nil
+
+	return keydata, err2
 }
 
 // GetSecretKeyDetails retrives the secret key details of key with keyid.
@@ -151,10 +170,14 @@ func (gc *gpgv2Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 }
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
-func (_ *gpgv1Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
-	args := append([]string{"--pinentry-mode", "loopback", "--batch", "--passphrase", passphrase, "--export-secret-key"}, fmt.Sprintf("0x%x", keyid))
+func (gc *gpgv1Client) GetGPGPrivateKey(keyid uint64, _ string) ([]byte, error) {
+	args := []string{}
+	if gc.gpgHomeDir != "" {
+		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
+	}
+	args = append(args, []string{"--batch", "--export-secret-key", fmt.Sprintf("0x%x", keyid)}...)
 
-	cmd := exec.Command("gpg2", args...)
+	cmd := exec.Command("gpg", args...)
 
 	stdout, err := cmd.StdoutPipe()
 	stderr, err := cmd.StderrPipe()
@@ -169,26 +192,39 @@ func (_ *gpgv1Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte,
 	message, _ := ioutil.ReadAll(stderr)
 
 	if err := cmd.Wait(); err != nil {
-		return nil, errors.Wrapf(errdefs.ErrUnknown, "Error from gpg2: %s\n", message)
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
 
 	return keydata, err2
 }
 
 // ReadGPGPubRingFile reads the GPG public key ring file
-func (_ *gpgv1Client) ReadGPGPubRingFile() ([]byte, error) {
-	var pubringfn string
-	home, err := homedir.Dir()
+func (gc *gpgv1Client) ReadGPGPubRingFile() ([]byte, error) {
+	args := []string{}
+	if gc.gpgHomeDir != "" {
+		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
+	}
+	args = append(args, []string{"--batch", "--export"}...)
+
+	cmd := exec.Command("gpg", args...)
+
+	stdout, err := cmd.StdoutPipe()
+	stderr, err := cmd.StderrPipe()
 	if err != nil {
 		return nil, err
-		pubringfn = fmt.Sprintf("%s/.gnupg/pubring.gpg", home)
+	}
+	if err := cmd.Start(); err != nil {
+		return nil, err
 	}
 
-	gpgPubRingFile, err := ioutil.ReadFile(pubringfn)
-	if err != nil {
-		return nil, errors.Wrapf(errdefs.ErrInvalidArgument, "Could not read Public keyring file %s: %v", pubringfn, err)
+	keydata, err2 := ioutil.ReadAll(stdout)
+	message, _ := ioutil.ReadAll(stderr)
+
+	if err := cmd.Wait(); err != nil {
+		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
 	}
-	return gpgPubRingFile, nil
+
+	return keydata, err2
 }
 
 // GetSecretKeyDetails retrives the secret key details of key with keyid.
@@ -201,7 +237,7 @@ func (gc *gpgv1Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 	}
 	args = append(args, "-K", fmt.Sprintf("0x%x", keyid))
 
-	cmd := exec.Command("gpg2", args...)
+	cmd := exec.Command("gpg", args...)
 
 	stdout, err := cmd.StdoutPipe()
 	stderr, err := cmd.StderrPipe()
@@ -216,7 +252,7 @@ func (gc *gpgv1Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 	message, _ := ioutil.ReadAll(stderr)
 
 	if err := cmd.Wait(); err != nil {
-		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
+		return nil, false, fmt.Errorf("Error from gpg2: %s", message)
 	}
 
 	return keydata, err2 == nil, err2
-- 
2.7.4


From 339c3dff3d464ba8544ace2100a31e43ecbe2f88 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 30 Jul 2018 09:43:24 -0400
Subject: [PATCH 47/79] Decrypt the symmetric keys on client side and pass them
 into containerd

---
 api/next.pb.txt                      |  26 +--
 api/services/images/v1/images.pb.go  | 384 ++++++++++++++++-------------------
 api/services/images/v1/images.proto  |   8 +-
 cmd/ctr/commands/images/decrypt.go   |  88 +++++---
 cmd/ctr/commands/images/encrypt.go   |   6 +-
 cmd/ctr/commands/images/layerinfo.go |  18 +-
 image_store.go                       |  35 ++--
 images/encryption.go                 |  73 ++-----
 images/image.go                      |  38 ++--
 images/openpgp.go                    | 266 +++++++++++++++++++-----
 services/images/local.go             |  46 ++---
 11 files changed, 547 insertions(+), 441 deletions(-)

diff --git a/api/next.pb.txt b/api/next.pb.txt
index 8bd1bb1..e11cf71 100755
--- a/api/next.pb.txt
+++ b/api/next.pb.txt
@@ -2253,37 +2253,37 @@ file {
   message_type {
     name: "DecryptKeyData"
     field {
-      name: "keyData"
+      name: "symKeyData"
       number: 1
       label: LABEL_OPTIONAL
       type: TYPE_BYTES
-      json_name: "keyData"
+      json_name: "symKeyData"
     }
     field {
-      name: "keyDataPassword"
+      name: "symKeyCipher"
       number: 2
       label: LABEL_OPTIONAL
-      type: TYPE_BYTES
-      json_name: "keyDataPassword"
+      type: TYPE_UINT32
+      json_name: "symKeyCipher"
     }
   }
   message_type {
     name: "DecryptConfig"
     field {
-      name: "keyIdMap"
+      name: "layerSymKeyMap"
       number: 1
       label: LABEL_REPEATED
       type: TYPE_MESSAGE
-      type_name: ".containerd.services.images.v1.DecryptConfig.KeyIdMapEntry"
-      json_name: "keyIdMap"
+      type_name: ".containerd.services.images.v1.DecryptConfig.LayerSymKeyMapEntry"
+      json_name: "layerSymKeyMap"
     }
     nested_type {
-      name: "KeyIdMapEntry"
+      name: "LayerSymKeyMapEntry"
       field {
         name: "key"
         number: 1
         label: LABEL_OPTIONAL
-        type: TYPE_UINT64
+        type: TYPE_STRING
         json_name: "key"
       }
       field {
@@ -2439,11 +2439,11 @@ file {
       json_name: "id"
     }
     field {
-      name: "keyIds"
+      name: "WrappedKeys"
       number: 2
       label: LABEL_REPEATED
-      type: TYPE_UINT64
-      json_name: "keyIds"
+      type: TYPE_BYTES
+      json_name: "WrappedKeys"
     }
     field {
       name: "digest"
diff --git a/api/services/images/v1/images.pb.go b/api/services/images/v1/images.pb.go
index 9170ae4..a30b8c6 100644
--- a/api/services/images/v1/images.pb.go
+++ b/api/services/images/v1/images.pb.go
@@ -196,8 +196,8 @@ func (*EncryptConfig) Descriptor() ([]byte, []int) { return fileDescriptorImages
 
 // DecryptKeyData holds the private key data and the password for the private key
 type DecryptKeyData struct {
-	KeyData         []byte `protobuf:"bytes,1,opt,name=keyData,proto3" json:"keyData,omitempty"`
-	KeyDataPassword []byte `protobuf:"bytes,2,opt,name=keyDataPassword,proto3" json:"keyDataPassword,omitempty"`
+	SymKeyData   []byte `protobuf:"bytes,1,opt,name=symKeyData,proto3" json:"symKeyData,omitempty"`
+	SymKeyCipher uint32 `protobuf:"varint,2,opt,name=symKeyCipher,proto3" json:"symKeyCipher,omitempty"`
 }
 
 func (m *DecryptKeyData) Reset()                    { *m = DecryptKeyData{} }
@@ -207,7 +207,7 @@ func (*DecryptKeyData) Descriptor() ([]byte, []int) { return fileDescriptorImage
 // DecrypConfig holds the Ids of public keys and their corresponding private keys
 // needed for decrypting data
 type DecryptConfig struct {
-	KeyIdMap map[uint64]*DecryptKeyData `protobuf:"bytes,1,rep,name=keyIdMap" json:"keyIdMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
+	LayerSymKeyMap map[string]*DecryptKeyData `protobuf:"bytes,1,rep,name=layerSymKeyMap" json:"layerSymKeyMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
 }
 
 func (m *DecryptConfig) Reset()                    { *m = DecryptConfig{} }
@@ -265,12 +265,12 @@ func (*GetImageLayerInfoRequest) ProtoMessage()               {}
 func (*GetImageLayerInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptorImages, []int{17} }
 
 type LayerInfo struct {
-	ID         uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
-	KeyIds     []uint64 `protobuf:"varint,2,rep,packed,name=keyIds" json:"keyIds,omitempty"`
-	Digest     string   `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
-	Encryption string   `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
-	FileSize   int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
-	Platform   string   `protobuf:"bytes,6,opt,name=platform,proto3" json:"platform,omitempty"`
+	ID          uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
+	WrappedKeys [][]byte `protobuf:"bytes,2,rep,name=WrappedKeys" json:"WrappedKeys,omitempty"`
+	Digest      string   `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
+	Encryption  string   `protobuf:"bytes,4,opt,name=encryption,proto3" json:"encryption,omitempty"`
+	FileSize    int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
+	Platform    string   `protobuf:"bytes,6,opt,name=platform,proto3" json:"platform,omitempty"`
 }
 
 func (m *LayerInfo) Reset()                    { *m = LayerInfo{} }
@@ -1030,17 +1030,16 @@ func (m *DecryptKeyData) MarshalTo(dAtA []byte) (int, error) {
 	_ = i
 	var l int
 	_ = l
-	if len(m.KeyData) > 0 {
+	if len(m.SymKeyData) > 0 {
 		dAtA[i] = 0xa
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(len(m.KeyData)))
-		i += copy(dAtA[i:], m.KeyData)
+		i = encodeVarintImages(dAtA, i, uint64(len(m.SymKeyData)))
+		i += copy(dAtA[i:], m.SymKeyData)
 	}
-	if len(m.KeyDataPassword) > 0 {
-		dAtA[i] = 0x12
+	if m.SymKeyCipher != 0 {
+		dAtA[i] = 0x10
 		i++
-		i = encodeVarintImages(dAtA, i, uint64(len(m.KeyDataPassword)))
-		i += copy(dAtA[i:], m.KeyDataPassword)
+		i = encodeVarintImages(dAtA, i, uint64(m.SymKeyCipher))
 	}
 	return i, nil
 }
@@ -1060,21 +1059,22 @@ func (m *DecryptConfig) MarshalTo(dAtA []byte) (int, error) {
 	_ = i
 	var l int
 	_ = l
-	if len(m.KeyIdMap) > 0 {
-		for k, _ := range m.KeyIdMap {
+	if len(m.LayerSymKeyMap) > 0 {
+		for k, _ := range m.LayerSymKeyMap {
 			dAtA[i] = 0xa
 			i++
-			v := m.KeyIdMap[k]
+			v := m.LayerSymKeyMap[k]
 			msgSize := 0
 			if v != nil {
 				msgSize = v.Size()
 				msgSize += 1 + sovImages(uint64(msgSize))
 			}
-			mapSize := 1 + sovImages(uint64(k)) + msgSize
+			mapSize := 1 + len(k) + sovImages(uint64(len(k))) + msgSize
 			i = encodeVarintImages(dAtA, i, uint64(mapSize))
-			dAtA[i] = 0x8
+			dAtA[i] = 0xa
 			i++
-			i = encodeVarintImages(dAtA, i, uint64(k))
+			i = encodeVarintImages(dAtA, i, uint64(len(k)))
+			i += copy(dAtA[i:], k)
 			if v != nil {
 				dAtA[i] = 0x12
 				i++
@@ -1365,22 +1365,13 @@ func (m *LayerInfo) MarshalTo(dAtA []byte) (int, error) {
 		i++
 		i = encodeVarintImages(dAtA, i, uint64(m.ID))
 	}
-	if len(m.KeyIds) > 0 {
-		dAtA23 := make([]byte, len(m.KeyIds)*10)
-		var j22 int
-		for _, num := range m.KeyIds {
-			for num >= 1<<7 {
-				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
-				num >>= 7
-				j22++
-			}
-			dAtA23[j22] = uint8(num)
-			j22++
+	if len(m.WrappedKeys) > 0 {
+		for _, b := range m.WrappedKeys {
+			dAtA[i] = 0x12
+			i++
+			i = encodeVarintImages(dAtA, i, uint64(len(b)))
+			i += copy(dAtA[i:], b)
 		}
-		dAtA[i] = 0x12
-		i++
-		i = encodeVarintImages(dAtA, i, uint64(j22))
-		i += copy(dAtA[i:], dAtA23[:j22])
 	}
 	if len(m.Digest) > 0 {
 		dAtA[i] = 0x1a
@@ -1590,13 +1581,12 @@ func (m *EncryptConfig) Size() (n int) {
 func (m *DecryptKeyData) Size() (n int) {
 	var l int
 	_ = l
-	l = len(m.KeyData)
+	l = len(m.SymKeyData)
 	if l > 0 {
 		n += 1 + l + sovImages(uint64(l))
 	}
-	l = len(m.KeyDataPassword)
-	if l > 0 {
-		n += 1 + l + sovImages(uint64(l))
+	if m.SymKeyCipher != 0 {
+		n += 1 + sovImages(uint64(m.SymKeyCipher))
 	}
 	return n
 }
@@ -1604,8 +1594,8 @@ func (m *DecryptKeyData) Size() (n int) {
 func (m *DecryptConfig) Size() (n int) {
 	var l int
 	_ = l
-	if len(m.KeyIdMap) > 0 {
-		for k, v := range m.KeyIdMap {
+	if len(m.LayerSymKeyMap) > 0 {
+		for k, v := range m.LayerSymKeyMap {
 			_ = k
 			_ = v
 			l = 0
@@ -1613,7 +1603,7 @@ func (m *DecryptConfig) Size() (n int) {
 				l = v.Size()
 				l += 1 + sovImages(uint64(l))
 			}
-			mapEntrySize := 1 + sovImages(uint64(k)) + l
+			mapEntrySize := 1 + len(k) + sovImages(uint64(len(k))) + l
 			n += mapEntrySize + 1 + sovImages(uint64(mapEntrySize))
 		}
 	}
@@ -1727,12 +1717,11 @@ func (m *LayerInfo) Size() (n int) {
 	if m.ID != 0 {
 		n += 1 + sovImages(uint64(m.ID))
 	}
-	if len(m.KeyIds) > 0 {
-		l = 0
-		for _, e := range m.KeyIds {
-			l += sovImages(uint64(e))
+	if len(m.WrappedKeys) > 0 {
+		for _, b := range m.WrappedKeys {
+			l = len(b)
+			n += 1 + l + sovImages(uint64(l))
 		}
-		n += 1 + sovImages(uint64(l)) + l
 	}
 	l = len(m.Digest)
 	if l > 0 {
@@ -1911,8 +1900,8 @@ func (this *DecryptKeyData) String() string {
 		return "nil"
 	}
 	s := strings.Join([]string{`&DecryptKeyData{`,
-		`KeyData:` + fmt.Sprintf("%v", this.KeyData) + `,`,
-		`KeyDataPassword:` + fmt.Sprintf("%v", this.KeyDataPassword) + `,`,
+		`SymKeyData:` + fmt.Sprintf("%v", this.SymKeyData) + `,`,
+		`SymKeyCipher:` + fmt.Sprintf("%v", this.SymKeyCipher) + `,`,
 		`}`,
 	}, "")
 	return s
@@ -1921,18 +1910,18 @@ func (this *DecryptConfig) String() string {
 	if this == nil {
 		return "nil"
 	}
-	keysForKeyIdMap := make([]uint64, 0, len(this.KeyIdMap))
-	for k, _ := range this.KeyIdMap {
-		keysForKeyIdMap = append(keysForKeyIdMap, k)
+	keysForLayerSymKeyMap := make([]string, 0, len(this.LayerSymKeyMap))
+	for k, _ := range this.LayerSymKeyMap {
+		keysForLayerSymKeyMap = append(keysForLayerSymKeyMap, k)
 	}
-	sortkeys.Uint64s(keysForKeyIdMap)
-	mapStringForKeyIdMap := "map[uint64]*DecryptKeyData{"
-	for _, k := range keysForKeyIdMap {
-		mapStringForKeyIdMap += fmt.Sprintf("%v: %v,", k, this.KeyIdMap[k])
+	sortkeys.Strings(keysForLayerSymKeyMap)
+	mapStringForLayerSymKeyMap := "map[string]*DecryptKeyData{"
+	for _, k := range keysForLayerSymKeyMap {
+		mapStringForLayerSymKeyMap += fmt.Sprintf("%v: %v,", k, this.LayerSymKeyMap[k])
 	}
-	mapStringForKeyIdMap += "}"
+	mapStringForLayerSymKeyMap += "}"
 	s := strings.Join([]string{`&DecryptConfig{`,
-		`KeyIdMap:` + mapStringForKeyIdMap + `,`,
+		`LayerSymKeyMap:` + mapStringForLayerSymKeyMap + `,`,
 		`}`,
 	}, "")
 	return s
@@ -2003,7 +1992,7 @@ func (this *LayerInfo) String() string {
 	}
 	s := strings.Join([]string{`&LayerInfo{`,
 		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
-		`KeyIds:` + fmt.Sprintf("%v", this.KeyIds) + `,`,
+		`WrappedKeys:` + fmt.Sprintf("%v", this.WrappedKeys) + `,`,
 		`Digest:` + fmt.Sprintf("%v", this.Digest) + `,`,
 		`Encryption:` + fmt.Sprintf("%v", this.Encryption) + `,`,
 		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
@@ -3284,7 +3273,7 @@ func (m *DecryptKeyData) Unmarshal(dAtA []byte) error {
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field KeyData", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field SymKeyData", wireType)
 			}
 			var byteLen int
 			for shift := uint(0); ; shift += 7 {
@@ -3308,16 +3297,16 @@ func (m *DecryptKeyData) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			m.KeyData = append(m.KeyData[:0], dAtA[iNdEx:postIndex]...)
-			if m.KeyData == nil {
-				m.KeyData = []byte{}
+			m.SymKeyData = append(m.SymKeyData[:0], dAtA[iNdEx:postIndex]...)
+			if m.SymKeyData == nil {
+				m.SymKeyData = []byte{}
 			}
 			iNdEx = postIndex
 		case 2:
-			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field KeyDataPassword", wireType)
+			if wireType != 0 {
+				return fmt.Errorf("proto: wrong wireType = %d for field SymKeyCipher", wireType)
 			}
-			var byteLen int
+			m.SymKeyCipher = 0
 			for shift := uint(0); ; shift += 7 {
 				if shift >= 64 {
 					return ErrIntOverflowImages
@@ -3327,23 +3316,11 @@ func (m *DecryptKeyData) Unmarshal(dAtA []byte) error {
 				}
 				b := dAtA[iNdEx]
 				iNdEx++
-				byteLen |= (int(b) & 0x7F) << shift
+				m.SymKeyCipher |= (uint32(b) & 0x7F) << shift
 				if b < 0x80 {
 					break
 				}
 			}
-			if byteLen < 0 {
-				return ErrInvalidLengthImages
-			}
-			postIndex := iNdEx + byteLen
-			if postIndex > l {
-				return io.ErrUnexpectedEOF
-			}
-			m.KeyDataPassword = append(m.KeyDataPassword[:0], dAtA[iNdEx:postIndex]...)
-			if m.KeyDataPassword == nil {
-				m.KeyDataPassword = []byte{}
-			}
-			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
 			skippy, err := skipImages(dAtA[iNdEx:])
@@ -3396,7 +3373,7 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 		switch fieldNum {
 		case 1:
 			if wireType != 2 {
-				return fmt.Errorf("proto: wrong wireType = %d for field KeyIdMap", wireType)
+				return fmt.Errorf("proto: wrong wireType = %d for field LayerSymKeyMap", wireType)
 			}
 			var msglen int
 			for shift := uint(0); ; shift += 7 {
@@ -3420,10 +3397,10 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 			if postIndex > l {
 				return io.ErrUnexpectedEOF
 			}
-			if m.KeyIdMap == nil {
-				m.KeyIdMap = make(map[uint64]*DecryptKeyData)
+			if m.LayerSymKeyMap == nil {
+				m.LayerSymKeyMap = make(map[string]*DecryptKeyData)
 			}
-			var mapkey uint64
+			var mapkey string
 			var mapvalue *DecryptKeyData
 			for iNdEx < postIndex {
 				entryPreIndex := iNdEx
@@ -3444,6 +3421,7 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 				}
 				fieldNum := int32(wire >> 3)
 				if fieldNum == 1 {
+					var stringLenmapkey uint64
 					for shift := uint(0); ; shift += 7 {
 						if shift >= 64 {
 							return ErrIntOverflowImages
@@ -3453,11 +3431,21 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 						}
 						b := dAtA[iNdEx]
 						iNdEx++
-						mapkey |= (uint64(b) & 0x7F) << shift
+						stringLenmapkey |= (uint64(b) & 0x7F) << shift
 						if b < 0x80 {
 							break
 						}
 					}
+					intStringLenmapkey := int(stringLenmapkey)
+					if intStringLenmapkey < 0 {
+						return ErrInvalidLengthImages
+					}
+					postStringIndexmapkey := iNdEx + intStringLenmapkey
+					if postStringIndexmapkey > l {
+						return io.ErrUnexpectedEOF
+					}
+					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
+					iNdEx = postStringIndexmapkey
 				} else if fieldNum == 2 {
 					var mapmsglen int
 					for shift := uint(0); ; shift += 7 {
@@ -3504,7 +3492,7 @@ func (m *DecryptConfig) Unmarshal(dAtA []byte) error {
 					iNdEx += skippy
 				}
 			}
-			m.KeyIdMap[mapkey] = mapvalue
+			m.LayerSymKeyMap[mapkey] = mapvalue
 			iNdEx = postIndex
 		default:
 			iNdEx = preIndex
@@ -4370,67 +4358,34 @@ func (m *LayerInfo) Unmarshal(dAtA []byte) error {
 				}
 			}
 		case 2:
-			if wireType == 0 {
-				var v uint64
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowImages
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					v |= (uint64(b) & 0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				m.KeyIds = append(m.KeyIds, v)
-			} else if wireType == 2 {
-				var packedLen int
-				for shift := uint(0); ; shift += 7 {
-					if shift >= 64 {
-						return ErrIntOverflowImages
-					}
-					if iNdEx >= l {
-						return io.ErrUnexpectedEOF
-					}
-					b := dAtA[iNdEx]
-					iNdEx++
-					packedLen |= (int(b) & 0x7F) << shift
-					if b < 0x80 {
-						break
-					}
-				}
-				if packedLen < 0 {
-					return ErrInvalidLengthImages
+			if wireType != 2 {
+				return fmt.Errorf("proto: wrong wireType = %d for field WrappedKeys", wireType)
+			}
+			var byteLen int
+			for shift := uint(0); ; shift += 7 {
+				if shift >= 64 {
+					return ErrIntOverflowImages
 				}
-				postIndex := iNdEx + packedLen
-				if postIndex > l {
+				if iNdEx >= l {
 					return io.ErrUnexpectedEOF
 				}
-				for iNdEx < postIndex {
-					var v uint64
-					for shift := uint(0); ; shift += 7 {
-						if shift >= 64 {
-							return ErrIntOverflowImages
-						}
-						if iNdEx >= l {
-							return io.ErrUnexpectedEOF
-						}
-						b := dAtA[iNdEx]
-						iNdEx++
-						v |= (uint64(b) & 0x7F) << shift
-						if b < 0x80 {
-							break
-						}
-					}
-					m.KeyIds = append(m.KeyIds, v)
+				b := dAtA[iNdEx]
+				iNdEx++
+				byteLen |= (int(b) & 0x7F) << shift
+				if b < 0x80 {
+					break
 				}
-			} else {
-				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
 			}
+			if byteLen < 0 {
+				return ErrInvalidLengthImages
+			}
+			postIndex := iNdEx + byteLen
+			if postIndex > l {
+				return io.ErrUnexpectedEOF
+			}
+			m.WrappedKeys = append(m.WrappedKeys, make([]byte, postIndex-iNdEx))
+			copy(m.WrappedKeys[len(m.WrappedKeys)-1], dAtA[iNdEx:postIndex])
+			iNdEx = postIndex
 		case 3:
 			if wireType != 2 {
 				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
@@ -4749,75 +4704,76 @@ func init() {
 }
 
 var fileDescriptorImages = []byte{
-	// 1119 bytes of a gzipped FileDescriptorProto
-	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x73, 0xdb, 0x44,
-	0x14, 0x8f, 0xe4, 0x8f, 0xc4, 0xcf, 0x09, 0x6d, 0xb7, 0x99, 0x8c, 0x10, 0xc5, 0xf1, 0x68, 0xca,
-	0x8c, 0x0f, 0x54, 0x26, 0xee, 0x81, 0x92, 0x74, 0x18, 0x9a, 0x38, 0x2d, 0x99, 0xa6, 0x1d, 0x46,
-	0x2d, 0x25, 0xc3, 0xa5, 0xa3, 0x48, 0x6b, 0xb1, 0xd8, 0x96, 0x84, 0x76, 0x9d, 0x8c, 0x39, 0x71,
-	0xe2, 0x0a, 0x33, 0xfc, 0x19, 0x9c, 0x38, 0xf1, 0x2f, 0xe4, 0xc8, 0x0c, 0x17, 0x4e, 0x85, 0xe6,
-	0xc0, 0xdf, 0xc1, 0xec, 0x87, 0x62, 0xf9, 0x83, 0xca, 0x4e, 0x73, 0xdb, 0xf7, 0xf4, 0x3e, 0x7e,
-	0xef, 0xf7, 0x76, 0xdf, 0xae, 0xa0, 0x1d, 0x10, 0xf6, 0xcd, 0xe0, 0xd8, 0xf6, 0xa2, 0x7e, 0xd3,
-	0x8b, 0x42, 0xe6, 0x92, 0x10, 0x27, 0x7e, 0x76, 0xe9, 0xc6, 0xa4, 0x49, 0x71, 0x72, 0x42, 0x3c,
-	0x4c, 0x9b, 0xa4, 0xef, 0x06, 0x98, 0x36, 0x4f, 0xb6, 0xd4, 0xca, 0x8e, 0x93, 0x88, 0x45, 0xe8,
-	0xfd, 0x91, 0xbd, 0x9d, 0xda, 0xda, 0xca, 0xe2, 0x64, 0xcb, 0x5c, 0x0f, 0xa2, 0x20, 0x12, 0x96,
-	0x4d, 0xbe, 0x92, 0x4e, 0xe6, 0x7b, 0x41, 0x14, 0x05, 0x3d, 0xdc, 0x14, 0xd2, 0xf1, 0xa0, 0xd3,
-	0xc4, 0xfd, 0x98, 0x0d, 0xd5, 0xc7, 0xfa, 0xe4, 0xc7, 0x0e, 0xc1, 0x3d, 0xff, 0x65, 0xdf, 0xa5,
-	0x5d, 0x65, 0xb1, 0x39, 0x69, 0xc1, 0x48, 0x1f, 0x53, 0xe6, 0xf6, 0x63, 0x65, 0xb0, 0x33, 0x57,
-	0x69, 0x6c, 0x18, 0x63, 0xda, 0xf4, 0x31, 0xf5, 0x12, 0x12, 0xb3, 0x28, 0x91, 0xce, 0xd6, 0xbf,
-	0x3a, 0x94, 0x0e, 0x78, 0x01, 0x08, 0x41, 0x31, 0x74, 0xfb, 0xd8, 0xd0, 0xea, 0x5a, 0xa3, 0xe2,
-	0x88, 0x35, 0xfa, 0x1c, 0xca, 0x3d, 0xf7, 0x18, 0xf7, 0xa8, 0xa1, 0xd7, 0x0b, 0x8d, 0x6a, 0xeb,
-	0x23, 0xfb, 0x8d, 0x04, 0xd8, 0x22, 0x92, 0x7d, 0x28, 0x5c, 0xf6, 0x43, 0x96, 0x0c, 0x1d, 0xe5,
-	0x8f, 0xb6, 0xa1, 0xcc, 0xdc, 0x24, 0xc0, 0xcc, 0x28, 0xd4, 0xb5, 0x46, 0xb5, 0x75, 0x2b, 0x1b,
-	0x49, 0x60, 0xb3, 0xdb, 0x17, 0xd8, 0x76, 0x8b, 0x67, 0xaf, 0x36, 0x97, 0x1c, 0xe5, 0x81, 0xf6,
-	0x00, 0xbc, 0x04, 0xbb, 0x0c, 0xfb, 0x2f, 0x5d, 0x66, 0x2c, 0x0b, 0x7f, 0xd3, 0x96, 0xb4, 0xd8,
-	0x29, 0x2d, 0xf6, 0xf3, 0x94, 0x96, 0xdd, 0x15, 0xee, 0xfd, 0xf3, 0xdf, 0x9b, 0x9a, 0x53, 0x51,
-	0x7e, 0x0f, 0x44, 0x90, 0x41, 0xec, 0xa7, 0x41, 0x56, 0x16, 0x09, 0xa2, 0xfc, 0x1e, 0x30, 0xf3,
-	0x13, 0xa8, 0x66, 0x8a, 0x43, 0xd7, 0xa1, 0xd0, 0xc5, 0x43, 0xc5, 0x18, 0x5f, 0xa2, 0x75, 0x28,
-	0x9d, 0xb8, 0xbd, 0x01, 0x36, 0x74, 0xa1, 0x93, 0xc2, 0xb6, 0x7e, 0x4f, 0xb3, 0x3e, 0x80, 0x6b,
-	0x8f, 0x30, 0x13, 0x04, 0x39, 0xf8, 0xbb, 0x01, 0xa6, 0x6c, 0x16, 0xe3, 0xd6, 0x53, 0xb8, 0x3e,
-	0x32, 0xa3, 0x71, 0x14, 0x52, 0x8c, 0xb6, 0xa1, 0x24, 0x28, 0x16, 0x86, 0xd5, 0xd6, 0xed, 0x79,
-	0x9a, 0xe0, 0x48, 0x17, 0xeb, 0x05, 0xa0, 0x3d, 0xc1, 0xc1, 0x58, 0xe6, 0xcf, 0x2e, 0x11, 0x51,
-	0x35, 0x45, 0xc5, 0xfd, 0x0a, 0x6e, 0x8e, 0xc5, 0x55, 0x50, 0xdf, 0x3e, 0xf0, 0x2f, 0x1a, 0xa0,
-	0x2f, 0x05, 0xe1, 0x57, 0x8b, 0x18, 0xed, 0x40, 0x55, 0x36, 0x52, 0x1c, 0x2e, 0xd1, 0xa0, 0x59,
-	0x3b, 0xe0, 0x21, 0x3f, 0x7f, 0x4f, 0x5c, 0xda, 0x75, 0xd4, 0x7e, 0xe1, 0x6b, 0x5e, 0xee, 0x18,
-	0xa8, 0x2b, 0x2b, 0xf7, 0x0e, 0xdc, 0x38, 0x24, 0x54, 0x36, 0x9c, 0xa6, 0xc5, 0x1a, 0xb0, 0xdc,
-	0x21, 0x3d, 0x86, 0x13, 0x6a, 0x68, 0xf5, 0x42, 0xa3, 0xe2, 0xa4, 0xa2, 0x75, 0x04, 0x28, 0x6b,
-	0xae, 0x60, 0xec, 0x42, 0x59, 0x26, 0x11, 0xe6, 0x8b, 0xe1, 0x50, 0x9e, 0xd6, 0x7d, 0x40, 0x6d,
-	0xdc, 0xc3, 0x13, 0xb4, 0xcf, 0x1a, 0x0a, 0x08, 0x8a, 0x74, 0x18, 0x7a, 0x82, 0xc1, 0x15, 0x47,
-	0xac, 0xad, 0xdf, 0x34, 0x58, 0xdb, 0x0f, 0xbd, 0x64, 0x18, 0xb3, 0xbd, 0x28, 0xec, 0x90, 0x00,
-	0xd5, 0x00, 0x12, 0xec, 0x91, 0x98, 0xe0, 0x90, 0xa5, 0x65, 0x64, 0x34, 0xe8, 0x36, 0xac, 0x05,
-	0x71, 0x10, 0x0f, 0x8e, 0xbb, 0x78, 0x98, 0x90, 0x30, 0x10, 0xe1, 0x56, 0x9d, 0x71, 0x25, 0xba,
-	0x05, 0x95, 0x28, 0xc6, 0x89, 0xcb, 0x48, 0x14, 0x8a, 0xc9, 0x51, 0x72, 0x46, 0x0a, 0x74, 0x1f,
-	0x74, 0xdf, 0x33, 0x8a, 0x82, 0xfb, 0x0f, 0x73, 0x6a, 0x6e, 0xe3, 0x0c, 0x3a, 0x47, 0xf7, 0x3d,
-	0xeb, 0x39, 0xbc, 0xa3, 0x94, 0x8f, 0xf1, 0xb0, 0xed, 0x32, 0x97, 0xf3, 0xde, 0x95, 0x4b, 0x51,
-	0xf0, 0xaa, 0x93, 0x8a, 0xa8, 0x01, 0xd7, 0xd4, 0xf2, 0x0b, 0x97, 0xd2, 0xd3, 0x28, 0xf1, 0x15,
-	0xde, 0x49, 0xb5, 0xf5, 0xa7, 0x06, 0x6b, 0x63, 0xb9, 0xd0, 0x0b, 0x58, 0xe9, 0xe2, 0xe1, 0x81,
-	0xff, 0xc4, 0x8d, 0x55, 0x7f, 0xb6, 0x17, 0xc1, 0x6a, 0x3f, 0x56, 0xce, 0x72, 0xa0, 0x5e, 0xc4,
-	0x32, 0xbf, 0x85, 0xb5, 0xb1, 0x4f, 0xd9, 0x71, 0x54, 0x94, 0xe3, 0x68, 0x2f, 0x3b, 0x8e, 0xaa,
-	0xad, 0x3b, 0xf3, 0xe5, 0x55, 0x74, 0x64, 0xa7, 0xd7, 0xef, 0x1a, 0xdc, 0x54, 0xfd, 0xcd, 0xdd,
-	0x1f, 0x06, 0x2c, 0x87, 0xf8, 0xf4, 0x29, 0x57, 0xcb, 0x29, 0x98, 0x8a, 0xbc, 0x5f, 0xd8, 0x53,
-	0x17, 0x40, 0x5e, 0xbf, 0xc6, 0x76, 0x93, 0xa3, 0x63, 0x0f, 0x6d, 0xf0, 0xcb, 0x68, 0xc8, 0x0f,
-	0x45, 0xb1, 0x5e, 0x68, 0x94, 0x1c, 0x25, 0xf1, 0x3d, 0x12, 0xf7, 0x5c, 0xd6, 0x89, 0x92, 0x3e,
-	0x35, 0x4a, 0x62, 0xa3, 0x8d, 0x14, 0xd6, 0x11, 0xac, 0x8f, 0x03, 0xbf, 0xb2, 0xa3, 0xcb, 0x39,
-	0x51, 0x8c, 0xbd, 0x1d, 0x27, 0xfe, 0xbc, 0x9c, 0x4c, 0xed, 0xe1, 0xcb, 0x73, 0x32, 0x0e, 0xfc,
-	0xca, 0x38, 0xf1, 0xc1, 0x48, 0xaf, 0xaf, 0x43, 0x8e, 0xe4, 0x20, 0xec, 0x44, 0x6f, 0xe2, 0x65,
-	0x84, 0x5f, 0xff, 0x7f, 0xfc, 0x85, 0x49, 0xfc, 0xbf, 0x6a, 0x50, 0xb9, 0x08, 0x8f, 0x36, 0x40,
-	0x27, 0xbe, 0x88, 0xba, 0xb6, 0x5b, 0x3e, 0x7f, 0xb5, 0xa9, 0x1f, 0xb4, 0x1d, 0x9d, 0xf8, 0x3c,
-	0xb6, 0x38, 0x2b, 0x32, 0x76, 0xd1, 0x51, 0x12, 0xd7, 0xfb, 0x24, 0xc0, 0x54, 0x3e, 0x45, 0x2a,
-	0x8e, 0x92, 0xf8, 0xc4, 0xc2, 0x72, 0xa7, 0xf0, 0x61, 0x53, 0x14, 0xdf, 0x32, 0x1a, 0x64, 0xc2,
-	0x4a, 0x87, 0xf4, 0xf0, 0x33, 0xf2, 0x3d, 0x36, 0x4a, 0x75, 0xad, 0x51, 0x70, 0x2e, 0x64, 0xfe,
-	0x2d, 0x85, 0x67, 0x94, 0x85, 0xe7, 0x85, 0x6c, 0x79, 0xf0, 0xee, 0x0c, 0x4e, 0x14, 0xe5, 0x0f,
-	0xa1, 0xd2, 0x4b, 0x95, 0x6a, 0x3a, 0x34, 0x72, 0x68, 0x1f, 0x05, 0x19, 0xb9, 0xb6, 0x7e, 0x5a,
-	0x86, 0xb2, 0xbc, 0x15, 0x50, 0x07, 0x0a, 0x8f, 0x30, 0x43, 0x76, 0x4e, 0x98, 0x89, 0xd7, 0x88,
-	0xd9, 0x9c, 0xdb, 0x5e, 0x41, 0xef, 0x42, 0x91, 0xdf, 0x45, 0x28, 0xef, 0x51, 0x38, 0x75, 0xbf,
-	0x99, 0x5b, 0x0b, 0x78, 0xa8, 0x64, 0x11, 0x94, 0xe5, 0x7b, 0x03, 0xe5, 0x39, 0x4f, 0x3f, 0x77,
-	0xcc, 0xd6, 0x22, 0x2e, 0xa3, 0x84, 0xf2, 0xc6, 0xcf, 0x4d, 0x38, 0xfd, 0x5a, 0xc9, 0x4d, 0x38,
-	0xeb, 0x2d, 0xf1, 0x0c, 0xca, 0xf2, 0x02, 0xce, 0x4d, 0x38, 0x7d, 0x4f, 0x9b, 0x1b, 0x53, 0xef,
-	0x98, 0x7d, 0xfe, 0x93, 0x81, 0x4e, 0x61, 0x35, 0x3b, 0xfd, 0x50, 0x6b, 0xbe, 0xa9, 0x3b, 0x16,
-	0xfb, 0xee, 0x42, 0x3e, 0xaa, 0x9a, 0x53, 0x58, 0xcd, 0x8e, 0x98, 0xdc, 0xc4, 0x33, 0x06, 0x69,
-	0x6e, 0xe2, 0x99, 0x33, 0xec, 0x47, 0x0d, 0x6e, 0x4c, 0x1d, 0x37, 0xf4, 0xf1, 0x9c, 0x9b, 0x7b,
-	0x72, 0x68, 0x99, 0xf7, 0x16, 0x77, 0x94, 0x40, 0x76, 0x8f, 0xce, 0x5e, 0xd7, 0x96, 0xfe, 0x7a,
-	0x5d, 0x5b, 0xfa, 0xe1, 0xbc, 0xa6, 0x9d, 0x9d, 0xd7, 0xb4, 0x3f, 0xce, 0x6b, 0xda, 0x3f, 0xe7,
-	0x35, 0xed, 0xeb, 0x4f, 0x2f, 0xf9, 0x2f, 0xba, 0x23, 0x57, 0x47, 0x4b, 0xc7, 0x65, 0xd1, 0xe6,
-	0xbb, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x86, 0x1e, 0xbb, 0x8e, 0xd6, 0x0e, 0x00, 0x00,
+	// 1126 bytes of a gzipped FileDescriptorProto
+	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x73, 0xdb, 0x44,
+	0x14, 0x8f, 0xe4, 0x3f, 0x89, 0x9f, 0x9d, 0xd2, 0x6e, 0x33, 0x19, 0x21, 0x8a, 0xe3, 0xd1, 0x94,
+	0x19, 0x1f, 0xa8, 0x4c, 0xdc, 0x03, 0x25, 0xe9, 0x30, 0x6d, 0xe2, 0xb4, 0x64, 0x9a, 0xf6, 0xa0,
+	0x14, 0x9a, 0xe1, 0xd2, 0x51, 0xa4, 0x67, 0x45, 0x13, 0x59, 0x12, 0xd2, 0x3a, 0x19, 0x71, 0xe2,
+	0xc4, 0x15, 0x66, 0xf8, 0x24, 0x1c, 0x18, 0xbe, 0x42, 0x8e, 0x1c, 0x39, 0x15, 0xea, 0x03, 0x17,
+	0xbe, 0x04, 0xa3, 0xd5, 0x2a, 0x96, 0x6c, 0x53, 0xd9, 0x69, 0x6e, 0xbb, 0x4f, 0xef, 0xcf, 0xef,
+	0xfd, 0xde, 0xdb, 0xb7, 0x2b, 0xe8, 0x59, 0x36, 0x3d, 0x19, 0x1e, 0xab, 0x86, 0x37, 0xe8, 0x18,
+	0x9e, 0x4b, 0x75, 0xdb, 0xc5, 0xc0, 0xcc, 0x2e, 0x75, 0xdf, 0xee, 0x84, 0x18, 0x9c, 0xd9, 0x06,
+	0x86, 0x1d, 0x7b, 0xa0, 0x5b, 0x18, 0x76, 0xce, 0x36, 0xf9, 0x4a, 0xf5, 0x03, 0x8f, 0x7a, 0xe4,
+	0xe3, 0xb1, 0xbe, 0x9a, 0xea, 0xaa, 0x5c, 0xe3, 0x6c, 0x53, 0x5e, 0xb3, 0x3c, 0xcb, 0x63, 0x9a,
+	0x9d, 0x78, 0x95, 0x18, 0xc9, 0x1f, 0x59, 0x9e, 0x67, 0x39, 0xd8, 0x61, 0xbb, 0xe3, 0x61, 0xbf,
+	0x83, 0x03, 0x9f, 0x46, 0xfc, 0x63, 0x6b, 0xf2, 0x63, 0xdf, 0x46, 0xc7, 0x7c, 0x3d, 0xd0, 0xc3,
+	0x53, 0xae, 0xb1, 0x31, 0xa9, 0x41, 0xed, 0x01, 0x86, 0x54, 0x1f, 0xf8, 0x5c, 0x61, 0x7b, 0xae,
+	0xd4, 0x68, 0xe4, 0x63, 0xd8, 0x31, 0x31, 0x34, 0x02, 0xdb, 0xa7, 0x5e, 0x90, 0x18, 0x2b, 0xff,
+	0x88, 0x50, 0xd9, 0x8f, 0x13, 0x20, 0x04, 0xca, 0xae, 0x3e, 0x40, 0x49, 0x68, 0x09, 0xed, 0x9a,
+	0xc6, 0xd6, 0xe4, 0x2b, 0xa8, 0x3a, 0xfa, 0x31, 0x3a, 0xa1, 0x24, 0xb6, 0x4a, 0xed, 0x7a, 0xf7,
+	0x33, 0xf5, 0x9d, 0x04, 0xa8, 0xcc, 0x93, 0x7a, 0xc0, 0x4c, 0xf6, 0x5c, 0x1a, 0x44, 0x1a, 0xb7,
+	0x27, 0x5b, 0x50, 0xa5, 0x7a, 0x60, 0x21, 0x95, 0x4a, 0x2d, 0xa1, 0x5d, 0xef, 0xde, 0xc9, 0x7a,
+	0x62, 0xd8, 0xd4, 0xde, 0x25, 0xb6, 0x9d, 0xf2, 0xc5, 0x9b, 0x8d, 0x25, 0x8d, 0x5b, 0x90, 0x5d,
+	0x00, 0x23, 0x40, 0x9d, 0xa2, 0xf9, 0x5a, 0xa7, 0xd2, 0x32, 0xb3, 0x97, 0xd5, 0x84, 0x16, 0x35,
+	0xa5, 0x45, 0x7d, 0x99, 0xd2, 0xb2, 0xb3, 0x12, 0x5b, 0xff, 0xfc, 0xd7, 0x86, 0xa0, 0xd5, 0xb8,
+	0xdd, 0x63, 0xe6, 0x64, 0xe8, 0x9b, 0xa9, 0x93, 0x95, 0x45, 0x9c, 0x70, 0xbb, 0xc7, 0x54, 0xfe,
+	0x02, 0xea, 0x99, 0xe4, 0xc8, 0x4d, 0x28, 0x9d, 0x62, 0xc4, 0x19, 0x8b, 0x97, 0x64, 0x0d, 0x2a,
+	0x67, 0xba, 0x33, 0x44, 0x49, 0x64, 0xb2, 0x64, 0xb3, 0x25, 0x3e, 0x10, 0x94, 0x4f, 0xe0, 0x83,
+	0xa7, 0x48, 0x19, 0x41, 0x1a, 0x7e, 0x37, 0xc4, 0x90, 0xce, 0x62, 0x5c, 0x79, 0x01, 0x37, 0xc7,
+	0x6a, 0xa1, 0xef, 0xb9, 0x21, 0x92, 0x2d, 0xa8, 0x30, 0x8a, 0x99, 0x62, 0xbd, 0x7b, 0x77, 0x9e,
+	0x22, 0x68, 0x89, 0x89, 0xf2, 0x0d, 0x90, 0x5d, 0xc6, 0x41, 0x2e, 0xf2, 0xa3, 0x2b, 0x78, 0xe4,
+	0x45, 0xe1, 0x7e, 0x5f, 0xc1, 0xed, 0x9c, 0x5f, 0x0e, 0xf5, 0xfd, 0x1d, 0xff, 0x22, 0x00, 0xf9,
+	0x9a, 0x11, 0x7e, 0xbd, 0x88, 0xc9, 0x36, 0xd4, 0x93, 0x42, 0xb2, 0xc3, 0xc5, 0x0a, 0x34, 0xab,
+	0x03, 0x9e, 0xc4, 0xe7, 0xef, 0xb9, 0x1e, 0x9e, 0x6a, 0xbc, 0x5f, 0xe2, 0x75, 0x9c, 0x6e, 0x0e,
+	0xd4, 0xb5, 0xa5, 0x7b, 0x0f, 0x6e, 0x1d, 0xd8, 0x61, 0x52, 0xf0, 0x30, 0x4d, 0x56, 0x82, 0xe5,
+	0xbe, 0xed, 0x50, 0x0c, 0x42, 0x49, 0x68, 0x95, 0xda, 0x35, 0x2d, 0xdd, 0x2a, 0x47, 0x40, 0xb2,
+	0xea, 0x1c, 0xc6, 0x0e, 0x54, 0x93, 0x20, 0x4c, 0x7d, 0x31, 0x1c, 0xdc, 0x52, 0x79, 0x08, 0xa4,
+	0x87, 0x0e, 0x4e, 0xd0, 0x3e, 0x6b, 0x28, 0x10, 0x28, 0x87, 0x91, 0x6b, 0x30, 0x06, 0x57, 0x34,
+	0xb6, 0x56, 0x7e, 0x15, 0x60, 0x75, 0xcf, 0x35, 0x82, 0xc8, 0xa7, 0xbb, 0x9e, 0xdb, 0xb7, 0x2d,
+	0xd2, 0x04, 0x08, 0xd0, 0xb0, 0x7d, 0x1b, 0x5d, 0x9a, 0xa6, 0x91, 0x91, 0x90, 0xbb, 0xb0, 0x6a,
+	0xf9, 0x96, 0x3f, 0x3c, 0x3e, 0xc5, 0x28, 0xb0, 0x5d, 0x8b, 0xb9, 0x6b, 0x68, 0x79, 0x21, 0xb9,
+	0x03, 0x35, 0xcf, 0xc7, 0x40, 0xa7, 0xb6, 0xe7, 0xb2, 0xc9, 0x51, 0xd1, 0xc6, 0x02, 0xf2, 0x10,
+	0x44, 0xd3, 0x90, 0xca, 0x8c, 0xfb, 0x4f, 0x0b, 0x72, 0xee, 0x61, 0x06, 0x9d, 0x26, 0x9a, 0x86,
+	0xf2, 0x12, 0x6e, 0x70, 0xe1, 0x33, 0x8c, 0x7a, 0x3a, 0xd5, 0x63, 0xcc, 0x61, 0x34, 0xe0, 0x3b,
+	0x96, 0x73, 0x43, 0xcb, 0x48, 0x88, 0x02, 0x8d, 0x64, 0xb7, 0x6b, 0xfb, 0x27, 0x18, 0x30, 0xc8,
+	0xab, 0x5a, 0x4e, 0xa6, 0xfc, 0x2b, 0xc0, 0x6a, 0x2e, 0x16, 0x39, 0x81, 0x1b, 0x8e, 0x1e, 0x61,
+	0x70, 0xc8, 0xd4, 0x9e, 0xeb, 0x3e, 0xaf, 0xd2, 0xa3, 0x45, 0x10, 0xab, 0x07, 0x39, 0x17, 0xc9,
+	0x70, 0x9d, 0xf0, 0x2b, 0xfb, 0x70, 0x7b, 0x86, 0xda, 0x8c, 0x31, 0xb5, 0x9b, 0x1d, 0x53, 0xf5,
+	0xee, 0xbd, 0xf9, 0x90, 0x70, 0x1a, 0xb2, 0x53, 0xed, 0x77, 0x01, 0x6e, 0xf3, 0xba, 0x17, 0xf6,
+	0x8d, 0x04, 0xcb, 0x2e, 0x9e, 0xbf, 0x88, 0xc5, 0xc9, 0x74, 0x4c, 0xb7, 0x71, 0x1d, 0xd1, 0xe0,
+	0x17, 0x43, 0x51, 0x1d, 0x73, 0x5d, 0xa6, 0x89, 0x68, 0x90, 0xf5, 0xf8, 0x92, 0x8a, 0xe2, 0xc3,
+	0x52, 0x6e, 0x95, 0xda, 0x15, 0x8d, 0xef, 0xe2, 0xde, 0xf1, 0x1d, 0x9d, 0xf6, 0xbd, 0x60, 0x10,
+	0x4a, 0x15, 0xd6, 0x80, 0x63, 0x81, 0x72, 0x04, 0x6b, 0x79, 0xe0, 0xd7, 0x76, 0xa4, 0x63, 0x4e,
+	0x38, 0x63, 0xef, 0xc7, 0x89, 0x39, 0x2f, 0x27, 0x53, 0xbd, 0x7d, 0x75, 0x4e, 0xf2, 0xc0, 0xaf,
+	0x8d, 0x13, 0x13, 0xa4, 0xf4, 0x5a, 0x63, 0x1d, 0xba, 0xef, 0xf6, 0xbd, 0x77, 0xf1, 0x32, 0xc6,
+	0x2f, 0xfe, 0x3f, 0xfe, 0xd2, 0x24, 0xfe, 0xdf, 0x04, 0xa8, 0x5d, 0xba, 0x27, 0xeb, 0x20, 0xda,
+	0x26, 0xf3, 0xba, 0xba, 0x53, 0x1d, 0xbd, 0xd9, 0x10, 0xf7, 0x7b, 0x9a, 0x68, 0x9b, 0xa4, 0x05,
+	0xf5, 0x57, 0x81, 0xee, 0xfb, 0x68, 0x3e, 0xc3, 0x28, 0x09, 0xd0, 0xd0, 0xb2, 0xa2, 0x38, 0xba,
+	0x69, 0x5b, 0x18, 0x26, 0x8f, 0x95, 0x9a, 0xc6, 0x77, 0xf1, 0x7c, 0xc0, 0xa4, 0x67, 0xe2, 0x71,
+	0x54, 0x66, 0xdf, 0x32, 0x12, 0x22, 0xc3, 0x4a, 0xdf, 0x76, 0xf0, 0xd0, 0xfe, 0x1e, 0xa5, 0x4a,
+	0x4b, 0x68, 0x97, 0xb4, 0xcb, 0x7d, 0xfc, 0x2d, 0x05, 0x2a, 0x55, 0x99, 0xe5, 0xe5, 0x5e, 0x31,
+	0xe0, 0xc3, 0x19, 0xec, 0x70, 0xf2, 0x9f, 0x40, 0xcd, 0x49, 0x85, 0x7c, 0x72, 0xb4, 0x0b, 0x0a,
+	0x30, 0x76, 0x32, 0x36, 0xed, 0xfe, 0xb4, 0x0c, 0xd5, 0xe4, 0xde, 0x20, 0x7d, 0x28, 0x3d, 0x45,
+	0x4a, 0xd4, 0x02, 0x37, 0x13, 0xef, 0x15, 0xb9, 0x33, 0xb7, 0x3e, 0x87, 0x7e, 0x0a, 0xe5, 0xf8,
+	0xb6, 0x22, 0x45, 0xcf, 0xc6, 0xa9, 0x1b, 0x50, 0xde, 0x5c, 0xc0, 0x82, 0x07, 0xf3, 0xa0, 0x9a,
+	0xbc, 0x48, 0x48, 0x91, 0xf1, 0xf4, 0x83, 0x48, 0xee, 0x2e, 0x62, 0x32, 0x0e, 0x98, 0xbc, 0x09,
+	0x0a, 0x03, 0x4e, 0xbf, 0x67, 0x0a, 0x03, 0xce, 0x7a, 0x6d, 0x1c, 0x42, 0x35, 0xb9, 0xa2, 0x0b,
+	0x03, 0x4e, 0xdf, 0xe4, 0xf2, 0xfa, 0xd4, 0x4b, 0x67, 0x2f, 0xfe, 0x0d, 0x21, 0xe7, 0xd0, 0xc8,
+	0xce, 0x41, 0xd2, 0x9d, 0x6f, 0xfe, 0xe6, 0x7c, 0xdf, 0x5f, 0xc8, 0x86, 0x67, 0x73, 0x0e, 0x8d,
+	0xec, 0xb0, 0x29, 0x0c, 0x3c, 0x63, 0xa4, 0x16, 0x06, 0x9e, 0x39, 0xcd, 0x7e, 0x14, 0xe0, 0xd6,
+	0xd4, 0x71, 0x23, 0x9f, 0xcf, 0xd9, 0xdc, 0x93, 0xe3, 0x4b, 0x7e, 0xb0, 0xb8, 0x61, 0x02, 0x64,
+	0xe7, 0xe8, 0xe2, 0x6d, 0x73, 0xe9, 0xcf, 0xb7, 0xcd, 0xa5, 0x1f, 0x46, 0x4d, 0xe1, 0x62, 0xd4,
+	0x14, 0xfe, 0x18, 0x35, 0x85, 0xbf, 0x47, 0x4d, 0xe1, 0xdb, 0x2f, 0xaf, 0xf8, 0xb7, 0xba, 0x9d,
+	0xac, 0x8e, 0x96, 0x8e, 0xab, 0xac, 0xcc, 0xf7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x62, 0xc8,
+	0x88, 0xc3, 0xf8, 0x0e, 0x00, 0x00,
 }
diff --git a/api/services/images/v1/images.proto b/api/services/images/v1/images.proto
index 14645d5..e990aed 100644
--- a/api/services/images/v1/images.proto
+++ b/api/services/images/v1/images.proto
@@ -141,14 +141,14 @@ message EncryptConfig {
 
 // DecryptKeyData holds the private key data and the password for the private key
 message DecryptKeyData {
-	bytes keyData = 1;
-	bytes keyDataPassword = 2;
+	bytes symKeyData = 1;
+	uint32 symKeyCipher = 2;
 }
 
 // DecrypConfig holds the Ids of public keys and their corresponding private keys
 // needed for decrypting data
 message DecryptConfig {
-	map<uint64, DecryptKeyData> keyIdMap = 1;
+	map<string, DecryptKeyData> layerSymKeyMap = 1;
 }
 
 message EncryptImageRequest {
@@ -185,7 +185,7 @@ message GetImageLayerInfoRequest {
 
 message LayerInfo {
 	uint32 id = 1;
-	repeated uint64 keyIds = 2;
+	repeated bytes WrappedKeys = 2;
 	string digest = 3;
 	string encryption = 4;
 	int64 fileSize = 5;
diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 568fa84..0e8571f 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -96,7 +96,7 @@ var decryptCommand = cli.Command{
 
 		isEncrypted := false
 		for i := 0; i < len(layerInfos); i++ {
-			if len(layerInfos[i].KeyIds) > 0 {
+			if len(layerInfos[i].WrappedKeys) > 0 {
 				isEncrypted = true
 			}
 		}
@@ -105,12 +105,12 @@ var decryptCommand = cli.Command{
 			return nil
 		}
 
-		keyIdMap, err := getPrivateKeys(layerInfos, gpgClient)
+		layerSymKeyMap, err := getSymmetricKeys(layerInfos, gpgClient)
 		fmt.Printf("\n")
 
 		cc := &images.CryptoConfig{
 			Dc: &images.DecryptConfig{
-				KeyIdMap: keyIdMap,
+				LayerSymKeyMap: layerSymKeyMap,
 			},
 		}
 		_, err = client.ImageService().DecryptImage(ctx, local, newName, cc, layers32, context.StringSlice("platform"))
@@ -135,21 +135,33 @@ func addToSet(set, add []uint64) []uint64 {
 	return set
 }
 
-// getPrivateKeys walks the list of layerInfos and determines which keys are on this system
-// and prompts for the passwords for those that are available. If we do not find a private
-// key on the system for a layer then an error is displayed.
-func getPrivateKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (map[uint64]images.DecryptKeyData, error) {
-	keyIdMap := make(map[uint64]images.DecryptKeyData)
+// getSymmetricKeys walks the list of layerInfos and tries to decrypt the
+// wrapped symmetric keys. For this it determines which private keys are on
+// this system and prompts for the passwords for those that are available.
+// If we do not find a private key on the system for getting to the symmetric
+// key of a layer then an error is generated. Otherwise the wrapped symmetric
+// key is decrypted using the private key and added to a map that describes
+// the layer by platform name and layer number as key and the symmetric key
+// data as value
+func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (map[string]images.DecryptKeyData, error) {
+	type PrivKeyData struct {
+		KeyData         []byte
+		KeyDataPassword []byte
+	}
+	var pkd PrivKeyData
+	keyIdPasswordMap := make(map[uint64]PrivKeyData)
+	layerSymkeyMap := make(map[string]images.DecryptKeyData)
 
-	// we need one key per encrypted layer
+	// we need to decrypt one symmetric key per encrypted layer per platform
 	for _, layerInfo := range layerInfos {
+
+		keyIds, err := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
+		if err != nil {
+			return layerSymkeyMap, err
+		}
+
 		found := false
-		for _, keyid := range layerInfo.KeyIds {
-			if _, ok := keyIdMap[keyid]; ok {
-				// password already there
-				found = true
-				break
-			}
+		for _, keyid := range keyIds {
 			// do we have this key?
 			keyinfo, haveKey, err := gpgClient.GetSecretKeyDetails(keyid)
 			// this may fail if the key is not here; we ignore the error
@@ -158,29 +170,45 @@ func getPrivateKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (
 				continue
 			}
 
-			fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
-			fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
-
-			password, err := terminal.ReadPassword(int(syscall.Stdin))
-			fmt.Printf("\n")
-			if err != nil {
-				return keyIdMap, err
+			var ok bool
+			if pkd, ok = keyIdPasswordMap[keyid]; !ok {
+				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
+				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
+
+				password, err := terminal.ReadPassword(int(syscall.Stdin))
+				fmt.Printf("\n")
+				if err != nil {
+					return layerSymkeyMap, err
+				}
+				keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
+				if err != nil {
+					return layerSymkeyMap, err
+				}
+				pkd = PrivKeyData{
+					KeyData:         keydata,
+					KeyDataPassword: password,
+				}
+				keyIdPasswordMap[keyid] = pkd
 			}
 
-			keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
+			symKeyData, symKeyCipher, err := images.DecryptSymmetricKey(layerInfo.WrappedKeys, keyid, pkd.KeyData, pkd.KeyDataPassword, nil)
 			if err != nil {
-				return keyIdMap, err
+				return layerSymkeyMap, err
 			}
-			keyIdMap[keyid] = images.DecryptKeyData{
-				KeyData:         keydata,
-				KeyDataPassword: password,
+
+			index := fmt.Sprintf("%s:%d", layerInfo.Platform, layerInfo.Id)
+			layerSymkeyMap[index] = images.DecryptKeyData{
+				SymKeyData:   symKeyData,
+				SymKeyCipher: uint8(symKeyCipher),
 			}
 			found = true
 			break
 		}
-		if !found && len(layerInfo.KeyIds) > 0 {
-			return keyIdMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, layerInfo.KeyIds)
+		if !found && len(layerInfo.WrappedKeys) > 0 {
+			keyIds, _ := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
+
+			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, keyIds)
 		}
 	}
-	return keyIdMap, nil
+	return layerSymkeyMap, nil
 }
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index eb0aa4d..2b4725b 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -112,13 +112,13 @@ var encryptCommand = cli.Command{
 
 		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
 
-		keyIdMap := make(map[uint64]images.DecryptKeyData)
+		layerSymKeyMap := make(map[string]images.DecryptKeyData)
 		if operation == images.OPERATION_ADD_RECIPIENTS {
 			layerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
 			if err != nil {
 				return err
 			}
-			keyIdMap, err = getPrivateKeys(layerInfos, gpgClient)
+			layerSymKeyMap, err = getSymmetricKeys(layerInfos, gpgClient)
 		}
 
 		cc := &images.CryptoConfig{
@@ -127,7 +127,7 @@ var encryptCommand = cli.Command{
 				Recipients:     recipients,
 				Operation:      operation,
 				Dc: images.DecryptConfig{
-					KeyIdMap: keyIdMap,
+					LayerSymKeyMap: layerSymKeyMap,
 				},
 			},
 		}
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index fdbd144..36a6915 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -20,9 +20,11 @@ import (
 	"fmt"
 	"os"
 	"strconv"
+	"strings"
 	"text/tabwriter"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
+	"github.com/containerd/containerd/images"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
 )
@@ -71,14 +73,16 @@ var layerinfoCommand = cli.Command{
 		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', tabwriter.AlignRight)
 		fmt.Fprintf(w, "#\tDIGEST\tPLATFORM\tSIZE\tENCRYPTION\tKEY IDS\t\n")
 		for _, layer := range LayerInfos {
-			keyids := ""
-			for _, keyid := range layer.KeyIds {
-				if keyids != "" {
-					keyids = keyids + ", "
-				}
-				keyids = keyids + "0x" + strconv.FormatUint(keyid, 16)
+			keyIds, err := images.WrappedKeysToKeyIds(layer.WrappedKeys)
+			if err != nil {
+				return err
 			}
-			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Platform, layer.FileSize, layer.Encryption, keyids)
+
+			var array []string
+			for _, keyid := range keyIds {
+				array = append(array, "0x"+strconv.FormatUint(keyid, 16))
+			}
+			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Platform, layer.FileSize, layer.Encryption, strings.Join(array, ", "))
 		}
 		w.Flush()
 		return nil
diff --git a/image_store.go b/image_store.go
index 4b9347d..4bbb3aa 100644
--- a/image_store.go
+++ b/image_store.go
@@ -126,14 +126,9 @@ func imageFromProto(imagepb *imagesapi.Image) images.Image {
 }
 
 func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
-	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
+	layerSymKeyMap := make(map[string]*imagesapi.DecryptKeyData)
 	if cc.Dc != nil {
-		for k, v := range cc.Dc.KeyIdMap {
-			keyIdMap[k] = &imagesapi.DecryptKeyData{
-				KeyData:         v.KeyData,
-				KeyDataPassword: v.KeyDataPassword,
-			}
-		}
+		layerSymKeyMap = convLayerSymKeyMap(cc.Dc.LayerSymKeyMap)
 	}
 
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
@@ -144,7 +139,7 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 			Gpgpubkeyring: cc.Ec.GPGPubRingFile,
 			Operation:     cc.Ec.Operation,
 			Dc: &imagesapi.DecryptConfig{
-				KeyIdMap: keyIdMap,
+				LayerSymKeyMap: layerSymKeyMap,
 			},
 		},
 		Layers:    layers,
@@ -158,19 +153,13 @@ func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, c
 }
 
 func (s *remoteImages) DecryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
-	keyIdMap := make(map[uint64]*imagesapi.DecryptKeyData)
-	for k, v := range cc.Dc.KeyIdMap {
-		keyIdMap[k] = &imagesapi.DecryptKeyData{
-			KeyData:         v.KeyData,
-			KeyDataPassword: v.KeyDataPassword,
-		}
-	}
+	layerSymKeyMap := convLayerSymKeyMap(cc.Dc.LayerSymKeyMap)
 
 	resp, err := s.client.DecryptImage(ctx, &imagesapi.DecryptImageRequest{
 		Name:    name,
 		NewName: newName,
 		Dc: &imagesapi.DecryptConfig{
-			KeyIdMap: keyIdMap,
+			LayerSymKeyMap: layerSymKeyMap,
 		},
 		Layers:    layers,
 		Platforms: platforms,
@@ -195,7 +184,7 @@ func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layer
 	li := make([]images.LayerInfo, len(resp.LayerInfo))
 	for i := 0; i < len(resp.LayerInfo); i++ {
 		li[i].Id = resp.LayerInfo[i].ID
-		li[i].KeyIds = resp.LayerInfo[i].KeyIds
+		li[i].WrappedKeys = resp.LayerInfo[i].WrappedKeys
 		li[i].Digest = resp.LayerInfo[i].Digest
 		li[i].Encryption = resp.LayerInfo[i].Encryption
 		li[i].FileSize = resp.LayerInfo[i].FileSize
@@ -205,6 +194,18 @@ func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layer
 	return li, nil
 }
 
+func convLayerSymKeyMap(layerSymKeyMap map[string]images.DecryptKeyData) map[string]*imagesapi.DecryptKeyData {
+	layerSymKeyMapOut := make(map[string]*imagesapi.DecryptKeyData)
+
+	for k, v := range layerSymKeyMap {
+		layerSymKeyMapOut[k] = &imagesapi.DecryptKeyData{
+			SymKeyData:   v.SymKeyData,
+			SymKeyCipher: uint32(v.SymKeyCipher),
+		}
+	}
+	return layerSymKeyMapOut
+}
+
 func imagesFromProto(imagespb []imagesapi.Image) []images.Image {
 	var images []images.Image
 
diff --git a/images/encryption.go b/images/encryption.go
index 56788e9..358e02e 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -18,6 +18,7 @@ package images
 
 import (
 	"bytes"
+	"fmt"
 	"io/ioutil"
 	"net/mail"
 	"strings"
@@ -50,14 +51,14 @@ const (
 // DecryptKeyData stores private key data for decryption and the necessary password
 // for being able to access/decrypt the private key data
 type DecryptKeyData struct {
-	KeyData         []byte
-	KeyDataPassword []byte
+	SymKeyData   []byte
+	SymKeyCipher uint8
 }
 
-// DecryptConfig stores the KeyIDs of keys needed for decryption as keys of
-// a map and the actual private key data in the values
+// DecryptConfig stores the platform layer number of keys needed for decryption as
+// keys of a map and the actual symmetric key data as value
 type DecryptConfig struct {
-	KeyIdMap map[uint64]DecryptKeyData
+	LayerSymKeyMap map[string]DecryptKeyData
 }
 
 // CryptoConfig is a common wrapper for EncryptConfig and DecrypConfig that can
@@ -140,7 +141,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 	switch ec.Operation {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
-			wrappedKeys, err = addRecipientsToKeys(keys, filteredList, ec.Dc.KeyIdMap)
+			wrappedKeys, err = addRecipientsToKeys(keys, filteredList, ec.Dc.LayerSymKeyMap)
 		} else {
 			encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 		}
@@ -157,11 +158,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 }
 
 // Decrypt decrypts a byte array using data from the DecryptConfig
-func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor) ([]byte, error) {
-	keyIds, err := GetKeyIds(desc)
-	if err != nil {
-		return nil, err
-	}
+func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor, layerNum int32, platform string) ([]byte, error) {
 
 	keys, err := getWrappedKeys(desc)
 	if err != nil {
@@ -169,57 +166,13 @@ func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor) ([]byte
 	}
 
 	data := assembleEncryptedMessage(encBody, keys)
-	// decrypt with the right key
-	for _, keyId := range keyIds {
-		if keydata, ok := dc.KeyIdMap[keyId]; ok {
-			r := bytes.NewReader(keydata.KeyData)
-			entityList, err := openpgp.ReadKeyRing(r)
-			if err != nil {
-				return []byte{}, err
-			}
-			entity := entityList[0]
-			entity.PrivateKey.Decrypt(keydata.KeyDataPassword)
-			for _, subkey := range entity.Subkeys {
-				subkey.PrivateKey.Decrypt(keydata.KeyDataPassword)
-			}
-			md, err := openpgp.ReadMessage(bytes.NewBuffer(data), entityList, nil, nil)
-			if err != nil {
-				return []byte{}, err
-			}
-			return ioutil.ReadAll(md.UnverifiedBody)
-		}
-	}
-	return []byte{}, errors.Wrapf(errdefs.ErrNotFound, "No suitable decryption key was found.")
-}
 
-// GetKeyIds gets the Key IDs for which the data are encrypted
-func GetKeyIds(desc ocispec.Descriptor) ([]uint64, error) {
-	var keyids []uint64
+	index := fmt.Sprintf("%s:%d", platform, layerNum)
+	r := bytes.NewReader(data)
 
-	keys, err := getWrappedKeys(desc)
+	md, err := ReadMessage(r, dc.LayerSymKeyMap[index].SymKeyData, packet.CipherFunction(dc.LayerSymKeyMap[index].SymKeyCipher))
 	if err != nil {
-		return nil, err
-	}
-
-	kbytes := make([]byte, 0)
-	for _, k := range keys {
-		kbytes = append(kbytes, k...)
-	}
-	kbuf := bytes.NewBuffer(kbytes)
-
-	packets := packet.NewReader(kbuf)
-ParsePackets:
-	for {
-		p, err := packets.Next()
-		if err != nil {
-			break ParsePackets
-		}
-		switch p := p.(type) {
-		case *packet.EncryptedKey:
-			keyids = append(keyids, p.KeyId)
-		case *packet.SymmetricallyEncrypted:
-			break ParsePackets
-		}
+		return []byte{}, err
 	}
-	return keyids, nil
+	return ioutil.ReadAll(md.UnverifiedBody)
 }
diff --git a/images/image.go b/images/image.go
index 72e9f7e..1e34f2e 100644
--- a/images/image.go
+++ b/images/image.go
@@ -63,8 +63,8 @@ type Image struct {
 type LayerInfo struct {
 	// The Id of the layer starting at 0
 	Id uint32
-	// An array of KeyIds to which the layer is encrypted
-	KeyIds []uint64
+	// Array of wrapped keys from which KeyIds can be derived
+	WrappedKeys [][]byte
 	// The Digest of the layer
 	Digest string
 	// The Encryption method used for encrypting the layer
@@ -487,8 +487,8 @@ func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 
 // decryptLayer decrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
 // The caller is expected to store the returned plain data and OCI Descriptor
-func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
-	p, err := Decrypt(cc.Dc, data, desc)
+func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor, layerNum int32, platform *ocispec.Platform) (ocispec.Descriptor, []byte, error) {
+	p, err := Decrypt(cc.Dc, data, desc, layerNum, platforms.Format(*platform))
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
@@ -511,7 +511,7 @@ func decryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 }
 
 // cryptLayer handles the changes due to encryption or decryption of a layer
-func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, encrypt bool) (ocispec.Descriptor, error) {
+func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, layerNum int32, platform *ocispec.Platform, encrypt bool) (ocispec.Descriptor, error) {
 	var (
 		p       []byte
 		newDesc ocispec.Descriptor
@@ -525,7 +525,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	if encrypt {
 		newDesc, p, err = encryptLayer(cc, data, desc)
 	} else {
-		newDesc, p, err = decryptLayer(cc, data, desc)
+		newDesc, p, err = decryptLayer(cc, data, desc, layerNum, platform)
 	}
 	if err != nil {
 		return ocispec.Descriptor{}, err
@@ -672,7 +672,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 			config = child
 		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
 			if encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
-				nl, err := cryptLayer(ctx, cs, child, cc, true)
+				nl, err := cryptLayer(ctx, cs, child, cc, layerNum, thisPlatform, true)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
 				}
@@ -685,7 +685,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		case MediaTypeDockerSchema2LayerGzipPGP, MediaTypeDockerSchema2LayerPGP:
 			// this one can be decrypted but also its recpients list changed
 			if isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
-				nl, err := cryptLayer(ctx, cs, child, cc, encrypt)
+				nl, err := cryptLayer(ctx, cs, child, cc, layerNum, thisPlatform, encrypt)
 				if err != nil {
 					return ocispec.Descriptor{}, false, err
 				}
@@ -849,25 +849,25 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 	case MediaTypeDockerSchema2Layer, MediaTypeDockerSchema2LayerGzip:
 		li := LayerInfo{
-			KeyIds:     []uint64{},
-			Digest:     desc.Digest.String(),
-			Encryption: "",
-			FileSize:   desc.Size,
-			Id:         uint32(layerNum),
+			WrappedKeys: [][]byte{},
+			Digest:      desc.Digest.String(),
+			Encryption:  "",
+			FileSize:    desc.Size,
+			Id:          uint32(layerNum),
 		}
 		lis = append(lis, li)
 	case MediaTypeDockerSchema2Config:
 	case MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP:
-		keyIds, err := GetKeyIds(desc)
+		wrappedKeys, err := getWrappedKeys(desc)
 		if err != nil {
 			return []LayerInfo{}, err
 		}
 		li := LayerInfo{
-			KeyIds:     keyIds,
-			Digest:     desc.Digest.String(),
-			Encryption: "pgp",
-			FileSize:   desc.Size,
-			Id:         uint32(layerNum),
+			WrappedKeys: wrappedKeys,
+			Digest:      desc.Digest.String(),
+			Encryption:  "pgp",
+			FileSize:    desc.Size,
+			Id:          uint32(layerNum),
 		}
 		lis = append(lis, li)
 	default:
diff --git a/images/openpgp.go b/images/openpgp.go
index 3f46ce9..9f83238 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -1,10 +1,57 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+   Some parts of this file were copied from golang's openpgp implementation
+   which is under the following license:
+
+   Copyright (c) 2009 The Go Authors. All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are
+   met:
+
+      * Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+      * Redistributions in binary form must reproduce the above
+   copyright notice, this list of conditions and the following disclaimer
+   in the documentation and/or other materials provided with the
+   distribution.
+      * Neither the name of Google Inc. nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
 package images
 
 import (
 	"bytes"
 	"fmt"
 	"io"
-	"io/ioutil"
 	"log"
 	"time"
 
@@ -52,7 +99,7 @@ func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (enc
 	return encBlob, wrappedKeys, nil
 }
 
-func addRecipientsToKeys(keys [][]byte, newRecipients openpgp.EntityList, keyIdMap map[uint64]DecryptKeyData) ([][]byte, error) {
+func addRecipientsToKeys(keys [][]byte, newRecipients openpgp.EntityList, keyIdMap map[string]DecryptKeyData) ([][]byte, error) {
 	return [][]byte{}, errors.Wrapf(errdefs.ErrNotImplemented, "Adding recipients is not supported\n")
 }
 
@@ -76,54 +123,6 @@ func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList
 	return wrappedKeys, nil
 }
 
-// decryptData decrypts an openpgp encrypted blob and wrapped keys and returns the decrypted data
-func decryptData(encBlob []byte, wrappedKeys [][]byte, kring openpgp.EntityList) (data []byte, err error) {
-	// Assemble message by concatenating packets
-	message := make([]byte, 0)
-	for _, ek := range wrappedKeys {
-		message = append(message, ek...)
-
-		// experiment
-		ekbuf := bytes.NewBuffer(ek)
-		p, err := packet.Read(ekbuf)
-		if err != nil {
-			log.Fatalf("Err reading enc key packet: %v", err)
-		}
-
-		pek := p.(*packet.EncryptedKey)
-		log.Printf("Enckey KeyID: %x", pek.KeyId)
-		log.Printf("  getting KeyID: %v", kring.KeysById(pek.KeyId))
-
-	}
-
-	message = append(message, encBlob...)
-
-	log.Printf("Encrypted message bytes: %x", message)
-
-	promptFunc := func(key []openpgp.Key, symm bool) ([]byte, error) {
-		for _, k := range key {
-			if symm {
-				return nil, errors.Wrapf(errdefs.ErrNotImplemented, "Not handled")
-			} else {
-				k.PrivateKey.Decrypt([]byte("hidden!"))
-			}
-		}
-		return nil, nil
-	}
-	messageIn := bytes.NewBuffer(message)
-	md, err := openpgp.ReadMessage(messageIn, kring, promptFunc, DefaultEncryptConfig)
-	if err != nil {
-		return nil, errors.Wrapf(err, "Unable to read message: %v", err)
-	}
-
-	plaintext, err := ioutil.ReadAll(md.UnverifiedBody)
-	if err != nil {
-		return nil, errors.Wrapf(err, "error reading encrypted contents: %s", err)
-	}
-
-	return plaintext, nil
-}
-
 // createWrappedKeys creates wrapped key bytes
 func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
 	// Array of serialized EncryptedKeys
@@ -262,3 +261,170 @@ func primaryIdentity(e *openpgp.Entity) *openpgp.Identity {
 	}
 	return firstIdentity
 }
+
+// WrappedKeysToKeyIds converts an array of wrapped keys into an array of
+// their key Ids
+func WrappedKeysToKeyIds(keys [][]byte) ([]uint64, error) {
+	var keyids []uint64
+
+	kbytes := make([]byte, 0)
+	for _, k := range keys {
+		kbytes = append(kbytes, k...)
+	}
+	kbuf := bytes.NewBuffer(kbytes)
+
+	packets := packet.NewReader(kbuf)
+ParsePackets:
+	for {
+		p, err := packets.Next()
+		if err == io.EOF {
+			break ParsePackets
+		}
+		if err != nil {
+			return []uint64{}, errors.Wrapf(err, "packets.Next() failed")
+		}
+		switch p := p.(type) {
+		case *packet.EncryptedKey:
+			keyids = append(keyids, p.KeyId)
+		}
+	}
+	return keyids, nil
+}
+
+// DecryptSymmetricKey decrypts a symmetric key from an array of wrapped keys. The public
+// key with the given keyid is attempted to be decrypted using the private key given
+// by keyData and keyDataPassword
+func DecryptSymmetricKey(keys [][]byte, keyid uint64, keyData []byte, keyDataPassword []byte, config *packet.Config) ([]byte, packet.CipherFunction, error) {
+	kbytes := make([]byte, 0)
+	for _, k := range keys {
+		kbytes = append(kbytes, k...)
+	}
+	kbuf := bytes.NewBuffer(kbytes)
+
+	var ek *packet.EncryptedKey
+
+	packets := packet.NewReader(kbuf)
+ParsePackets:
+	for {
+		p, err := packets.Next()
+		if err == io.EOF {
+			break ParsePackets
+		}
+		if err != nil {
+			return []byte{}, 0, errors.Wrapf(err, "packets.Next() failed")
+		}
+		switch p := p.(type) {
+		case *packet.EncryptedKey:
+			if p.KeyId == keyid {
+				ek = p
+				break ParsePackets
+			}
+		}
+	}
+
+	if ek == nil {
+		return []byte{}, 0, errors.Wrapf(errdefs.ErrNotFound, "Key with id 0x%x could not be found.", keyid)
+	}
+
+	// read the private keys
+	r := bytes.NewReader(keyData)
+	entityList, err := openpgp.ReadKeyRing(r)
+	if err != nil {
+		return []byte{}, 0, errors.Wrapf(err, "Could not read keyring")
+	}
+	// decrypt them
+	entity := entityList[0]
+	entity.PrivateKey.Decrypt(keyDataPassword)
+	for _, subkey := range entity.Subkeys {
+		subkey.PrivateKey.Decrypt(keyDataPassword)
+	}
+
+	// try with another key
+	decrypted := false
+	for _, subkey := range entity.Subkeys {
+		if (subkey.Sig.FlagsValid &&
+			subkey.Sig.FlagEncryptCommunications &&
+			subkey.PublicKey.PubKeyAlgo.CanEncrypt()) {
+			err = ek.Decrypt(subkey.PrivateKey, config)
+			if err == nil {
+				decrypted = true
+				break
+			}
+		}
+	}
+	if !decrypted {
+		return []byte{}, 0, errors.Wrapf(err, "could not decrypt symmetric key")
+	}
+
+	return ek.Key, ek.CipherFunc, nil
+}
+
+// ReadMessage reads an OpenPGP byte stream and decrypts it with the given symmetric key and cipher
+func ReadMessage(r io.Reader, symKey []byte, symKeyCipher packet.CipherFunction) (*openpgp.MessageDetails, error) {
+	var se *packet.SymmetricallyEncrypted
+
+	packets := packet.NewReader(r)
+
+ParsePackets:
+	for {
+		p, err := packets.Next()
+		if err == io.EOF {
+			break ParsePackets
+		}
+		if err != nil {
+			return nil, errors.Wrapf(err, "packets.Next() failed")
+		}
+		switch p := p.(type) {
+		case *packet.SymmetricallyEncrypted:
+			se = p
+			break ParsePackets
+		}
+	}
+
+	if se == nil {
+		return nil, errors.Wrapf(errdefs.ErrNotFound, "No symmetrically encrypted data found.")
+	}
+
+	decrypted, err := se.Decrypt(symKeyCipher, symKey)
+	if err != nil {
+		return nil, errors.Wrapf(err, "Decrypting layer with symmetric key failed")
+	}
+
+	if err := packets.Push(decrypted); err != nil {
+		return nil, errors.Wrapf(err, "Pushing failed")
+	}
+
+	md := new(openpgp.MessageDetails)
+	var p packet.Packet
+FindLiteralData:
+	for {
+		p, err = packets.Next()
+		if err == io.EOF {
+			break FindLiteralData
+		}
+		if err != nil {
+			return nil, errors.Wrapf(err, "packets.Next() failed")
+		}
+		switch p := p.(type) {
+		case *packet.LiteralData:
+			md.LiteralData = p
+			break FindLiteralData
+		}
+	}
+
+	if md.LiteralData == nil {
+		return nil, errors.Wrapf(errdefs.ErrNotFound, "LiteralData not found")
+	}
+
+	md.UnverifiedBody = checkReader{md}
+
+	return md, nil
+}
+
+type checkReader struct {
+	md *openpgp.MessageDetails
+}
+
+func (cr checkReader) Read(buf []byte) (n int, err error) {
+	return cr.md.LiteralData.Body.Read(buf)
+}
diff --git a/services/images/local.go b/services/images/local.go
index ee38c66..efe7bb8 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -186,14 +186,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 
 	var resp imagesapi.EncryptImageResponse
 
-	keyIdMap := make(map[uint64]images.DecryptKeyData)
-
-	for k, v := range req.Ec.Dc.KeyIdMap {
-		keyIdMap[k] = images.DecryptKeyData{
-			KeyData:         v.KeyData,
-			KeyDataPassword: v.KeyDataPassword,
-		}
-	}
+	layerSymKeyMap := convLayerSymKeyMap(req.Ec.Dc.LayerSymKeyMap)
 
 	encrypted, err := l.store.EncryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
 		Ec: &images.EncryptConfig{
@@ -201,7 +194,7 @@ func (l *local) EncryptImage(ctx context.Context, req *imagesapi.EncryptImageReq
 			GPGPubRingFile: req.Ec.Gpgpubkeyring,
 			Operation:      req.Ec.Operation,
 			Dc: images.DecryptConfig{
-				KeyIdMap: keyIdMap,
+				LayerSymKeyMap: layerSymKeyMap,
 			},
 		},
 	}, req.Layers, req.Platforms)
@@ -226,18 +219,11 @@ func (l *local) DecryptImage(ctx context.Context, req *imagesapi.DecryptImageReq
 
 	var resp imagesapi.DecryptImageResponse
 
-	keyIdMap := make(map[uint64]images.DecryptKeyData)
-
-	for k, v := range req.Dc.KeyIdMap {
-		keyIdMap[k] = images.DecryptKeyData{
-			KeyData:         v.KeyData,
-			KeyDataPassword: v.KeyDataPassword,
-		}
-	}
+	layerSymKeyMap := convLayerSymKeyMap(req.Dc.LayerSymKeyMap)
 
 	encrypted, err := l.store.DecryptImage(ctx, req.Name, req.NewName, &images.CryptoConfig{
 		Dc: &images.DecryptConfig{
-			KeyIdMap: keyIdMap,
+			LayerSymKeyMap: layerSymKeyMap,
 		},
 	}, req.Layers, req.Platforms)
 	if err != nil {
@@ -268,14 +254,26 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	resp.LayerInfo = make([]*imagesapi.LayerInfo, len(lis))
 	for i := 0; i < len(lis); i++ {
 		resp.LayerInfo[i] = &imagesapi.LayerInfo{
-			ID:         lis[i].Id,
-			KeyIds:     lis[i].KeyIds,
-			Digest:     lis[i].Digest,
-			Encryption: lis[i].Encryption,
-			FileSize:   lis[i].FileSize,
-			Platform:   lis[i].Platform,
+			ID:          lis[i].Id,
+			WrappedKeys: lis[i].WrappedKeys,
+			Digest:      lis[i].Digest,
+			Encryption:  lis[i].Encryption,
+			FileSize:    lis[i].FileSize,
+			Platform:    lis[i].Platform,
 		}
 	}
 
 	return &resp, nil
 }
+
+func convLayerSymKeyMap(layerSymKeyMap map[string]*imagesapi.DecryptKeyData) map[string]images.DecryptKeyData {
+	layerSymKeyMapOut := make(map[string]images.DecryptKeyData)
+
+	for k, v := range layerSymKeyMap {
+		layerSymKeyMapOut[k] = images.DecryptKeyData{
+			SymKeyData:   v.SymKeyData,
+			SymKeyCipher: uint8(v.SymKeyCipher),
+		}
+	}
+	return layerSymKeyMapOut
+}
-- 
2.7.4


From bbf8a06c0c760c9f5da4baddbaccaa6112a82353 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Mon, 30 Jul 2018 13:49:06 -0400
Subject: [PATCH 48/79] Added list check by keyid query and a bit more error
 checking for symkey

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/encryption.go |  7 ++++++-
 images/openpgp.go    | 33 +++++++++++++++++----------------
 2 files changed, 23 insertions(+), 17 deletions(-)

diff --git a/images/encryption.go b/images/encryption.go
index 358e02e..4783d8e 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -170,7 +170,12 @@ func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor, layerNu
 	index := fmt.Sprintf("%s:%d", platform, layerNum)
 	r := bytes.NewReader(data)
 
-	md, err := ReadMessage(r, dc.LayerSymKeyMap[index].SymKeyData, packet.CipherFunction(dc.LayerSymKeyMap[index].SymKeyCipher))
+	symKey := dc.LayerSymKeyMap[index].SymKeyData
+	if len(symKey) == 0 {
+		return nil, errors.New("Unable to retrieve symkey for layer")
+	}
+
+	md, err := ReadMessage(r, symKey, packet.CipherFunction(dc.LayerSymKeyMap[index].SymKeyCipher))
 	if err != nil {
 		return []byte{}, err
 	}
diff --git a/images/openpgp.go b/images/openpgp.go
index 9f83238..69e6f4e 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -333,27 +333,26 @@ ParsePackets:
 		return []byte{}, 0, errors.Wrapf(err, "Could not read keyring")
 	}
 	// decrypt them
-	entity := entityList[0]
-	entity.PrivateKey.Decrypt(keyDataPassword)
-	for _, subkey := range entity.Subkeys {
-		subkey.PrivateKey.Decrypt(keyDataPassword)
+	decKeys := entityList.KeysByIdUsage(ek.KeyId, packet.KeyFlagEncryptCommunications)
+	for _, k := range decKeys {
+		if k.PrivateKey.Encrypted {
+			if err := k.PrivateKey.Decrypt(keyDataPassword); err != nil {
+				return []byte{}, 0, errors.Wrapf(err, "passphrase invalid for private key")
+			}
+		}
 	}
-
-	// try with another key
 	decrypted := false
-	for _, subkey := range entity.Subkeys {
-		if (subkey.Sig.FlagsValid &&
-			subkey.Sig.FlagEncryptCommunications &&
-			subkey.PublicKey.PubKeyAlgo.CanEncrypt()) {
-			err = ek.Decrypt(subkey.PrivateKey, config)
-			if err == nil {
-				decrypted = true
-				break
-			}
+
+	for _, k := range decKeys {
+		err = ek.Decrypt(k.PrivateKey, config)
+		if err == nil {
+			decrypted = true
+			break
 		}
 	}
+
 	if !decrypted {
-		return []byte{}, 0, errors.Wrapf(err, "could not decrypt symmetric key")
+		return []byte{}, 0, errors.New("could not successfully decrypt symmetric key, no valid keys usable")
 	}
 
 	return ek.Key, ek.CipherFunc, nil
@@ -385,6 +384,8 @@ ParsePackets:
 		return nil, errors.Wrapf(errdefs.ErrNotFound, "No symmetrically encrypted data found.")
 	}
 
+	fmt.Printf("Symkey :%v", symKey)
+
 	decrypted, err := se.Decrypt(symKeyCipher, symKey)
 	if err != nil {
 		return nil, errors.Wrapf(err, "Decrypting layer with symmetric key failed")
-- 
2.7.4


From ca38dc863af7fa13acd65e9f72c061cadc161a0b Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Mon, 30 Jul 2018 13:58:51 -0400
Subject: [PATCH 49/79] Fixed missing error check that prevented error
 propagation

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 cmd/ctr/commands/images/decrypt.go | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 0e8571f..58268d0 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -106,6 +106,9 @@ var decryptCommand = cli.Command{
 		}
 
 		layerSymKeyMap, err := getSymmetricKeys(layerInfos, gpgClient)
+		if err != nil {
+			return err
+		}
 		fmt.Printf("\n")
 
 		cc := &images.CryptoConfig{
-- 
2.7.4


From 99391da4652ab83c423b20a9472383dbae76dc04 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 30 Jul 2018 14:01:04 -0400
Subject: [PATCH 50/79] Fixed a function description

---
 images/openpgp.go | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 69e6f4e..dc1db2c 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -358,7 +358,8 @@ ParsePackets:
 	return ek.Key, ek.CipherFunc, nil
 }
 
-// ReadMessage reads an OpenPGP byte stream and decrypts it with the given symmetric key and cipher
+// ReadMessage reads an OpenPGP byte stream and decrypts the SymmetricallyEncrypted
+// path with the given symmetric key and cipher
 func ReadMessage(r io.Reader, symKey []byte, symKeyCipher packet.CipherFunction) (*openpgp.MessageDetails, error) {
 	var se *packet.SymmetricallyEncrypted
 
-- 
2.7.4


From 2be7030707290e5f3ac5d82ab5cd8bf9638d7bf7 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 30 Jul 2018 14:02:35 -0400
Subject: [PATCH 51/79] Fixed a typo

---
 images/openpgp.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index dc1db2c..16c9297 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -359,7 +359,7 @@ ParsePackets:
 }
 
 // ReadMessage reads an OpenPGP byte stream and decrypts the SymmetricallyEncrypted
-// path with the given symmetric key and cipher
+// part with the given symmetric key and cipher
 func ReadMessage(r io.Reader, symKey []byte, symKeyCipher packet.CipherFunction) (*openpgp.MessageDetails, error) {
 	var se *packet.SymmetricallyEncrypted
 
-- 
2.7.4


From 558f861e113870729b03893cb5528105b0c554f7 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 30 Jul 2018 15:42:40 -0400
Subject: [PATCH 52/79] Format the key Ids in the error output a bit nicer

---
 cmd/ctr/commands/images/decrypt.go |  4 +++-
 cmd/ctr/commands/utils.go          | 14 +++++++++++++-
 2 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 58268d0..9fed33d 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -18,6 +18,7 @@ package images
 
 import (
 	"fmt"
+	"strings"
 	"syscall"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
@@ -209,8 +210,9 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 		}
 		if !found && len(layerInfo.WrappedKeys) > 0 {
 			keyIds, _ := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
+			kIds := commands.Uint64ToStringArray("0x%x", keyIds)
 
-			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, keyIds)
+			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, strings.Join(kIds, ", "))
 		}
 	}
 	return layerSymkeyMap, nil
diff --git a/cmd/ctr/commands/utils.go b/cmd/ctr/commands/utils.go
index 0cb8a0b..ad3cfce 100644
--- a/cmd/ctr/commands/utils.go
+++ b/cmd/ctr/commands/utils.go
@@ -16,12 +16,24 @@
 
 package commands
 
+import (
+	"fmt"
+)
+
 func IntToInt32Array(in []int) []int32 {
 	var ret []int32
 
-	for _, v := range in{
+	for _, v := range in {
 		ret = append(ret, int32(v))
 	}
 	return ret
 }
 
+func Uint64ToStringArray(format string, in []uint64) []string {
+	var ret []string
+
+	for _, v := range in {
+		ret = append(ret, fmt.Sprintf(format, v))
+	}
+	return ret
+}
-- 
2.7.4


From 8c70a37a7a27148d64b65e7844554332d438a09f Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 30 Jul 2018 17:27:41 -0400
Subject: [PATCH 53/79] More fixes to function descriptions

---
 cmd/ctr/commands/images/decrypt.go |  2 +-
 images/encryption.go               | 16 +++++++++-------
 2 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 9fed33d..6da0d58 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -212,7 +212,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 			keyIds, _ := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
 			kIds := commands.Uint64ToStringArray("0x%x", keyIds)
 
-			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %v\n", layerInfo.Id, layerInfo.Platform, strings.Join(kIds, ", "))
+			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %s", layerInfo.Id, layerInfo.Platform, strings.Join(kIds, ", "))
 		}
 	}
 	return layerSymkeyMap, nil
diff --git a/images/encryption.go b/images/encryption.go
index 4783d8e..c8f4afd 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -38,8 +38,8 @@ type EncryptConfig struct {
 	GPGPubRingFile []byte
 	Operation      int32
 	// for adding recipients on an already encrypted image we need the
-	// private keys for the layers to get to the symmetric key so we can
-	// (re)wrap it with the recpient's public key
+	// symmetric keys for the layers so we can wrap them with the recpient's
+	// public key
 	Dc DecryptConfig
 }
 
@@ -49,14 +49,15 @@ const (
 )
 
 // DecryptKeyData stores private key data for decryption and the necessary password
-// for being able to access/decrypt the private key data
+// for being able to access/decrypt the private key data.
 type DecryptKeyData struct {
 	SymKeyData   []byte
 	SymKeyCipher uint8
 }
 
-// DecryptConfig stores the platform layer number of keys needed for decryption as
-// keys of a map and the actual symmetric key data as value
+// DecryptConfig stores the platform and layer number encode in a string as a
+// key to the map. The symmetric key needed for decrypting a platform specific
+// layer is stored as value.
 type DecryptConfig struct {
 	LayerSymKeyMap map[string]DecryptKeyData
 }
@@ -121,8 +122,9 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 	return filteredList, nil
 }
 
-// HandleEncrypt encrypts a byte array using data from the EncryptConfig and also manages
-// the list of recipients' keys
+// HandleEncrypt encrypts a byte array using data from the EncryptConfig. It
+// also manages the list of recipients' keys by enabling removal or addition
+// of recipients.
 func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
 	var (
 		encBlob     []byte
-- 
2.7.4


From d799b3bc722c2cd37d635927962a3a7f999af309 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 31 Jul 2018 16:10:23 -0400
Subject: [PATCH 54/79] Implement adding of recipients

---
 cmd/ctr/commands/images/encrypt.go |  3 ++
 image_store.go                     |  5 +--
 images/encryption.go               | 12 +++++--
 images/image.go                    |  6 ++--
 images/openpgp.go                  | 66 ++++++++++++++++++++++----------------
 5 files changed, 55 insertions(+), 37 deletions(-)

diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 2b4725b..289cb23 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -119,6 +119,9 @@ var encryptCommand = cli.Command{
 				return err
 			}
 			layerSymKeyMap, err = getSymmetricKeys(layerInfos, gpgClient)
+			if err != nil {
+				return err
+			}
 		}
 
 		cc := &images.CryptoConfig{
diff --git a/image_store.go b/image_store.go
index 4bbb3aa..4da4487 100644
--- a/image_store.go
+++ b/image_store.go
@@ -126,10 +126,7 @@ func imageFromProto(imagepb *imagesapi.Image) images.Image {
 }
 
 func (s *remoteImages) EncryptImage(ctx context.Context, name, newName string, cc *images.CryptoConfig, layers []int32, platforms []string) (images.Image, error) {
-	layerSymKeyMap := make(map[string]*imagesapi.DecryptKeyData)
-	if cc.Dc != nil {
-		layerSymKeyMap = convLayerSymKeyMap(cc.Dc.LayerSymKeyMap)
-	}
+	layerSymKeyMap := convLayerSymKeyMap(cc.Ec.Dc.LayerSymKeyMap)
 
 	resp, err := s.client.EncryptImage(ctx, &imagesapi.EncryptImageRequest{
 		Name:    name,
diff --git a/images/encryption.go b/images/encryption.go
index c8f4afd..e54f810 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -125,7 +125,7 @@ func createEntityList(ec *EncryptConfig) (openpgp.EntityList, error) {
 // HandleEncrypt encrypts a byte array using data from the EncryptConfig. It
 // also manages the list of recipients' keys by enabling removal or addition
 // of recipients.
-func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]byte, error) {
+func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte, layerNum int32, platform string) ([]byte, [][]byte, error) {
 	var (
 		encBlob     []byte
 		wrappedKeys [][]byte
@@ -143,7 +143,13 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte) ([]byte, [][]b
 	switch ec.Operation {
 	case OPERATION_ADD_RECIPIENTS:
 		if len(keys) > 0 {
-			wrappedKeys, err = addRecipientsToKeys(keys, filteredList, ec.Dc.LayerSymKeyMap)
+			index := fmt.Sprintf("%s:%d", platform, layerNum)
+			symKey := ec.Dc.LayerSymKeyMap[index].SymKeyData
+			if len(symKey) == 0 {
+				return nil, nil, errors.Wrapf(errdefs.ErrInvalidArgument, "Unable to retrieve symkey for layer %s", index)
+			}
+			symKeyCipher := packet.CipherFunction(ec.Dc.LayerSymKeyMap[index].SymKeyCipher)
+			wrappedKeys, err = addRecipientsToKeys(keys, filteredList, symKey, symKeyCipher, nil)
 		} else {
 			encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 		}
@@ -174,7 +180,7 @@ func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor, layerNu
 
 	symKey := dc.LayerSymKeyMap[index].SymKeyData
 	if len(symKey) == 0 {
-		return nil, errors.New("Unable to retrieve symkey for layer")
+		return nil, errors.Wrapf(errdefs.ErrInvalidArgument, "Unable to retrieve symkey for layer %s", index)
 	}
 
 	md, err := ReadMessage(r, symKey, packet.CipherFunction(dc.LayerSymKeyMap[index].SymKeyCipher))
diff --git a/images/image.go b/images/image.go
index 1e34f2e..ab9035f 100644
--- a/images/image.go
+++ b/images/image.go
@@ -435,7 +435,7 @@ func IsCompressedDiff(ctx context.Context, mediaType string) (bool, error) {
 // encryptLayer encrypts the layer using the CryptoConfig and creates a new OCI Descriptor.
 // A call to this function may also only manipulate the wrapped keys list.
 // The caller is expected to store the returned encrypted data and OCI Descriptor
-func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocispec.Descriptor, []byte, error) {
+func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor, layerNum int32, platform *ocispec.Platform) (ocispec.Descriptor, []byte, error) {
 	var (
 		keys [][]byte
 		size int64
@@ -448,7 +448,7 @@ func encryptLayer(cc *CryptoConfig, data []byte, desc ocispec.Descriptor) (ocisp
 		return ocispec.Descriptor{}, []byte{}, err
 	}
 
-	p, keys, err := HandleEncrypt(cc.Ec, data, keys)
+	p, keys, err := HandleEncrypt(cc.Ec, data, keys, layerNum, platforms.Format(*platform))
 	if err != nil {
 		return ocispec.Descriptor{}, []byte{}, err
 	}
@@ -523,7 +523,7 @@ func cryptLayer(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	}
 
 	if encrypt {
-		newDesc, p, err = encryptLayer(cc, data, desc)
+		newDesc, p, err = encryptLayer(cc, data, desc, layerNum, platform)
 	} else {
 		newDesc, p, err = decryptLayer(cc, data, desc, layerNum, platform)
 	}
diff --git a/images/openpgp.go b/images/openpgp.go
index 16c9297..e470ce9 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -99,8 +99,45 @@ func encryptData(data []byte, recipients openpgp.EntityList, symKey []byte) (enc
 	return encBlob, wrappedKeys, nil
 }
 
-func addRecipientsToKeys(keys [][]byte, newRecipients openpgp.EntityList, keyIdMap map[string]DecryptKeyData) ([][]byte, error) {
-	return [][]byte{}, errors.Wrapf(errdefs.ErrNotImplemented, "Adding recipients is not supported\n")
+// createWrappedKeys creates wrapped key bytes
+func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
+	return addRecipientsToKeys([][]byte{}, recipients, symKey, config.DefaultCipher, config)
+}
+
+// addRecipientsToKeys adds wrapped keys to an existing list of wrapped keys by
+// encrypting the given symmetric key (symKey) with a public key of each one
+// of the recipients
+func addRecipientsToKeys(keys [][]byte, recipients openpgp.EntityList, symKey []byte, symKeyCipher packet.CipherFunction, config *packet.Config) ([][]byte, error) {
+	keyIds, err := WrappedKeysToKeyIds(keys)
+	if err != nil {
+		return nil, err
+	}
+
+	encKeys := keys
+
+	for _, et := range recipients {
+		pkey, canEncrypt := encryptionKey(et, time.Now())
+		if !canEncrypt {
+			return nil, errors.Wrapf(errdefs.ErrInvalidArgument, "key doesn't support encryption")
+		}
+		// already part of the wrapped keys ?
+		found := false
+		for _, v :=  range keyIds {
+			if v == pkey.PublicKey.KeyId {
+				found = true
+				break
+			}
+		}
+		if !found {
+			encKeyBuf := new(bytes.Buffer)
+			if err := packet.SerializeEncryptedKey(encKeyBuf, pkey.PublicKey, symKeyCipher, symKey, config); err != nil {
+				return nil, errors.Wrapf(err, "Error serializing encrypted key: %v", err)
+			}
+			encKeys = append(encKeys, encKeyBuf.Bytes())
+			keyIds = append(keyIds, pkey.PublicKey.KeyId)
+		}
+	}
+	return encKeys, nil
 }
 
 func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList) ([][]byte, error) {
@@ -123,31 +160,6 @@ func removeRecipientsFromKeys(keys [][]byte, removeRecipients openpgp.EntityList
 	return wrappedKeys, nil
 }
 
-// createWrappedKeys creates wrapped key bytes
-func createWrappedKeys(symKey []byte, recipients openpgp.EntityList, config *packet.Config) (wrappedKeys [][]byte, err error) {
-	// Array of serialized EncryptedKeys
-	encKeys := make([][]byte, 0, len(recipients))
-	encKeyBuf := new(bytes.Buffer)
-
-	for _, et := range recipients {
-		pkey, canEncrypt := encryptionKey(et, time.Now())
-		if !canEncrypt {
-			log.Printf("Error key doesn't support encryption")
-			return nil, fmt.Errorf("key doesn't support encryption")
-		}
-		if err := packet.SerializeEncryptedKey(encKeyBuf, pkey.PublicKey, config.DefaultCipher, symKey, config); err != nil {
-			return nil, fmt.Errorf("Error serializing encrypted key: %v", err)
-		}
-		encryptedKeyBytes := encKeyBuf.Bytes()
-		encKeys = append(encKeys, encryptedKeyBytes)
-		encKeyBuf = new(bytes.Buffer)
-	}
-
-	log.Printf("Encrypted keys' bytes: %x", encKeys)
-
-	return encKeys, nil
-}
-
 // createEncryptedBlob creates encrypted data blob bytes
 func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (encBlob []byte, err error) {
 	// Perform encryption
-- 
2.7.4


From 31a231c8dc2e1356bf637f266d6ba58e5abc4381 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 1 Aug 2018 07:31:01 -0400
Subject: [PATCH 55/79] Adding missing vendor.conf line for dependency

---
 vendor.conf | 1 +
 1 file changed, 1 insertion(+)

diff --git a/vendor.conf b/vendor.conf
index 094a1be..f079ef8 100644
--- a/vendor.conf
+++ b/vendor.conf
@@ -16,6 +16,7 @@ github.com/prometheus/common 89604d197083d4781071d3c65855d24ecfb0a563
 github.com/prometheus/procfs cb4147076ac75738c9a7d279075a253c0cc5acbd
 github.com/beorn7/perks 4c0e84591b9aa9e6dcfdf3e020114cd81f89d5f9
 github.com/matttproud/golang_protobuf_extensions v1.0.0
+github.com/mitchellh/go-homedir 3864e76763d94a6df2f9960b16a20a33da9f9a66
 github.com/gogo/protobuf v1.0.0
 github.com/gogo/googleapis 08a7655d27152912db7aaf4f983275eaf8d128ef
 github.com/golang/protobuf v1.1.0
-- 
2.7.4


From 53ea827304518c29945c5672283c944faf9e4186 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 1 Aug 2018 08:00:34 -0400
Subject: [PATCH 56/79] gpg.go: consolidate commont code into runGPGGetOutput

---
 images/gpg.go | 114 ++++++++++++----------------------------------------------
 1 file changed, 23 insertions(+), 91 deletions(-)

diff --git a/images/gpg.go b/images/gpg.go
index 2f64d87..52bed4c 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -90,23 +90,7 @@ func (gc *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte
 
 	cmd := exec.Command("gpg2", args...)
 
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2
+	return runGPGGetOutput(cmd)
 }
 
 // ReadGPGPubRingFile reads the GPG public key ring file
@@ -119,23 +103,7 @@ func (gc *gpgv2Client) ReadGPGPubRingFile() ([]byte, error) {
 
 	cmd := exec.Command("gpg2", args...)
 
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2
+	return runGPGGetOutput(cmd)
 }
 
 // GetSecretKeyDetails retrives the secret key details of key with keyid.
@@ -150,23 +118,8 @@ func (gc *gpgv2Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 
 	cmd := exec.Command("gpg2", args...)
 
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, false, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, false, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, false, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2 == nil, err2
+	keydata, err := runGPGGetOutput(cmd)
+	return keydata, err == nil, err
 }
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
@@ -179,23 +132,7 @@ func (gc *gpgv1Client) GetGPGPrivateKey(keyid uint64, _ string) ([]byte, error)
 
 	cmd := exec.Command("gpg", args...)
 
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2
+	return runGPGGetOutput(cmd)
 }
 
 // ReadGPGPubRingFile reads the GPG public key ring file
@@ -208,23 +145,7 @@ func (gc *gpgv1Client) ReadGPGPubRingFile() ([]byte, error) {
 
 	cmd := exec.Command("gpg", args...)
 
-	stdout, err := cmd.StdoutPipe()
-	stderr, err := cmd.StderrPipe()
-	if err != nil {
-		return nil, err
-	}
-	if err := cmd.Start(); err != nil {
-		return nil, err
-	}
-
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
-
-	if err := cmd.Wait(); err != nil {
-		return nil, fmt.Errorf("Error from gpg2: %s\n", message)
-	}
-
-	return keydata, err2
+	return runGPGGetOutput(cmd)
 }
 
 // GetSecretKeyDetails retrives the secret key details of key with keyid.
@@ -239,21 +160,32 @@ func (gc *gpgv1Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 
 	cmd := exec.Command("gpg", args...)
 
+	keydata, err := runGPGGetOutput(cmd)
+
+	return keydata, err == nil, err
+}
+
+// runGPGGetOutput runs the GPG commandline and returns stdout as byte array
+// and any stderr in the error
+func runGPGGetOutput(cmd *exec.Cmd) ([]byte, error){
 	stdout, err := cmd.StdoutPipe()
+	if err != nil {
+		return nil, err
+	}
 	stderr, err := cmd.StderrPipe()
 	if err != nil {
-		return nil, false, err
+		return nil, err
 	}
 	if err := cmd.Start(); err != nil {
-		return nil, false, err
+		return nil, err
 	}
 
-	keydata, err2 := ioutil.ReadAll(stdout)
-	message, _ := ioutil.ReadAll(stderr)
+	stdoutstr, err2 := ioutil.ReadAll(stdout)
+	stderrstr, _ := ioutil.ReadAll(stderr)
 
 	if err := cmd.Wait(); err != nil {
-		return nil, false, fmt.Errorf("Error from gpg2: %s", message)
+		return nil, fmt.Errorf("Error from %s: %s", cmd.Path, string(stderrstr))
 	}
 
-	return keydata, err2 == nil, err2
+	return stdoutstr, err2
 }
-- 
2.7.4


From 985a4872ce20b97d41615e3b89157fd4b8b0e29a Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 2 Aug 2018 10:02:25 -0400
Subject: [PATCH 57/79] Declare the args as a string array in all cases

---
 images/gpg.go | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/images/gpg.go b/images/gpg.go
index 52bed4c..60d64cb 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -81,7 +81,8 @@ func NewGPGClient(version *GPGVersion, homedir string) (GPGClient, error) {
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
 func (gc *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte, error) {
-	args := []string{}
+	var args []string
+
 	if gc.gpgHomeDir != "" {
 		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
 	}
@@ -95,7 +96,8 @@ func (gc *gpgv2Client) GetGPGPrivateKey(keyid uint64, passphrase string) ([]byte
 
 // ReadGPGPubRingFile reads the GPG public key ring file
 func (gc *gpgv2Client) ReadGPGPubRingFile() ([]byte, error) {
-	args := []string{}
+	var args []string
+
 	if gc.gpgHomeDir != "" {
 		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
 	}
@@ -124,7 +126,8 @@ func (gc *gpgv2Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 
 // GetGPGPrivateKey gets the bytes of a specified keyid, supplying a passphrase
 func (gc *gpgv1Client) GetGPGPrivateKey(keyid uint64, _ string) ([]byte, error) {
-	args := []string{}
+	var args []string
+
 	if gc.gpgHomeDir != "" {
 		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
 	}
@@ -137,7 +140,8 @@ func (gc *gpgv1Client) GetGPGPrivateKey(keyid uint64, _ string) ([]byte, error)
 
 // ReadGPGPubRingFile reads the GPG public key ring file
 func (gc *gpgv1Client) ReadGPGPubRingFile() ([]byte, error) {
-	args := []string{}
+	var args []string
+
 	if gc.gpgHomeDir != "" {
 		args = append(args, []string{"--homedir", gc.gpgHomeDir}...)
 	}
-- 
2.7.4


From fdece3e24cbeef4eadae7574e405f547ce4df66b Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Thu, 2 Aug 2018 10:04:46 -0400
Subject: [PATCH 58/79] We don't need the github.com/mitchellh/go-homedir
 dependency

---
 vendor.conf                                 |   1 -
 vendor/mitchellh/go-homedir/LICENSE         |  21 ----
 vendor/mitchellh/go-homedir/README.md       |  14 ---
 vendor/mitchellh/go-homedir/homedir.go      | 155 ----------------------------
 vendor/mitchellh/go-homedir/homedir_test.go | 129 -----------------------
 5 files changed, 320 deletions(-)
 delete mode 100644 vendor/mitchellh/go-homedir/LICENSE
 delete mode 100644 vendor/mitchellh/go-homedir/README.md
 delete mode 100644 vendor/mitchellh/go-homedir/homedir.go
 delete mode 100644 vendor/mitchellh/go-homedir/homedir_test.go

diff --git a/vendor.conf b/vendor.conf
index f079ef8..094a1be 100644
--- a/vendor.conf
+++ b/vendor.conf
@@ -16,7 +16,6 @@ github.com/prometheus/common 89604d197083d4781071d3c65855d24ecfb0a563
 github.com/prometheus/procfs cb4147076ac75738c9a7d279075a253c0cc5acbd
 github.com/beorn7/perks 4c0e84591b9aa9e6dcfdf3e020114cd81f89d5f9
 github.com/matttproud/golang_protobuf_extensions v1.0.0
-github.com/mitchellh/go-homedir 3864e76763d94a6df2f9960b16a20a33da9f9a66
 github.com/gogo/protobuf v1.0.0
 github.com/gogo/googleapis 08a7655d27152912db7aaf4f983275eaf8d128ef
 github.com/golang/protobuf v1.1.0
diff --git a/vendor/mitchellh/go-homedir/LICENSE b/vendor/mitchellh/go-homedir/LICENSE
deleted file mode 100644
index f9c841a..0000000
--- a/vendor/mitchellh/go-homedir/LICENSE
+++ /dev/null
@@ -1,21 +0,0 @@
-The MIT License (MIT)
-
-Copyright (c) 2013 Mitchell Hashimoto
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
diff --git a/vendor/mitchellh/go-homedir/README.md b/vendor/mitchellh/go-homedir/README.md
deleted file mode 100644
index d70706d..0000000
--- a/vendor/mitchellh/go-homedir/README.md
+++ /dev/null
@@ -1,14 +0,0 @@
-# go-homedir
-
-This is a Go library for detecting the user's home directory without
-the use of cgo, so the library can be used in cross-compilation environments.
-
-Usage is incredibly simple, just call `homedir.Dir()` to get the home directory
-for a user, and `homedir.Expand()` to expand the `~` in a path to the home
-directory.
-
-**Why not just use `os/user`?** The built-in `os/user` package requires
-cgo on Darwin systems. This means that any Go code that uses that package
-cannot cross compile. But 99% of the time the use for `os/user` is just to
-retrieve the home directory, which we can do for the current user without
-cgo. This library does that, enabling cross-compilation.
diff --git a/vendor/mitchellh/go-homedir/homedir.go b/vendor/mitchellh/go-homedir/homedir.go
deleted file mode 100644
index acbb605..0000000
--- a/vendor/mitchellh/go-homedir/homedir.go
+++ /dev/null
@@ -1,155 +0,0 @@
-package homedir
-
-import (
-	"bytes"
-	"errors"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"runtime"
-	"strconv"
-	"strings"
-	"sync"
-)
-
-// DisableCache will disable caching of the home directory. Caching is enabled
-// by default.
-var DisableCache bool
-
-var homedirCache string
-var cacheLock sync.RWMutex
-
-// Dir returns the home directory for the executing user.
-//
-// This uses an OS-specific method for discovering the home directory.
-// An error is returned if a home directory cannot be detected.
-func Dir() (string, error) {
-	if !DisableCache {
-		cacheLock.RLock()
-		cached := homedirCache
-		cacheLock.RUnlock()
-		if cached != "" {
-			return cached, nil
-		}
-	}
-
-	cacheLock.Lock()
-	defer cacheLock.Unlock()
-
-	var result string
-	var err error
-	if runtime.GOOS == "windows" {
-		result, err = dirWindows()
-	} else {
-		// Unix-like system, so just assume Unix
-		result, err = dirUnix()
-	}
-
-	if err != nil {
-		return "", err
-	}
-	homedirCache = result
-	return result, nil
-}
-
-// Expand expands the path to include the home directory if the path
-// is prefixed with `~`. If it isn't prefixed with `~`, the path is
-// returned as-is.
-func Expand(path string) (string, error) {
-	if len(path) == 0 {
-		return path, nil
-	}
-
-	if path[0] != '~' {
-		return path, nil
-	}
-
-	if len(path) > 1 && path[1] != '/' && path[1] != '\\' {
-		return "", errors.New("cannot expand user-specific home dir")
-	}
-
-	dir, err := Dir()
-	if err != nil {
-		return "", err
-	}
-
-	return filepath.Join(dir, path[1:]), nil
-}
-
-func dirUnix() (string, error) {
-	homeEnv := "HOME"
-	if runtime.GOOS == "plan9" {
-		// On plan9, env vars are lowercase.
-		homeEnv = "home"
-	}
-
-	// First prefer the HOME environmental variable
-	if home := os.Getenv(homeEnv); home != "" {
-		return home, nil
-	}
-
-	var stdout bytes.Buffer
-
-	// If that fails, try OS specific commands
-	if runtime.GOOS == "darwin" {
-		cmd := exec.Command("sh", "-c", `dscl -q . -read /Users/"$(whoami)" NFSHomeDirectory | sed 's/^[^ ]*: //'`)
-		cmd.Stdout = &stdout
-		if err := cmd.Run(); err == nil {
-			result := strings.TrimSpace(stdout.String())
-			if result != "" {
-				return result, nil
-			}
-		}
-	} else {
-		cmd := exec.Command("getent", "passwd", strconv.Itoa(os.Getuid()))
-		cmd.Stdout = &stdout
-		if err := cmd.Run(); err != nil {
-			// If the error is ErrNotFound, we ignore it. Otherwise, return it.
-			if err != exec.ErrNotFound {
-				return "", err
-			}
-		} else {
-			if passwd := strings.TrimSpace(stdout.String()); passwd != "" {
-				// username:password:uid:gid:gecos:home:shell
-				passwdParts := strings.SplitN(passwd, ":", 7)
-				if len(passwdParts) > 5 {
-					return passwdParts[5], nil
-				}
-			}
-		}
-	}
-
-	// If all else fails, try the shell
-	stdout.Reset()
-	cmd := exec.Command("sh", "-c", "cd && pwd")
-	cmd.Stdout = &stdout
-	if err := cmd.Run(); err != nil {
-		return "", err
-	}
-
-	result := strings.TrimSpace(stdout.String())
-	if result == "" {
-		return "", errors.New("blank output when reading home directory")
-	}
-
-	return result, nil
-}
-
-func dirWindows() (string, error) {
-	// First prefer the HOME environmental variable
-	if home := os.Getenv("HOME"); home != "" {
-		return home, nil
-	}
-
-	drive := os.Getenv("HOMEDRIVE")
-	path := os.Getenv("HOMEPATH")
-	home := drive + path
-	if drive == "" || path == "" {
-		home = os.Getenv("USERPROFILE")
-	}
-	if home == "" {
-		return "", errors.New("HOMEDRIVE, HOMEPATH, and USERPROFILE are blank")
-	}
-
-	return home, nil
-}
diff --git a/vendor/mitchellh/go-homedir/homedir_test.go b/vendor/mitchellh/go-homedir/homedir_test.go
deleted file mode 100644
index cd52127..0000000
--- a/vendor/mitchellh/go-homedir/homedir_test.go
+++ /dev/null
@@ -1,129 +0,0 @@
-package homedir
-
-import (
-	"os"
-	"os/user"
-	"path/filepath"
-	"testing"
-)
-
-func patchEnv(key, value string) func() {
-	bck := os.Getenv(key)
-	deferFunc := func() {
-		os.Setenv(key, bck)
-	}
-
-	if value != "" {
-		os.Setenv(key, value)
-	} else {
-		os.Unsetenv(key)
-	}
-
-	return deferFunc
-}
-
-func BenchmarkDir(b *testing.B) {
-	// We do this for any "warmups"
-	for i := 0; i < 10; i++ {
-		Dir()
-	}
-
-	b.ResetTimer()
-	for i := 0; i < b.N; i++ {
-		Dir()
-	}
-}
-
-func TestDir(t *testing.T) {
-	u, err := user.Current()
-	if err != nil {
-		t.Fatalf("err: %s", err)
-	}
-
-	dir, err := Dir()
-	if err != nil {
-		t.Fatalf("err: %s", err)
-	}
-
-	if u.HomeDir != dir {
-		t.Fatalf("%#v != %#v", u.HomeDir, dir)
-	}
-
-	DisableCache = true
-	defer func() { DisableCache = false }()
-	defer patchEnv("HOME", "")()
-	dir, err = Dir()
-	if err != nil {
-		t.Fatalf("err: %s", err)
-	}
-
-	if u.HomeDir != dir {
-		t.Fatalf("%#v != %#v", u.HomeDir, dir)
-	}
-}
-
-func TestExpand(t *testing.T) {
-	u, err := user.Current()
-	if err != nil {
-		t.Fatalf("err: %s", err)
-	}
-
-	cases := []struct {
-		Input  string
-		Output string
-		Err    bool
-	}{
-		{
-			"/foo",
-			"/foo",
-			false,
-		},
-
-		{
-			"~/foo",
-			filepath.Join(u.HomeDir, "foo"),
-			false,
-		},
-
-		{
-			"",
-			"",
-			false,
-		},
-
-		{
-			"~",
-			u.HomeDir,
-			false,
-		},
-
-		{
-			"~foo/foo",
-			"",
-			true,
-		},
-	}
-
-	for _, tc := range cases {
-		actual, err := Expand(tc.Input)
-		if (err != nil) != tc.Err {
-			t.Fatalf("Input: %#v\n\nErr: %s", tc.Input, err)
-		}
-
-		if actual != tc.Output {
-			t.Fatalf("Input: %#v\n\nOutput: %#v", tc.Input, actual)
-		}
-	}
-
-	DisableCache = true
-	defer func() { DisableCache = false }()
-	defer patchEnv("HOME", "/custom/path/")()
-	expected := filepath.Join("/", "custom", "path", "foo/bar")
-	actual, err := Expand("~/foo/bar")
-
-	if err != nil {
-		t.Errorf("No error is expected, got: %v", err)
-	} else if actual != expected {
-		t.Errorf("Expected: %v; actual: %v", expected, actual)
-	}
-}
-- 
2.7.4


From a88db440248e769e9513b9468242841d1053bcc5 Mon Sep 17 00:00:00 2001
From: Brandon Lum <lumjjb@gmail.com>
Date: Fri, 3 Aug 2018 13:59:00 -0400
Subject: [PATCH 59/79] Added quick fix for mediatype expectation from Docker
 Registry

Signed-off-by: Brandon Lum <lumjjb@gmail.com>
---
 images/image.go | 40 ++++++++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 8 deletions(-)

diff --git a/images/image.go b/images/image.go
index ab9035f..58fc984 100644
--- a/images/image.go
+++ b/images/image.go
@@ -701,12 +701,23 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	}
 
 	if modified && len(newLayers) > 0 {
-		newManifest := ocispec.Manifest{
-			Versioned: specs.Versioned{
-				SchemaVersion: 2,
+		// TODO: Hack to work with docker registry since it still expects the mediatype for manifest
+		// REF: https://github.com/moby/buildkit/blob/master/exporter/containerimage/writer.go#L83-L100
+		newManifest := struct {
+			// MediaType is reserved in the OCI spec but
+			// excluded from go types.
+			MediaType string `json:"mediaType,omitempty"`
+
+			ocispec.Manifest
+		}{
+			MediaType: MediaTypeDockerSchema2Manifest,
+			Manifest: ocispec.Manifest{
+				Versioned: specs.Versioned{
+					SchemaVersion: 2,
+				},
+				Config: config,
+				Layers: newLayers,
 			},
-			Config: config,
-			Layers: newLayers,
 		}
 
 		mb, err := json.MarshalIndent(newManifest, "", "   ")
@@ -768,10 +779,23 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 
 	if modified {
 		// we need to update the index
-		newIndex := ocispec.Index{
-			Versioned: index.Versioned,
-			Manifests: newManifests,
+
+		// TODO: Hack to work with docker registry since it still expects the mediatype for index
+		// REF: https://github.com/moby/buildkit/blob/master/exporter/containerimage/writer.go#L83-L100
+		newIndex := struct {
+			// MediaType is reserved in the OCI spec but
+			// excluded from go types.
+			MediaType string `json:"mediaType,omitempty"`
+
+			ocispec.Index
+		}{
+			MediaType: MediaTypeDockerSchema2ManifestList,
+			Index: ocispec.Index{
+				Versioned: index.Versioned,
+				Manifests: newManifests,
+			},
 		}
+
 		mb, err := json.MarshalIndent(newIndex, "", "   ")
 		if err != nil {
 			return ocispec.Descriptor{}, false, errors.Wrap(err, "failed to marshal index")
-- 
2.7.4


From 402a8abd4c1a3f4b5f992f796ff0854ca38808d5 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Sat, 4 Aug 2018 09:50:47 -0400
Subject: [PATCH 60/79] Allow layerinfo to work even if not all platforms'
 layers have been pulled

---
 images/image.go | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/images/image.go b/images/image.go
index 58fc984..87dcd5e 100644
--- a/images/image.go
+++ b/images/image.go
@@ -843,6 +843,9 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			platform = platforms.Format(*desc.Platform)
 		}
 		if err != nil {
+			if errdefs.IsNotFound(err) {
+				return[]LayerInfo{}, nil
+			}
 			return []LayerInfo{}, err
 		}
 
-- 
2.7.4


From e6778cdd03249baddda0ff2204e8a614b3192504 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Sat, 4 Aug 2018 12:22:10 -0400
Subject: [PATCH 61/79] remove debugging noise

---
 images/openpgp.go | 2 --
 1 file changed, 2 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index e470ce9..883b43a 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -52,7 +52,6 @@ import (
 	"bytes"
 	"fmt"
 	"io"
-	"log"
 	"time"
 
 	"crypto"
@@ -183,7 +182,6 @@ func createEncryptedBlob(data []byte, symKey []byte, config *packet.Config) (enc
 	}
 
 	encBlob = encData.Bytes()
-	log.Printf("Encrypted data bytes: %x", encBlob)
 
 	return encBlob, nil
 }
-- 
2.7.4


From 22b64c1509515c26e5b03fe7e8dc10a9cbc2e11a Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Sat, 4 Aug 2018 12:22:36 -0400
Subject: [PATCH 62/79] Allow encryption of image for which not all layers have
 been pulled

---
 images/image.go | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/images/image.go b/images/image.go
index 87dcd5e..7d29f1b 100644
--- a/images/image.go
+++ b/images/image.go
@@ -656,6 +656,9 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 
 	children, err := Children(ctx, cs, desc)
 	if err != nil {
+		if errdefs.IsNotFound(err) {
+			return desc, false, nil
+		}
 		return ocispec.Descriptor{}, false, err
 	}
 
-- 
2.7.4


From 0dd490a8e6371998c660c4824fef947931c421d6 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Mon, 6 Aug 2018 17:01:51 -0400
Subject: [PATCH 63/79] Enable encryption if top level is a manifest type of
 JSON document

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 images/image.go    | 54 +++++++++++++++++++++++++++++++++++++++++-------------
 metadata/images.go |  2 +-
 2 files changed, 42 insertions(+), 14 deletions(-)

diff --git a/images/image.go b/images/image.go
index 7d29f1b..ae14c8e 100644
--- a/images/image.go
+++ b/images/image.go
@@ -671,7 +671,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	for _, child := range children {
 		// we only encrypt child layers and have to update their parents if encyrption happened
 		switch child.MediaType {
-		case MediaTypeDockerSchema2Config:
+		case MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig:
 			config = child
 		case MediaTypeDockerSchema2LayerGzip, MediaTypeDockerSchema2Layer:
 			if encrypt && isUserSelectedLayer(layerNum, layersTotal, lf.Layers) && isUserSelectedPlatform(thisPlatform, lf.Platforms) {
@@ -751,11 +751,26 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	return desc, modified, nil
 }
 
-// cryptManifestList encrypts or decrypts the children of a top level manifest list
-func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
-	if desc.MediaType != MediaTypeDockerSchema2ManifestList {
-		return ocispec.Descriptor{}, false, errors.Wrapf(nil, "Wrong media type %s passed. Need %s.\n", desc.MediaType, MediaTypeDockerSchema2ManifestList)
+// cryptManifest encrypt or decrypt the children of a top level manifest
+func cryptManifest(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
+	p, err := content.ReadBlob(ctx, cs, desc)
+	if err != nil {
+		return ocispec.Descriptor{}, false, err
+	}
+	var manifest ocispec.Manifest
+	if err := json.Unmarshal(p, &manifest); err != nil {
+		return ocispec.Descriptor{}, false, err
 	}
+	platform := platforms.DefaultSpec()
+	newDesc, modified, err := cryptChildren(ctx, cs, desc, cc, lf, encrypt, &platform)
+	if err != nil {
+		return ocispec.Descriptor{}, false, err
+	}
+	return newDesc, modified, nil
+}
+
+// cryptManifestList encrypts or decrypts the children of a top level manifest list
+func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
 	// read the index; if any layer is encrypted and any manifests change we will need to rewrite it
 	b, err := content.ReadBlob(ctx, cs, desc)
 	if err != nil {
@@ -825,14 +840,30 @@ func CryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	return desc, false, nil
 }
 
+func CryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
+	switch desc.MediaType {
+	case MediaTypeDockerSchema2ManifestList:
+		return cryptManifestList(ctx, cs, desc, cc, lf, encrypt)
+	case ocispec.MediaTypeImageManifest, MediaTypeDockerSchema2Manifest:
+		return cryptManifest(ctx, cs, desc, cc, lf, encrypt)
+	default:
+		return ocispec.Descriptor{}, false, errors.Wrapf(errdefs.ErrInvalidArgument, "CryptImage: Unhandled media type: %s", desc.MediaType)
+	}
+}
+
 // Get the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
 func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32) ([]LayerInfo, error) {
+	return getImageLayerInfo(ctx, cs, desc, lf, layerNum, platforms.Default())
+}
+
+// the recursive version of GetImageLayerInfo that takes the default platform
+// as additional parameter
+func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32, platform string) ([]LayerInfo, error) {
 	var (
 		lis      []LayerInfo
 		tmp      []LayerInfo
-		platform string
 	)
 
 	switch desc.MediaType {
@@ -859,7 +890,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			if isDescriptorALayer(child) {
 				layerNum = layerNum + 1
 				if isUserSelectedLayer(layerNum, layersTotal, lf.Layers) {
-					tmp, err = GetImageLayerInfo(ctx, cs, child, lf, layerNum)
+					tmp, err = getImageLayerInfo(ctx, cs, child, lf, layerNum, platform)
 				} else {
 					continue
 				}
@@ -870,11 +901,6 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 				return []LayerInfo{}, err
 			}
 
-			if platform != "" {
-				for i := 0; i < len(tmp); i++ {
-					tmp[i].Platform = platform
-				}
-			}
 			lis = append(lis, tmp...)
 		}
 	case MediaTypeDockerSchema2Layer, MediaTypeDockerSchema2LayerGzip:
@@ -884,9 +910,10 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Encryption:  "",
 			FileSize:    desc.Size,
 			Id:          uint32(layerNum),
+			Platform:    platform,
 		}
 		lis = append(lis, li)
-	case MediaTypeDockerSchema2Config:
+	case MediaTypeDockerSchema2Config, ocispec.MediaTypeImageConfig:
 	case MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP:
 		wrappedKeys, err := getWrappedKeys(desc)
 		if err != nil {
@@ -898,6 +925,7 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Encryption:  "pgp",
 			FileSize:    desc.Size,
 			Id:          uint32(layerNum),
+			Platform:    platform,
 		}
 		lis = append(lis, li)
 	default:
diff --git a/metadata/images.go b/metadata/images.go
index 899fad1..ce2b2c9 100644
--- a/metadata/images.go
+++ b/metadata/images.go
@@ -298,7 +298,7 @@ func (s *imageStore) cryptImage(ctx context.Context, name, newName string, cc *i
 		Platforms: pl,
 	}
 
-	newSpec, modified, err := images.CryptManifestList(ctx, s.db.ContentStore(), image.Target, cc, lf, encrypt)
+	newSpec, modified, err := images.CryptImage(ctx, s.db.ContentStore(), image.Target, cc, lf, encrypt)
 	if err != nil {
 		return image, err
 	}
-- 
2.7.4


From c20688c31b5f5a9ff4b687a0a45cbcdabe5dc143 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 12:28:30 -0400
Subject: [PATCH 64/79] Partially remove the hacks

---
 images/image.go | 29 +++++++++--------------------
 1 file changed, 9 insertions(+), 20 deletions(-)

diff --git a/images/image.go b/images/image.go
index ae14c8e..47e3f96 100644
--- a/images/image.go
+++ b/images/image.go
@@ -704,23 +704,12 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 	}
 
 	if modified && len(newLayers) > 0 {
-		// TODO: Hack to work with docker registry since it still expects the mediatype for manifest
-		// REF: https://github.com/moby/buildkit/blob/master/exporter/containerimage/writer.go#L83-L100
-		newManifest := struct {
-			// MediaType is reserved in the OCI spec but
-			// excluded from go types.
-			MediaType string `json:"mediaType,omitempty"`
-
-			ocispec.Manifest
-		}{
-			MediaType: MediaTypeDockerSchema2Manifest,
-			Manifest: ocispec.Manifest{
-				Versioned: specs.Versioned{
-					SchemaVersion: 2,
-				},
-				Config: config,
-				Layers: newLayers,
+		newManifest := ocispec.Manifest{
+			Versioned: specs.Versioned{
+				SchemaVersion: 2,
 			},
+			Config: config,
+			Layers: newLayers,
 		}
 
 		mb, err := json.MarshalIndent(newManifest, "", "   ")
@@ -729,7 +718,7 @@ func cryptChildren(ctx context.Context, cs content.Store, desc ocispec.Descripto
 		}
 
 		newDesc := ocispec.Descriptor{
-			MediaType: MediaTypeDockerSchema2Manifest,
+			MediaType: ocispec.MediaTypeImageManifest,
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
 			Platform:  desc.Platform,
@@ -862,8 +851,8 @@ func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 // as additional parameter
 func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32, platform string) ([]LayerInfo, error) {
 	var (
-		lis      []LayerInfo
-		tmp      []LayerInfo
+		lis []LayerInfo
+		tmp []LayerInfo
 	)
 
 	switch desc.MediaType {
@@ -878,7 +867,7 @@ func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 		if err != nil {
 			if errdefs.IsNotFound(err) {
-				return[]LayerInfo{}, nil
+				return []LayerInfo{}, nil
 			}
 			return []LayerInfo{}, err
 		}
-- 
2.7.4


From 0fb086a9c0efbaf8269878df5ed401d907de8665 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 12:56:06 -0400
Subject: [PATCH 65/79] remove display of Symkey

---
 images/openpgp.go | 2 --
 1 file changed, 2 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 883b43a..47b7286 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -395,8 +395,6 @@ ParsePackets:
 		return nil, errors.Wrapf(errdefs.ErrNotFound, "No symmetrically encrypted data found.")
 	}
 
-	fmt.Printf("Symkey :%v", symKey)
-
 	decrypted, err := se.Decrypt(symKeyCipher, symKey)
 	if err != nil {
 		return nil, errors.Wrapf(err, "Decrypting layer with symmetric key failed")
-- 
2.7.4


From 494aa07d7b307cbf05731ebf69d0094272a6494c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 15:17:18 -0400
Subject: [PATCH 66/79] Fixes for images/gpg.go

---
 images/gpg.go | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/images/gpg.go b/images/gpg.go
index 60d64cb..9c90067 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -12,13 +12,13 @@ type GPGVersion int
 const (
 	// GPGv2 signifies gpgv2+
 	GPGv2 GPGVersion = iota
-	// GPGv2 signifies gpgv1+
+	// GPGv1 signifies gpgv1+
 	GPGv1
 	// GPGVersionUndetermined signifies gpg client version undetermined
 	GPGVersionUndetermined
 )
 
-// GPG
+// GPGClient defines an interface for wrapping the gpg command line tools
 type GPGClient interface {
 	// ReadGPGPubRingFile gets the byte sequence of the gpg public keyring
 	ReadGPGPubRingFile() ([]byte, error)
@@ -55,6 +55,8 @@ func GuessGPGVersion() GPGVersion {
 	}
 }
 
+// NewGPGClient creates a new GPGClient object representing the given version
+// and using the given home directory
 func NewGPGClient(version *GPGVersion, homedir string) (GPGClient, error) {
 	var gpgVersion GPGVersion
 	if version != nil {
@@ -171,7 +173,7 @@ func (gc *gpgv1Client) GetSecretKeyDetails(keyid uint64) ([]byte, bool, error) {
 
 // runGPGGetOutput runs the GPG commandline and returns stdout as byte array
 // and any stderr in the error
-func runGPGGetOutput(cmd *exec.Cmd) ([]byte, error){
+func runGPGGetOutput(cmd *exec.Cmd) ([]byte, error) {
 	stdout, err := cmd.StdoutPipe()
 	if err != nil {
 		return nil, err
-- 
2.7.4


From 9876dd6982b3aac5080b7fe9cd71f7e408f7e631 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 15:14:20 -0400
Subject: [PATCH 67/79] Fixes for OpenPGP extensions

---
 images/openpgp.go | 33 +--------------------------------
 1 file changed, 1 insertion(+), 32 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 47b7286..98e7774 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -121,7 +121,7 @@ func addRecipientsToKeys(keys [][]byte, recipients openpgp.EntityList, symKey []
 		}
 		// already part of the wrapped keys ?
 		found := false
-		for _, v :=  range keyIds {
+		for _, v := range keyIds {
 			if v == pkey.PublicKey.KeyId {
 				found = true
 				break
@@ -226,37 +226,6 @@ func encryptionKey(e *openpgp.Entity, now time.Time) (openpgp.Key, bool) {
 	return openpgp.Key{}, false
 }
 
-// signingKey return the best candidate Key for signing a message with this
-// Entity.
-func signingKey(e *openpgp.Entity, now time.Time) (openpgp.Key, bool) {
-	candidateSubkey := -1
-
-	for i, subkey := range e.Subkeys {
-		if subkey.Sig.FlagsValid &&
-			subkey.Sig.FlagSign &&
-			subkey.PublicKey.PubKeyAlgo.CanSign() &&
-			!subkey.Sig.KeyExpired(now) {
-			candidateSubkey = i
-			break
-		}
-	}
-
-	if candidateSubkey != -1 {
-		subkey := e.Subkeys[candidateSubkey]
-		return openpgp.Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true
-	}
-
-	// If we have no candidate subkey then we assume that it's ok to sign
-	// with the primary key.
-	i := primaryIdentity(e)
-	if !i.SelfSignature.FlagsValid || i.SelfSignature.FlagSign &&
-		!i.SelfSignature.KeyExpired(now) {
-		return openpgp.Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true
-	}
-
-	return openpgp.Key{}, false
-}
-
 // primaryIdentity returns the Identity marked as primary or the first identity
 // if none are so marked.
 func primaryIdentity(e *openpgp.Entity) *openpgp.Identity {
-- 
2.7.4


From b8b13276b3289f672ff24a8448e5c0c2d6acb071 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 15:29:33 -0400
Subject: [PATCH 68/79] Fixes for the container implementation

---
 image_store.go           |  2 +-
 images/encryption.go     | 10 ++++++----
 images/image.go          | 23 +++++++++++++----------
 services/images/local.go |  2 +-
 4 files changed, 21 insertions(+), 16 deletions(-)

diff --git a/image_store.go b/image_store.go
index 4da4487..9fae308 100644
--- a/image_store.go
+++ b/image_store.go
@@ -180,7 +180,7 @@ func (s *remoteImages) GetImageLayerInfo(ctx context.Context, name string, layer
 
 	li := make([]images.LayerInfo, len(resp.LayerInfo))
 	for i := 0; i < len(resp.LayerInfo); i++ {
-		li[i].Id = resp.LayerInfo[i].ID
+		li[i].ID = resp.LayerInfo[i].ID
 		li[i].WrappedKeys = resp.LayerInfo[i].WrappedKeys
 		li[i].Digest = resp.LayerInfo[i].Digest
 		li[i].Encryption = resp.LayerInfo[i].Encryption
diff --git a/images/encryption.go b/images/encryption.go
index e54f810..de6abfc 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -44,8 +44,10 @@ type EncryptConfig struct {
 }
 
 const (
-	OPERATION_ADD_RECIPIENTS    = int32(iota)
-	OPERATION_REMOVE_RECIPIENTS = int32(iota)
+	// OperationAddRecipients instructs to add a recipient
+	OperationAddRecipients    = int32(iota)
+	// OperationRemoveRecipients instructs to remove a recipient
+	OperationRemoveRecipients = int32(iota)
 )
 
 // DecryptKeyData stores private key data for decryption and the necessary password
@@ -141,7 +143,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte, layerNum int32
 	}
 
 	switch ec.Operation {
-	case OPERATION_ADD_RECIPIENTS:
+	case OperationAddRecipients:
 		if len(keys) > 0 {
 			index := fmt.Sprintf("%s:%d", platform, layerNum)
 			symKey := ec.Dc.LayerSymKeyMap[index].SymKeyData
@@ -153,7 +155,7 @@ func HandleEncrypt(ec *EncryptConfig, data []byte, keys [][]byte, layerNum int32
 		} else {
 			encBlob, wrappedKeys, err = encryptData(data, filteredList, nil)
 		}
-	case OPERATION_REMOVE_RECIPIENTS:
+	case OperationRemoveRecipients:
 		wrappedKeys, err = removeRecipientsFromKeys(keys, filteredList)
 		// encBlob stays empty to indicate it wasn't touched
 	}
diff --git a/images/image.go b/images/image.go
index 47e3f96..86096d7 100644
--- a/images/image.go
+++ b/images/image.go
@@ -60,9 +60,10 @@ type Image struct {
 	CreatedAt, UpdatedAt time.Time
 }
 
+// LayerInfo holds information about an image layer
 type LayerInfo struct {
 	// The Id of the layer starting at 0
-	Id uint32
+	ID uint32
 	// Array of wrapped keys from which KeyIds can be derived
 	WrappedKeys [][]byte
 	// The Digest of the layer
@@ -75,6 +76,7 @@ type LayerInfo struct {
 	Platform string
 }
 
+// LayerFilter holds criteria for which layer to select
 type LayerFilter struct {
 	// IDs of layers to touch; may be negative number to start from topmost layer
 	// empty array means 'all layers'
@@ -546,9 +548,8 @@ func getWrappedKeys(desc ocispec.Descriptor) ([][]byte, error) {
 			return nil, err
 		}
 		return keys, nil
-	} else {
-		return make([][]byte, 0), nil
 	}
+	return make([][]byte, 0), nil
 }
 
 // assembleEncryptedMessage takes in the openpgp encrypted body packets and
@@ -579,10 +580,10 @@ func encodeWrappedKeys(keys [][]byte) string {
 // decodeWrappedKeys decodes wrapped openpgp keys from string readable ','
 // separated base64 strings to their byte values
 func decodeWrappedKeys(keys string) ([][]byte, error) {
-	kSplit := strings.Split(keys, ",")
-	keyBytes := make([][]byte, 0, len(kSplit))
+	keySplit := strings.Split(keys, ",")
+	keyBytes := make([][]byte, 0, len(keySplit))
 
-	for _, v := range kSplit {
+	for _, v := range keySplit {
 		data, err := base64.StdEncoding.DecodeString(v)
 		if err != nil {
 			return nil, err
@@ -829,6 +830,8 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	return desc, false, nil
 }
 
+// CryptImage is the dispatcher to encrypt/decrypt an image; it accepts either an OCI descriptor
+// representing a manifest list or a single manifest
 func CryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor, cc *CryptoConfig, lf *LayerFilter, encrypt bool) (ocispec.Descriptor, bool, error) {
 	switch desc.MediaType {
 	case MediaTypeDockerSchema2ManifestList:
@@ -840,14 +843,14 @@ func CryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 	}
 }
 
-// Get the image key Ids necessary for decrypting an image
+// GetImageLayerInfo gets the image key Ids necessary for decrypting an image
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
 func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32) ([]LayerInfo, error) {
 	return getImageLayerInfo(ctx, cs, desc, lf, layerNum, platforms.Default())
 }
 
-// the recursive version of GetImageLayerInfo that takes the default platform
+// getImageLayerInfo is the recursive version of GetImageLayerInfo that takes the platform
 // as additional parameter
 func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32, platform string) ([]LayerInfo, error) {
 	var (
@@ -898,7 +901,7 @@ func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Digest:      desc.Digest.String(),
 			Encryption:  "",
 			FileSize:    desc.Size,
-			Id:          uint32(layerNum),
+			ID:          uint32(layerNum),
 			Platform:    platform,
 		}
 		lis = append(lis, li)
@@ -913,7 +916,7 @@ func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 			Digest:      desc.Digest.String(),
 			Encryption:  "pgp",
 			FileSize:    desc.Size,
-			Id:          uint32(layerNum),
+			ID:          uint32(layerNum),
 			Platform:    platform,
 		}
 		lis = append(lis, li)
diff --git a/services/images/local.go b/services/images/local.go
index efe7bb8..867145f 100644
--- a/services/images/local.go
+++ b/services/images/local.go
@@ -254,7 +254,7 @@ func (l *local) GetImageLayerInfo(ctx context.Context, req *imagesapi.GetImageLa
 	resp.LayerInfo = make([]*imagesapi.LayerInfo, len(lis))
 	for i := 0; i < len(lis); i++ {
 		resp.LayerInfo[i] = &imagesapi.LayerInfo{
-			ID:          lis[i].Id,
+			ID:          lis[i].ID,
 			WrappedKeys: lis[i].WrappedKeys,
 			Digest:      lis[i].Digest,
 			Encryption:  lis[i].Encryption,
-- 
2.7.4


From 57f9ad3570f9ca346335294fd7d91f57c9dbe9a6 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 15:12:54 -0400
Subject: [PATCH 69/79] Fixes for the client tool

---
 cmd/ctr/commands/images/decrypt.go   | 32 ++++++++------------------------
 cmd/ctr/commands/images/encrypt.go   |  6 +++---
 cmd/ctr/commands/images/layerinfo.go |  2 +-
 cmd/ctr/commands/utils.go            |  3 +++
 4 files changed, 15 insertions(+), 28 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 6da0d58..39a1c73 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -123,22 +123,6 @@ var decryptCommand = cli.Command{
 	},
 }
 
-func addToSet(set, add []uint64) []uint64 {
-	for i := 0; i < len(add); i++ {
-		found := false
-		for j := 0; j < len(set); j++ {
-			if set[j] == add[i] {
-				found = true
-				break
-			}
-		}
-		if !found {
-			set = append(set, add[i])
-		}
-	}
-	return set
-}
-
 // getSymmetricKeys walks the list of layerInfos and tries to decrypt the
 // wrapped symmetric keys. For this it determines which private keys are on
 // this system and prompts for the passwords for those that are available.
@@ -153,7 +137,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 		KeyDataPassword []byte
 	}
 	var pkd PrivKeyData
-	keyIdPasswordMap := make(map[uint64]PrivKeyData)
+	keyIDPasswordMap := make(map[uint64]PrivKeyData)
 	layerSymkeyMap := make(map[string]images.DecryptKeyData)
 
 	// we need to decrypt one symmetric key per encrypted layer per platform
@@ -167,7 +151,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 		found := false
 		for _, keyid := range keyIds {
 			// do we have this key?
-			keyinfo, haveKey, err := gpgClient.GetSecretKeyDetails(keyid)
+			keyinfo, haveKey, _ := gpgClient.GetSecretKeyDetails(keyid)
 			// this may fail if the key is not here; we ignore the error
 			if !haveKey {
 				// key not on this system
@@ -175,11 +159,11 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 			}
 
 			var ok bool
-			if pkd, ok = keyIdPasswordMap[keyid]; !ok {
+			if pkd, ok = keyIDPasswordMap[keyid]; !ok {
 				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
 				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
 
-				password, err := terminal.ReadPassword(int(syscall.Stdin))
+				password, err := terminal.ReadPassword(syscall.Stdin)
 				fmt.Printf("\n")
 				if err != nil {
 					return layerSymkeyMap, err
@@ -192,7 +176,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 					KeyData:         keydata,
 					KeyDataPassword: password,
 				}
-				keyIdPasswordMap[keyid] = pkd
+				keyIDPasswordMap[keyid] = pkd
 			}
 
 			symKeyData, symKeyCipher, err := images.DecryptSymmetricKey(layerInfo.WrappedKeys, keyid, pkd.KeyData, pkd.KeyDataPassword, nil)
@@ -200,7 +184,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 				return layerSymkeyMap, err
 			}
 
-			index := fmt.Sprintf("%s:%d", layerInfo.Platform, layerInfo.Id)
+			index := fmt.Sprintf("%s:%d", layerInfo.Platform, layerInfo.ID)
 			layerSymkeyMap[index] = images.DecryptKeyData{
 				SymKeyData:   symKeyData,
 				SymKeyCipher: uint8(symKeyCipher),
@@ -210,9 +194,9 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 		}
 		if !found && len(layerInfo.WrappedKeys) > 0 {
 			keyIds, _ := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
-			kIds := commands.Uint64ToStringArray("0x%x", keyIds)
+			ids := commands.Uint64ToStringArray("0x%x", keyIds)
 
-			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %s", layerInfo.Id, layerInfo.Platform, strings.Join(kIds, ", "))
+			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %s", layerInfo.ID, layerInfo.Platform, strings.Join(ids, ", "))
 		}
 	}
 	return layerSymkeyMap, nil
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 289cb23..69b3b76 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -105,15 +105,15 @@ var encryptCommand = cli.Command{
 			return err
 		}
 
-		operation := images.OPERATION_ADD_RECIPIENTS
+		operation := images.OperationAddRecipients
 		if context.Bool("remove") {
-			operation = images.OPERATION_REMOVE_RECIPIENTS
+			operation = images.OperationRemoveRecipients
 		}
 
 		layers32 := commands.IntToInt32Array(context.IntSlice("layer"))
 
 		layerSymKeyMap := make(map[string]images.DecryptKeyData)
-		if operation == images.OPERATION_ADD_RECIPIENTS {
+		if operation == images.OperationAddRecipients {
 			layerInfos, err := client.ImageService().GetImageLayerInfo(ctx, local, layers32, context.StringSlice("platform"))
 			if err != nil {
 				return err
diff --git a/cmd/ctr/commands/images/layerinfo.go b/cmd/ctr/commands/images/layerinfo.go
index 36a6915..4cd2627 100644
--- a/cmd/ctr/commands/images/layerinfo.go
+++ b/cmd/ctr/commands/images/layerinfo.go
@@ -82,7 +82,7 @@ var layerinfoCommand = cli.Command{
 			for _, keyid := range keyIds {
 				array = append(array, "0x"+strconv.FormatUint(keyid, 16))
 			}
-			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.Id, layer.Digest, layer.Platform, layer.FileSize, layer.Encryption, strings.Join(array, ", "))
+			fmt.Fprintf(w, "%d\t%s\t%s\t%d\t%s\t%s\t\n", layer.ID, layer.Digest, layer.Platform, layer.FileSize, layer.Encryption, strings.Join(array, ", "))
 		}
 		w.Flush()
 		return nil
diff --git a/cmd/ctr/commands/utils.go b/cmd/ctr/commands/utils.go
index ad3cfce..f848522 100644
--- a/cmd/ctr/commands/utils.go
+++ b/cmd/ctr/commands/utils.go
@@ -20,6 +20,7 @@ import (
 	"fmt"
 )
 
+// IntToInt32Array converts an array of int's to int32's
 func IntToInt32Array(in []int) []int32 {
 	var ret []int32
 
@@ -29,6 +30,8 @@ func IntToInt32Array(in []int) []int32 {
 	return ret
 }
 
+// Uint64ToStringArray converts an array of uint64's to an array of strings
+// by applying a format string to each uint64
 func Uint64ToStringArray(format string, in []uint64) []string {
 	var ret []string
 
-- 
2.7.4


From 550e334697dc35de2331a4d37eb8f52e835c34df Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 15:52:44 -0400
Subject: [PATCH 70/79] More fixes to sync with .pr branch

---
 images/encryption.go   | 2 +-
 images/openpgp.go      | 1 +
 platforms/platforms.go | 1 +
 3 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/images/encryption.go b/images/encryption.go
index de6abfc..06bc310 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -45,7 +45,7 @@ type EncryptConfig struct {
 
 const (
 	// OperationAddRecipients instructs to add a recipient
-	OperationAddRecipients    = int32(iota)
+	OperationAddRecipients = int32(iota)
 	// OperationRemoveRecipients instructs to remove a recipient
 	OperationRemoveRecipients = int32(iota)
 )
diff --git a/images/openpgp.go b/images/openpgp.go
index 98e7774..810520e 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -56,6 +56,7 @@ import (
 
 	"crypto"
 	"crypto/rand"
+
 	"github.com/containerd/containerd/errdefs"
 	"github.com/pkg/errors"
 	"golang.org/x/crypto/openpgp"
diff --git a/platforms/platforms.go b/platforms/platforms.go
index caa5113..2038379 100644
--- a/platforms/platforms.go
+++ b/platforms/platforms.go
@@ -231,6 +231,7 @@ func Parse(specifier string) (specs.Platform, error) {
 	return specs.Platform{}, errors.Wrapf(errdefs.ErrInvalidArgument, "%q: cannot parse platform specifier", specifier)
 }
 
+// ParseArray parses an array of specifieds and converts them into an array of specs.Platform
 func ParseArray(specifiers []string) ([]specs.Platform, error) {
 	var speclist []specs.Platform
 
-- 
2.7.4


From babd9a14cbfbe2fab5e36754246d757204e31ebf Mon Sep 17 00:00:00 2001
From: Harshal Patil <harshal.patil@in.ibm.com>
Date: Wed, 8 Aug 2018 00:18:09 +0530
Subject: [PATCH 71/79] Fixing OCI Index manifest push to registry

Signed-off-by: Harshal Patil <harshal.patil@in.ibm.com>
---
 images/image.go | 21 +++++----------------
 1 file changed, 5 insertions(+), 16 deletions(-)

diff --git a/images/image.go b/images/image.go
index 86096d7..ecf1b26 100644
--- a/images/image.go
+++ b/images/image.go
@@ -788,20 +788,9 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 	if modified {
 		// we need to update the index
 
-		// TODO: Hack to work with docker registry since it still expects the mediatype for index
-		// REF: https://github.com/moby/buildkit/blob/master/exporter/containerimage/writer.go#L83-L100
-		newIndex := struct {
-			// MediaType is reserved in the OCI spec but
-			// excluded from go types.
-			MediaType string `json:"mediaType,omitempty"`
-
-			ocispec.Index
-		}{
-			MediaType: MediaTypeDockerSchema2ManifestList,
-			Index: ocispec.Index{
-				Versioned: index.Versioned,
-				Manifests: newManifests,
-			},
+		newIndex := ocispec.Index{
+			Versioned: index.Versioned,
+			Manifests: newManifests,
 		}
 
 		mb, err := json.MarshalIndent(newIndex, "", "   ")
@@ -810,7 +799,7 @@ func cryptManifestList(ctx context.Context, cs content.Store, desc ocispec.Descr
 		}
 
 		newDesc := ocispec.Descriptor{
-			MediaType: desc.MediaType,
+			MediaType: ocispec.MediaTypeImageIndex,
 			Size:      int64(len(mb)),
 			Digest:    digest.Canonical.FromBytes(mb),
 		}
@@ -859,7 +848,7 @@ func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 	)
 
 	switch desc.MediaType {
-	case MediaTypeDockerSchema2ManifestList,
+	case MediaTypeDockerSchema2ManifestList, ocispec.MediaTypeImageIndex,
 		MediaTypeDockerSchema2Manifest, ocispec.MediaTypeImageManifest:
 		children, err := Children(ctx, cs, desc)
 		if desc.Platform != nil {
-- 
2.7.4


From c340056cd265751b69f67577a7c6fa320935b51c Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 16:25:05 -0400
Subject: [PATCH 72/79] Make vndr happy by importing
 golang.org/x/crypto/{cast5,openpgp}

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 vendor/golang.org/x/crypto/cast5/cast5.go          | 526 +++++++++++++++
 vendor/golang.org/x/crypto/openpgp/armor/armor.go  | 219 ++++++
 vendor/golang.org/x/crypto/openpgp/armor/encode.go | 160 +++++
 .../golang.org/x/crypto/openpgp/canonical_text.go  |  59 ++
 .../golang.org/x/crypto/openpgp/elgamal/elgamal.go | 122 ++++
 .../golang.org/x/crypto/openpgp/errors/errors.go   |  72 ++
 vendor/golang.org/x/crypto/openpgp/keys.go         | 641 ++++++++++++++++++
 .../x/crypto/openpgp/packet/compressed.go          | 123 ++++
 .../golang.org/x/crypto/openpgp/packet/config.go   |  91 +++
 .../x/crypto/openpgp/packet/encrypted_key.go       | 199 ++++++
 .../golang.org/x/crypto/openpgp/packet/literal.go  |  89 +++
 vendor/golang.org/x/crypto/openpgp/packet/ocfb.go  | 143 ++++
 .../x/crypto/openpgp/packet/one_pass_signature.go  |  73 ++
 .../golang.org/x/crypto/openpgp/packet/opaque.go   | 162 +++++
 .../golang.org/x/crypto/openpgp/packet/packet.go   | 537 +++++++++++++++
 .../x/crypto/openpgp/packet/private_key.go         | 380 +++++++++++
 .../x/crypto/openpgp/packet/public_key.go          | 748 +++++++++++++++++++++
 .../x/crypto/openpgp/packet/public_key_v3.go       | 279 ++++++++
 .../golang.org/x/crypto/openpgp/packet/reader.go   |  76 +++
 .../x/crypto/openpgp/packet/signature.go           | 731 ++++++++++++++++++++
 .../x/crypto/openpgp/packet/signature_v3.go        | 146 ++++
 .../openpgp/packet/symmetric_key_encrypted.go      | 155 +++++
 .../openpgp/packet/symmetrically_encrypted.go      | 290 ++++++++
 .../x/crypto/openpgp/packet/userattribute.go       |  91 +++
 .../golang.org/x/crypto/openpgp/packet/userid.go   | 160 +++++
 vendor/golang.org/x/crypto/openpgp/read.go         | 442 ++++++++++++
 vendor/golang.org/x/crypto/openpgp/s2k/s2k.go      | 273 ++++++++
 vendor/golang.org/x/crypto/openpgp/write.go        | 378 +++++++++++
 28 files changed, 7365 insertions(+)
 create mode 100644 vendor/golang.org/x/crypto/cast5/cast5.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/armor/armor.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/armor/encode.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/canonical_text.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/elgamal/elgamal.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/errors/errors.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/keys.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/compressed.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/config.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/encrypted_key.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/literal.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/ocfb.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/one_pass_signature.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/opaque.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/packet.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/private_key.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/public_key.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/public_key_v3.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/reader.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/signature.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/signature_v3.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/symmetric_key_encrypted.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/symmetrically_encrypted.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/packet/userid.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/read.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/s2k/s2k.go
 create mode 100644 vendor/golang.org/x/crypto/openpgp/write.go

diff --git a/vendor/golang.org/x/crypto/cast5/cast5.go b/vendor/golang.org/x/crypto/cast5/cast5.go
new file mode 100644
index 0000000..0b4af37
--- /dev/null
+++ b/vendor/golang.org/x/crypto/cast5/cast5.go
@@ -0,0 +1,526 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package cast5 implements CAST5, as defined in RFC 2144. CAST5 is a common
+// OpenPGP cipher.
+package cast5 // import "golang.org/x/crypto/cast5"
+
+import "errors"
+
+const BlockSize = 8
+const KeySize = 16
+
+type Cipher struct {
+	masking [16]uint32
+	rotate  [16]uint8
+}
+
+func NewCipher(key []byte) (c *Cipher, err error) {
+	if len(key) != KeySize {
+		return nil, errors.New("CAST5: keys must be 16 bytes")
+	}
+
+	c = new(Cipher)
+	c.keySchedule(key)
+	return
+}
+
+func (c *Cipher) BlockSize() int {
+	return BlockSize
+}
+
+func (c *Cipher) Encrypt(dst, src []byte) {
+	l := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])
+	r := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])
+
+	l, r = r, l^f1(r, c.masking[0], c.rotate[0])
+	l, r = r, l^f2(r, c.masking[1], c.rotate[1])
+	l, r = r, l^f3(r, c.masking[2], c.rotate[2])
+	l, r = r, l^f1(r, c.masking[3], c.rotate[3])
+
+	l, r = r, l^f2(r, c.masking[4], c.rotate[4])
+	l, r = r, l^f3(r, c.masking[5], c.rotate[5])
+	l, r = r, l^f1(r, c.masking[6], c.rotate[6])
+	l, r = r, l^f2(r, c.masking[7], c.rotate[7])
+
+	l, r = r, l^f3(r, c.masking[8], c.rotate[8])
+	l, r = r, l^f1(r, c.masking[9], c.rotate[9])
+	l, r = r, l^f2(r, c.masking[10], c.rotate[10])
+	l, r = r, l^f3(r, c.masking[11], c.rotate[11])
+
+	l, r = r, l^f1(r, c.masking[12], c.rotate[12])
+	l, r = r, l^f2(r, c.masking[13], c.rotate[13])
+	l, r = r, l^f3(r, c.masking[14], c.rotate[14])
+	l, r = r, l^f1(r, c.masking[15], c.rotate[15])
+
+	dst[0] = uint8(r >> 24)
+	dst[1] = uint8(r >> 16)
+	dst[2] = uint8(r >> 8)
+	dst[3] = uint8(r)
+	dst[4] = uint8(l >> 24)
+	dst[5] = uint8(l >> 16)
+	dst[6] = uint8(l >> 8)
+	dst[7] = uint8(l)
+}
+
+func (c *Cipher) Decrypt(dst, src []byte) {
+	l := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])
+	r := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])
+
+	l, r = r, l^f1(r, c.masking[15], c.rotate[15])
+	l, r = r, l^f3(r, c.masking[14], c.rotate[14])
+	l, r = r, l^f2(r, c.masking[13], c.rotate[13])
+	l, r = r, l^f1(r, c.masking[12], c.rotate[12])
+
+	l, r = r, l^f3(r, c.masking[11], c.rotate[11])
+	l, r = r, l^f2(r, c.masking[10], c.rotate[10])
+	l, r = r, l^f1(r, c.masking[9], c.rotate[9])
+	l, r = r, l^f3(r, c.masking[8], c.rotate[8])
+
+	l, r = r, l^f2(r, c.masking[7], c.rotate[7])
+	l, r = r, l^f1(r, c.masking[6], c.rotate[6])
+	l, r = r, l^f3(r, c.masking[5], c.rotate[5])
+	l, r = r, l^f2(r, c.masking[4], c.rotate[4])
+
+	l, r = r, l^f1(r, c.masking[3], c.rotate[3])
+	l, r = r, l^f3(r, c.masking[2], c.rotate[2])
+	l, r = r, l^f2(r, c.masking[1], c.rotate[1])
+	l, r = r, l^f1(r, c.masking[0], c.rotate[0])
+
+	dst[0] = uint8(r >> 24)
+	dst[1] = uint8(r >> 16)
+	dst[2] = uint8(r >> 8)
+	dst[3] = uint8(r)
+	dst[4] = uint8(l >> 24)
+	dst[5] = uint8(l >> 16)
+	dst[6] = uint8(l >> 8)
+	dst[7] = uint8(l)
+}
+
+type keyScheduleA [4][7]uint8
+type keyScheduleB [4][5]uint8
+
+// keyScheduleRound contains the magic values for a round of the key schedule.
+// The keyScheduleA deals with the lines like:
+//   z0z1z2z3 = x0x1x2x3 ^ S5[xD] ^ S6[xF] ^ S7[xC] ^ S8[xE] ^ S7[x8]
+// Conceptually, both x and z are in the same array, x first. The first
+// element describes which word of this array gets written to and the
+// second, which word gets read. So, for the line above, it's "4, 0", because
+// it's writing to the first word of z, which, being after x, is word 4, and
+// reading from the first word of x: word 0.
+//
+// Next are the indexes into the S-boxes. Now the array is treated as bytes. So
+// "xD" is 0xd. The first byte of z is written as "16 + 0", just to be clear
+// that it's z that we're indexing.
+//
+// keyScheduleB deals with lines like:
+//   K1 = S5[z8] ^ S6[z9] ^ S7[z7] ^ S8[z6] ^ S5[z2]
+// "K1" is ignored because key words are always written in order. So the five
+// elements are the S-box indexes. They use the same form as in keyScheduleA,
+// above.
+
+type keyScheduleRound struct{}
+type keySchedule []keyScheduleRound
+
+var schedule = []struct {
+	a keyScheduleA
+	b keyScheduleB
+}{
+	{
+		keyScheduleA{
+			{4, 0, 0xd, 0xf, 0xc, 0xe, 0x8},
+			{5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa},
+			{6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9},
+			{7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb},
+		},
+		keyScheduleB{
+			{16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2},
+			{16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6},
+			{16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9},
+			{16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc},
+		},
+	},
+	{
+		keyScheduleA{
+			{0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0},
+			{1, 4, 0, 2, 1, 3, 16 + 2},
+			{2, 5, 7, 6, 5, 4, 16 + 1},
+			{3, 7, 0xa, 9, 0xb, 8, 16 + 3},
+		},
+		keyScheduleB{
+			{3, 2, 0xc, 0xd, 8},
+			{1, 0, 0xe, 0xf, 0xd},
+			{7, 6, 8, 9, 3},
+			{5, 4, 0xa, 0xb, 7},
+		},
+	},
+	{
+		keyScheduleA{
+			{4, 0, 0xd, 0xf, 0xc, 0xe, 8},
+			{5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa},
+			{6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9},
+			{7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb},
+		},
+		keyScheduleB{
+			{16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9},
+			{16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc},
+			{16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2},
+			{16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6},
+		},
+	},
+	{
+		keyScheduleA{
+			{0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0},
+			{1, 4, 0, 2, 1, 3, 16 + 2},
+			{2, 5, 7, 6, 5, 4, 16 + 1},
+			{3, 7, 0xa, 9, 0xb, 8, 16 + 3},
+		},
+		keyScheduleB{
+			{8, 9, 7, 6, 3},
+			{0xa, 0xb, 5, 4, 7},
+			{0xc, 0xd, 3, 2, 8},
+			{0xe, 0xf, 1, 0, 0xd},
+		},
+	},
+}
+
+func (c *Cipher) keySchedule(in []byte) {
+	var t [8]uint32
+	var k [32]uint32
+
+	for i := 0; i < 4; i++ {
+		j := i * 4
+		t[i] = uint32(in[j])<<24 | uint32(in[j+1])<<16 | uint32(in[j+2])<<8 | uint32(in[j+3])
+	}
+
+	x := []byte{6, 7, 4, 5}
+	ki := 0
+
+	for half := 0; half < 2; half++ {
+		for _, round := range schedule {
+			for j := 0; j < 4; j++ {
+				var a [7]uint8
+				copy(a[:], round.a[j][:])
+				w := t[a[1]]
+				w ^= sBox[4][(t[a[2]>>2]>>(24-8*(a[2]&3)))&0xff]
+				w ^= sBox[5][(t[a[3]>>2]>>(24-8*(a[3]&3)))&0xff]
+				w ^= sBox[6][(t[a[4]>>2]>>(24-8*(a[4]&3)))&0xff]
+				w ^= sBox[7][(t[a[5]>>2]>>(24-8*(a[5]&3)))&0xff]
+				w ^= sBox[x[j]][(t[a[6]>>2]>>(24-8*(a[6]&3)))&0xff]
+				t[a[0]] = w
+			}
+
+			for j := 0; j < 4; j++ {
+				var b [5]uint8
+				copy(b[:], round.b[j][:])
+				w := sBox[4][(t[b[0]>>2]>>(24-8*(b[0]&3)))&0xff]
+				w ^= sBox[5][(t[b[1]>>2]>>(24-8*(b[1]&3)))&0xff]
+				w ^= sBox[6][(t[b[2]>>2]>>(24-8*(b[2]&3)))&0xff]
+				w ^= sBox[7][(t[b[3]>>2]>>(24-8*(b[3]&3)))&0xff]
+				w ^= sBox[4+j][(t[b[4]>>2]>>(24-8*(b[4]&3)))&0xff]
+				k[ki] = w
+				ki++
+			}
+		}
+	}
+
+	for i := 0; i < 16; i++ {
+		c.masking[i] = k[i]
+		c.rotate[i] = uint8(k[16+i] & 0x1f)
+	}
+}
+
+// These are the three 'f' functions. See RFC 2144, section 2.2.
+func f1(d, m uint32, r uint8) uint32 {
+	t := m + d
+	I := (t << r) | (t >> (32 - r))
+	return ((sBox[0][I>>24] ^ sBox[1][(I>>16)&0xff]) - sBox[2][(I>>8)&0xff]) + sBox[3][I&0xff]
+}
+
+func f2(d, m uint32, r uint8) uint32 {
+	t := m ^ d
+	I := (t << r) | (t >> (32 - r))
+	return ((sBox[0][I>>24] - sBox[1][(I>>16)&0xff]) + sBox[2][(I>>8)&0xff]) ^ sBox[3][I&0xff]
+}
+
+func f3(d, m uint32, r uint8) uint32 {
+	t := m - d
+	I := (t << r) | (t >> (32 - r))
+	return ((sBox[0][I>>24] + sBox[1][(I>>16)&0xff]) ^ sBox[2][(I>>8)&0xff]) - sBox[3][I&0xff]
+}
+
+var sBox = [8][256]uint32{
+	{
+		0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949,
+		0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e,
+		0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,
+		0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0,
+		0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7,
+		0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,
+		0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d,
+		0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50,
+		0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,
+		0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3,
+		0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167,
+		0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,
+		0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779,
+		0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2,
+		0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,
+		0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d,
+		0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5,
+		0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324,
+		0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c,
+		0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc,
+		0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d,
+		0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96,
+		0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a,
+		0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d,
+		0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd,
+		0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6,
+		0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,
+		0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872,
+		0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c,
+		0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,
+		0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9,
+		0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf,
+	},
+	{
+		0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651,
+		0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3,
+		0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,
+		0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806,
+		0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b,
+		0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,
+		0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b,
+		0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c,
+		0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,
+		0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb,
+		0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd,
+		0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,
+		0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b,
+		0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304,
+		0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,
+		0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf,
+		0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c,
+		0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,
+		0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f,
+		0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6,
+		0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,
+		0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58,
+		0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906,
+		0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,
+		0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6,
+		0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4,
+		0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,
+		0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f,
+		0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249,
+		0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,
+		0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9,
+		0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1,
+	},
+	{
+		0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90,
+		0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5,
+		0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,
+		0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240,
+		0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5,
+		0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,
+		0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71,
+		0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04,
+		0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,
+		0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15,
+		0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2,
+		0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,
+		0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148,
+		0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc,
+		0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,
+		0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e,
+		0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51,
+		0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,
+		0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a,
+		0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b,
+		0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,
+		0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5,
+		0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45,
+		0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,
+		0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc,
+		0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0,
+		0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,
+		0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2,
+		0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49,
+		0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,
+		0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a,
+		0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783,
+	},
+	{
+		0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1,
+		0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf,
+		0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,
+		0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121,
+		0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25,
+		0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,
+		0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb,
+		0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5,
+		0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,
+		0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6,
+		0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23,
+		0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,
+		0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6,
+		0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119,
+		0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,
+		0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a,
+		0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79,
+		0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,
+		0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26,
+		0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab,
+		0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,
+		0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417,
+		0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2,
+		0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,
+		0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a,
+		0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919,
+		0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,
+		0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876,
+		0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab,
+		0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,
+		0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282,
+		0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2,
+	},
+	{
+		0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f,
+		0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a,
+		0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff,
+		0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02,
+		0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a,
+		0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7,
+		0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9,
+		0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981,
+		0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774,
+		0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655,
+		0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2,
+		0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910,
+		0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1,
+		0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da,
+		0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049,
+		0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f,
+		0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba,
+		0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be,
+		0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3,
+		0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840,
+		0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4,
+		0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2,
+		0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7,
+		0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5,
+		0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e,
+		0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e,
+		0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801,
+		0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad,
+		0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0,
+		0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20,
+		0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8,
+		0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4,
+	},
+	{
+		0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac,
+		0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138,
+		0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367,
+		0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98,
+		0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072,
+		0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3,
+		0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd,
+		0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8,
+		0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9,
+		0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54,
+		0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387,
+		0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc,
+		0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf,
+		0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf,
+		0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f,
+		0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289,
+		0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950,
+		0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f,
+		0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b,
+		0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be,
+		0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13,
+		0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976,
+		0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0,
+		0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891,
+		0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da,
+		0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc,
+		0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084,
+		0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25,
+		0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121,
+		0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5,
+		0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd,
+		0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f,
+	},
+	{
+		0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f,
+		0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de,
+		0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43,
+		0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19,
+		0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2,
+		0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516,
+		0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88,
+		0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816,
+		0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756,
+		0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a,
+		0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264,
+		0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688,
+		0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28,
+		0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3,
+		0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7,
+		0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06,
+		0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033,
+		0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a,
+		0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566,
+		0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509,
+		0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962,
+		0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e,
+		0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c,
+		0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c,
+		0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285,
+		0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301,
+		0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be,
+		0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767,
+		0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647,
+		0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914,
+		0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c,
+		0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3,
+	},
+	{
+		0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5,
+		0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc,
+		0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd,
+		0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d,
+		0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2,
+		0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862,
+		0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc,
+		0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c,
+		0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e,
+		0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039,
+		0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8,
+		0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42,
+		0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5,
+		0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472,
+		0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225,
+		0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c,
+		0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb,
+		0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054,
+		0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70,
+		0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc,
+		0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c,
+		0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3,
+		0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4,
+		0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101,
+		0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f,
+		0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e,
+		0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a,
+		0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c,
+		0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384,
+		0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c,
+		0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82,
+		0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e,
+	},
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/armor/armor.go b/vendor/golang.org/x/crypto/openpgp/armor/armor.go
new file mode 100644
index 0000000..592d186
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/armor/armor.go
@@ -0,0 +1,219 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package armor implements OpenPGP ASCII Armor, see RFC 4880. OpenPGP Armor is
+// very similar to PEM except that it has an additional CRC checksum.
+package armor // import "golang.org/x/crypto/openpgp/armor"
+
+import (
+	"bufio"
+	"bytes"
+	"encoding/base64"
+	"golang.org/x/crypto/openpgp/errors"
+	"io"
+)
+
+// A Block represents an OpenPGP armored structure.
+//
+// The encoded form is:
+//    -----BEGIN Type-----
+//    Headers
+//
+//    base64-encoded Bytes
+//    '=' base64 encoded checksum
+//    -----END Type-----
+// where Headers is a possibly empty sequence of Key: Value lines.
+//
+// Since the armored data can be very large, this package presents a streaming
+// interface.
+type Block struct {
+	Type    string            // The type, taken from the preamble (i.e. "PGP SIGNATURE").
+	Header  map[string]string // Optional headers.
+	Body    io.Reader         // A Reader from which the contents can be read
+	lReader lineReader
+	oReader openpgpReader
+}
+
+var ArmorCorrupt error = errors.StructuralError("armor invalid")
+
+const crc24Init = 0xb704ce
+const crc24Poly = 0x1864cfb
+const crc24Mask = 0xffffff
+
+// crc24 calculates the OpenPGP checksum as specified in RFC 4880, section 6.1
+func crc24(crc uint32, d []byte) uint32 {
+	for _, b := range d {
+		crc ^= uint32(b) << 16
+		for i := 0; i < 8; i++ {
+			crc <<= 1
+			if crc&0x1000000 != 0 {
+				crc ^= crc24Poly
+			}
+		}
+	}
+	return crc
+}
+
+var armorStart = []byte("-----BEGIN ")
+var armorEnd = []byte("-----END ")
+var armorEndOfLine = []byte("-----")
+
+// lineReader wraps a line based reader. It watches for the end of an armor
+// block and records the expected CRC value.
+type lineReader struct {
+	in  *bufio.Reader
+	buf []byte
+	eof bool
+	crc uint32
+}
+
+func (l *lineReader) Read(p []byte) (n int, err error) {
+	if l.eof {
+		return 0, io.EOF
+	}
+
+	if len(l.buf) > 0 {
+		n = copy(p, l.buf)
+		l.buf = l.buf[n:]
+		return
+	}
+
+	line, isPrefix, err := l.in.ReadLine()
+	if err != nil {
+		return
+	}
+	if isPrefix {
+		return 0, ArmorCorrupt
+	}
+
+	if len(line) == 5 && line[0] == '=' {
+		// This is the checksum line
+		var expectedBytes [3]byte
+		var m int
+		m, err = base64.StdEncoding.Decode(expectedBytes[0:], line[1:])
+		if m != 3 || err != nil {
+			return
+		}
+		l.crc = uint32(expectedBytes[0])<<16 |
+			uint32(expectedBytes[1])<<8 |
+			uint32(expectedBytes[2])
+
+		line, _, err = l.in.ReadLine()
+		if err != nil && err != io.EOF {
+			return
+		}
+		if !bytes.HasPrefix(line, armorEnd) {
+			return 0, ArmorCorrupt
+		}
+
+		l.eof = true
+		return 0, io.EOF
+	}
+
+	if len(line) > 96 {
+		return 0, ArmorCorrupt
+	}
+
+	n = copy(p, line)
+	bytesToSave := len(line) - n
+	if bytesToSave > 0 {
+		if cap(l.buf) < bytesToSave {
+			l.buf = make([]byte, 0, bytesToSave)
+		}
+		l.buf = l.buf[0:bytesToSave]
+		copy(l.buf, line[n:])
+	}
+
+	return
+}
+
+// openpgpReader passes Read calls to the underlying base64 decoder, but keeps
+// a running CRC of the resulting data and checks the CRC against the value
+// found by the lineReader at EOF.
+type openpgpReader struct {
+	lReader    *lineReader
+	b64Reader  io.Reader
+	currentCRC uint32
+}
+
+func (r *openpgpReader) Read(p []byte) (n int, err error) {
+	n, err = r.b64Reader.Read(p)
+	r.currentCRC = crc24(r.currentCRC, p[:n])
+
+	if err == io.EOF {
+		if r.lReader.crc != uint32(r.currentCRC&crc24Mask) {
+			return 0, ArmorCorrupt
+		}
+	}
+
+	return
+}
+
+// Decode reads a PGP armored block from the given Reader. It will ignore
+// leading garbage. If it doesn't find a block, it will return nil, io.EOF. The
+// given Reader is not usable after calling this function: an arbitrary amount
+// of data may have been read past the end of the block.
+func Decode(in io.Reader) (p *Block, err error) {
+	r := bufio.NewReaderSize(in, 100)
+	var line []byte
+	ignoreNext := false
+
+TryNextBlock:
+	p = nil
+
+	// Skip leading garbage
+	for {
+		ignoreThis := ignoreNext
+		line, ignoreNext, err = r.ReadLine()
+		if err != nil {
+			return
+		}
+		if ignoreNext || ignoreThis {
+			continue
+		}
+		line = bytes.TrimSpace(line)
+		if len(line) > len(armorStart)+len(armorEndOfLine) && bytes.HasPrefix(line, armorStart) {
+			break
+		}
+	}
+
+	p = new(Block)
+	p.Type = string(line[len(armorStart) : len(line)-len(armorEndOfLine)])
+	p.Header = make(map[string]string)
+	nextIsContinuation := false
+	var lastKey string
+
+	// Read headers
+	for {
+		isContinuation := nextIsContinuation
+		line, nextIsContinuation, err = r.ReadLine()
+		if err != nil {
+			p = nil
+			return
+		}
+		if isContinuation {
+			p.Header[lastKey] += string(line)
+			continue
+		}
+		line = bytes.TrimSpace(line)
+		if len(line) == 0 {
+			break
+		}
+
+		i := bytes.Index(line, []byte(": "))
+		if i == -1 {
+			goto TryNextBlock
+		}
+		lastKey = string(line[:i])
+		p.Header[lastKey] = string(line[i+2:])
+	}
+
+	p.lReader.in = r
+	p.oReader.currentCRC = crc24Init
+	p.oReader.lReader = &p.lReader
+	p.oReader.b64Reader = base64.NewDecoder(base64.StdEncoding, &p.lReader)
+	p.Body = &p.oReader
+
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/armor/encode.go b/vendor/golang.org/x/crypto/openpgp/armor/encode.go
new file mode 100644
index 0000000..6f07582
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/armor/encode.go
@@ -0,0 +1,160 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package armor
+
+import (
+	"encoding/base64"
+	"io"
+)
+
+var armorHeaderSep = []byte(": ")
+var blockEnd = []byte("\n=")
+var newline = []byte("\n")
+var armorEndOfLineOut = []byte("-----\n")
+
+// writeSlices writes its arguments to the given Writer.
+func writeSlices(out io.Writer, slices ...[]byte) (err error) {
+	for _, s := range slices {
+		_, err = out.Write(s)
+		if err != nil {
+			return err
+		}
+	}
+	return
+}
+
+// lineBreaker breaks data across several lines, all of the same byte length
+// (except possibly the last). Lines are broken with a single '\n'.
+type lineBreaker struct {
+	lineLength  int
+	line        []byte
+	used        int
+	out         io.Writer
+	haveWritten bool
+}
+
+func newLineBreaker(out io.Writer, lineLength int) *lineBreaker {
+	return &lineBreaker{
+		lineLength: lineLength,
+		line:       make([]byte, lineLength),
+		used:       0,
+		out:        out,
+	}
+}
+
+func (l *lineBreaker) Write(b []byte) (n int, err error) {
+	n = len(b)
+
+	if n == 0 {
+		return
+	}
+
+	if l.used == 0 && l.haveWritten {
+		_, err = l.out.Write([]byte{'\n'})
+		if err != nil {
+			return
+		}
+	}
+
+	if l.used+len(b) < l.lineLength {
+		l.used += copy(l.line[l.used:], b)
+		return
+	}
+
+	l.haveWritten = true
+	_, err = l.out.Write(l.line[0:l.used])
+	if err != nil {
+		return
+	}
+	excess := l.lineLength - l.used
+	l.used = 0
+
+	_, err = l.out.Write(b[0:excess])
+	if err != nil {
+		return
+	}
+
+	_, err = l.Write(b[excess:])
+	return
+}
+
+func (l *lineBreaker) Close() (err error) {
+	if l.used > 0 {
+		_, err = l.out.Write(l.line[0:l.used])
+		if err != nil {
+			return
+		}
+	}
+
+	return
+}
+
+// encoding keeps track of a running CRC24 over the data which has been written
+// to it and outputs a OpenPGP checksum when closed, followed by an armor
+// trailer.
+//
+// It's built into a stack of io.Writers:
+//    encoding -> base64 encoder -> lineBreaker -> out
+type encoding struct {
+	out       io.Writer
+	breaker   *lineBreaker
+	b64       io.WriteCloser
+	crc       uint32
+	blockType []byte
+}
+
+func (e *encoding) Write(data []byte) (n int, err error) {
+	e.crc = crc24(e.crc, data)
+	return e.b64.Write(data)
+}
+
+func (e *encoding) Close() (err error) {
+	err = e.b64.Close()
+	if err != nil {
+		return
+	}
+	e.breaker.Close()
+
+	var checksumBytes [3]byte
+	checksumBytes[0] = byte(e.crc >> 16)
+	checksumBytes[1] = byte(e.crc >> 8)
+	checksumBytes[2] = byte(e.crc)
+
+	var b64ChecksumBytes [4]byte
+	base64.StdEncoding.Encode(b64ChecksumBytes[:], checksumBytes[:])
+
+	return writeSlices(e.out, blockEnd, b64ChecksumBytes[:], newline, armorEnd, e.blockType, armorEndOfLine)
+}
+
+// Encode returns a WriteCloser which will encode the data written to it in
+// OpenPGP armor.
+func Encode(out io.Writer, blockType string, headers map[string]string) (w io.WriteCloser, err error) {
+	bType := []byte(blockType)
+	err = writeSlices(out, armorStart, bType, armorEndOfLineOut)
+	if err != nil {
+		return
+	}
+
+	for k, v := range headers {
+		err = writeSlices(out, []byte(k), armorHeaderSep, []byte(v), newline)
+		if err != nil {
+			return
+		}
+	}
+
+	_, err = out.Write(newline)
+	if err != nil {
+		return
+	}
+
+	e := &encoding{
+		out:       out,
+		breaker:   newLineBreaker(out, 64),
+		crc:       crc24Init,
+		blockType: bType,
+	}
+	e.b64 = base64.NewEncoder(base64.StdEncoding, e.breaker)
+	return e, nil
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/canonical_text.go b/vendor/golang.org/x/crypto/openpgp/canonical_text.go
new file mode 100644
index 0000000..e601e38
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/canonical_text.go
@@ -0,0 +1,59 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package openpgp
+
+import "hash"
+
+// NewCanonicalTextHash reformats text written to it into the canonical
+// form and then applies the hash h.  See RFC 4880, section 5.2.1.
+func NewCanonicalTextHash(h hash.Hash) hash.Hash {
+	return &canonicalTextHash{h, 0}
+}
+
+type canonicalTextHash struct {
+	h hash.Hash
+	s int
+}
+
+var newline = []byte{'\r', '\n'}
+
+func (cth *canonicalTextHash) Write(buf []byte) (int, error) {
+	start := 0
+
+	for i, c := range buf {
+		switch cth.s {
+		case 0:
+			if c == '\r' {
+				cth.s = 1
+			} else if c == '\n' {
+				cth.h.Write(buf[start:i])
+				cth.h.Write(newline)
+				start = i + 1
+			}
+		case 1:
+			cth.s = 0
+		}
+	}
+
+	cth.h.Write(buf[start:])
+	return len(buf), nil
+}
+
+func (cth *canonicalTextHash) Sum(in []byte) []byte {
+	return cth.h.Sum(in)
+}
+
+func (cth *canonicalTextHash) Reset() {
+	cth.h.Reset()
+	cth.s = 0
+}
+
+func (cth *canonicalTextHash) Size() int {
+	return cth.h.Size()
+}
+
+func (cth *canonicalTextHash) BlockSize() int {
+	return cth.h.BlockSize()
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/elgamal/elgamal.go b/vendor/golang.org/x/crypto/openpgp/elgamal/elgamal.go
new file mode 100644
index 0000000..73f4fe3
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/elgamal/elgamal.go
@@ -0,0 +1,122 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package elgamal implements ElGamal encryption, suitable for OpenPGP,
+// as specified in "A Public-Key Cryptosystem and a Signature Scheme Based on
+// Discrete Logarithms," IEEE Transactions on Information Theory, v. IT-31,
+// n. 4, 1985, pp. 469-472.
+//
+// This form of ElGamal embeds PKCS#1 v1.5 padding, which may make it
+// unsuitable for other protocols. RSA should be used in preference in any
+// case.
+package elgamal // import "golang.org/x/crypto/openpgp/elgamal"
+
+import (
+	"crypto/rand"
+	"crypto/subtle"
+	"errors"
+	"io"
+	"math/big"
+)
+
+// PublicKey represents an ElGamal public key.
+type PublicKey struct {
+	G, P, Y *big.Int
+}
+
+// PrivateKey represents an ElGamal private key.
+type PrivateKey struct {
+	PublicKey
+	X *big.Int
+}
+
+// Encrypt encrypts the given message to the given public key. The result is a
+// pair of integers. Errors can result from reading random, or because msg is
+// too large to be encrypted to the public key.
+func Encrypt(random io.Reader, pub *PublicKey, msg []byte) (c1, c2 *big.Int, err error) {
+	pLen := (pub.P.BitLen() + 7) / 8
+	if len(msg) > pLen-11 {
+		err = errors.New("elgamal: message too long")
+		return
+	}
+
+	// EM = 0x02 || PS || 0x00 || M
+	em := make([]byte, pLen-1)
+	em[0] = 2
+	ps, mm := em[1:len(em)-len(msg)-1], em[len(em)-len(msg):]
+	err = nonZeroRandomBytes(ps, random)
+	if err != nil {
+		return
+	}
+	em[len(em)-len(msg)-1] = 0
+	copy(mm, msg)
+
+	m := new(big.Int).SetBytes(em)
+
+	k, err := rand.Int(random, pub.P)
+	if err != nil {
+		return
+	}
+
+	c1 = new(big.Int).Exp(pub.G, k, pub.P)
+	s := new(big.Int).Exp(pub.Y, k, pub.P)
+	c2 = s.Mul(s, m)
+	c2.Mod(c2, pub.P)
+
+	return
+}
+
+// Decrypt takes two integers, resulting from an ElGamal encryption, and
+// returns the plaintext of the message. An error can result only if the
+// ciphertext is invalid. Users should keep in mind that this is a padding
+// oracle and thus, if exposed to an adaptive chosen ciphertext attack, can
+// be used to break the cryptosystem.  See ``Chosen Ciphertext Attacks
+// Against Protocols Based on the RSA Encryption Standard PKCS #1'', Daniel
+// Bleichenbacher, Advances in Cryptology (Crypto '98),
+func Decrypt(priv *PrivateKey, c1, c2 *big.Int) (msg []byte, err error) {
+	s := new(big.Int).Exp(c1, priv.X, priv.P)
+	s.ModInverse(s, priv.P)
+	s.Mul(s, c2)
+	s.Mod(s, priv.P)
+	em := s.Bytes()
+
+	firstByteIsTwo := subtle.ConstantTimeByteEq(em[0], 2)
+
+	// The remainder of the plaintext must be a string of non-zero random
+	// octets, followed by a 0, followed by the message.
+	//   lookingForIndex: 1 iff we are still looking for the zero.
+	//   index: the offset of the first zero byte.
+	var lookingForIndex, index int
+	lookingForIndex = 1
+
+	for i := 1; i < len(em); i++ {
+		equals0 := subtle.ConstantTimeByteEq(em[i], 0)
+		index = subtle.ConstantTimeSelect(lookingForIndex&equals0, i, index)
+		lookingForIndex = subtle.ConstantTimeSelect(equals0, 0, lookingForIndex)
+	}
+
+	if firstByteIsTwo != 1 || lookingForIndex != 0 || index < 9 {
+		return nil, errors.New("elgamal: decryption error")
+	}
+	return em[index+1:], nil
+}
+
+// nonZeroRandomBytes fills the given slice with non-zero random octets.
+func nonZeroRandomBytes(s []byte, rand io.Reader) (err error) {
+	_, err = io.ReadFull(rand, s)
+	if err != nil {
+		return
+	}
+
+	for i := 0; i < len(s); i++ {
+		for s[i] == 0 {
+			_, err = io.ReadFull(rand, s[i:i+1])
+			if err != nil {
+				return
+			}
+		}
+	}
+
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/errors/errors.go b/vendor/golang.org/x/crypto/openpgp/errors/errors.go
new file mode 100644
index 0000000..eb0550b
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/errors/errors.go
@@ -0,0 +1,72 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package errors contains common error types for the OpenPGP packages.
+package errors // import "golang.org/x/crypto/openpgp/errors"
+
+import (
+	"strconv"
+)
+
+// A StructuralError is returned when OpenPGP data is found to be syntactically
+// invalid.
+type StructuralError string
+
+func (s StructuralError) Error() string {
+	return "openpgp: invalid data: " + string(s)
+}
+
+// UnsupportedError indicates that, although the OpenPGP data is valid, it
+// makes use of currently unimplemented features.
+type UnsupportedError string
+
+func (s UnsupportedError) Error() string {
+	return "openpgp: unsupported feature: " + string(s)
+}
+
+// InvalidArgumentError indicates that the caller is in error and passed an
+// incorrect value.
+type InvalidArgumentError string
+
+func (i InvalidArgumentError) Error() string {
+	return "openpgp: invalid argument: " + string(i)
+}
+
+// SignatureError indicates that a syntactically valid signature failed to
+// validate.
+type SignatureError string
+
+func (b SignatureError) Error() string {
+	return "openpgp: invalid signature: " + string(b)
+}
+
+type keyIncorrectError int
+
+func (ki keyIncorrectError) Error() string {
+	return "openpgp: incorrect key"
+}
+
+var ErrKeyIncorrect error = keyIncorrectError(0)
+
+type unknownIssuerError int
+
+func (unknownIssuerError) Error() string {
+	return "openpgp: signature made by unknown entity"
+}
+
+var ErrUnknownIssuer error = unknownIssuerError(0)
+
+type keyRevokedError int
+
+func (keyRevokedError) Error() string {
+	return "openpgp: signature made by revoked key"
+}
+
+var ErrKeyRevoked error = keyRevokedError(0)
+
+type UnknownPacketTypeError uint8
+
+func (upte UnknownPacketTypeError) Error() string {
+	return "openpgp: unknown packet type: " + strconv.Itoa(int(upte))
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/keys.go b/vendor/golang.org/x/crypto/openpgp/keys.go
new file mode 100644
index 0000000..fd582a8
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/keys.go
@@ -0,0 +1,641 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package openpgp
+
+import (
+	"crypto/rsa"
+	"io"
+	"time"
+
+	"golang.org/x/crypto/openpgp/armor"
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/packet"
+)
+
+// PublicKeyType is the armor type for a PGP public key.
+var PublicKeyType = "PGP PUBLIC KEY BLOCK"
+
+// PrivateKeyType is the armor type for a PGP private key.
+var PrivateKeyType = "PGP PRIVATE KEY BLOCK"
+
+// An Entity represents the components of an OpenPGP key: a primary public key
+// (which must be a signing key), one or more identities claimed by that key,
+// and zero or more subkeys, which may be encryption keys.
+type Entity struct {
+	PrimaryKey  *packet.PublicKey
+	PrivateKey  *packet.PrivateKey
+	Identities  map[string]*Identity // indexed by Identity.Name
+	Revocations []*packet.Signature
+	Subkeys     []Subkey
+}
+
+// An Identity represents an identity claimed by an Entity and zero or more
+// assertions by other entities about that claim.
+type Identity struct {
+	Name          string // by convention, has the form "Full Name (comment) <email@example.com>"
+	UserId        *packet.UserId
+	SelfSignature *packet.Signature
+	Signatures    []*packet.Signature
+}
+
+// A Subkey is an additional public key in an Entity. Subkeys can be used for
+// encryption.
+type Subkey struct {
+	PublicKey  *packet.PublicKey
+	PrivateKey *packet.PrivateKey
+	Sig        *packet.Signature
+}
+
+// A Key identifies a specific public key in an Entity. This is either the
+// Entity's primary key or a subkey.
+type Key struct {
+	Entity        *Entity
+	PublicKey     *packet.PublicKey
+	PrivateKey    *packet.PrivateKey
+	SelfSignature *packet.Signature
+}
+
+// A KeyRing provides access to public and private keys.
+type KeyRing interface {
+	// KeysById returns the set of keys that have the given key id.
+	KeysById(id uint64) []Key
+	// KeysByIdAndUsage returns the set of keys with the given id
+	// that also meet the key usage given by requiredUsage.
+	// The requiredUsage is expressed as the bitwise-OR of
+	// packet.KeyFlag* values.
+	KeysByIdUsage(id uint64, requiredUsage byte) []Key
+	// DecryptionKeys returns all private keys that are valid for
+	// decryption.
+	DecryptionKeys() []Key
+}
+
+// primaryIdentity returns the Identity marked as primary or the first identity
+// if none are so marked.
+func (e *Entity) primaryIdentity() *Identity {
+	var firstIdentity *Identity
+	for _, ident := range e.Identities {
+		if firstIdentity == nil {
+			firstIdentity = ident
+		}
+		if ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {
+			return ident
+		}
+	}
+	return firstIdentity
+}
+
+// encryptionKey returns the best candidate Key for encrypting a message to the
+// given Entity.
+func (e *Entity) encryptionKey(now time.Time) (Key, bool) {
+	candidateSubkey := -1
+
+	// Iterate the keys to find the newest key
+	var maxTime time.Time
+	for i, subkey := range e.Subkeys {
+		if subkey.Sig.FlagsValid &&
+			subkey.Sig.FlagEncryptCommunications &&
+			subkey.PublicKey.PubKeyAlgo.CanEncrypt() &&
+			!subkey.Sig.KeyExpired(now) &&
+			(maxTime.IsZero() || subkey.Sig.CreationTime.After(maxTime)) {
+			candidateSubkey = i
+			maxTime = subkey.Sig.CreationTime
+		}
+	}
+
+	if candidateSubkey != -1 {
+		subkey := e.Subkeys[candidateSubkey]
+		return Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true
+	}
+
+	// If we don't have any candidate subkeys for encryption and
+	// the primary key doesn't have any usage metadata then we
+	// assume that the primary key is ok. Or, if the primary key is
+	// marked as ok to encrypt to, then we can obviously use it.
+	i := e.primaryIdentity()
+	if !i.SelfSignature.FlagsValid || i.SelfSignature.FlagEncryptCommunications &&
+		e.PrimaryKey.PubKeyAlgo.CanEncrypt() &&
+		!i.SelfSignature.KeyExpired(now) {
+		return Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true
+	}
+
+	// This Entity appears to be signing only.
+	return Key{}, false
+}
+
+// signingKey return the best candidate Key for signing a message with this
+// Entity.
+func (e *Entity) signingKey(now time.Time) (Key, bool) {
+	candidateSubkey := -1
+
+	for i, subkey := range e.Subkeys {
+		if subkey.Sig.FlagsValid &&
+			subkey.Sig.FlagSign &&
+			subkey.PublicKey.PubKeyAlgo.CanSign() &&
+			!subkey.Sig.KeyExpired(now) {
+			candidateSubkey = i
+			break
+		}
+	}
+
+	if candidateSubkey != -1 {
+		subkey := e.Subkeys[candidateSubkey]
+		return Key{e, subkey.PublicKey, subkey.PrivateKey, subkey.Sig}, true
+	}
+
+	// If we have no candidate subkey then we assume that it's ok to sign
+	// with the primary key.
+	i := e.primaryIdentity()
+	if !i.SelfSignature.FlagsValid || i.SelfSignature.FlagSign &&
+		!i.SelfSignature.KeyExpired(now) {
+		return Key{e, e.PrimaryKey, e.PrivateKey, i.SelfSignature}, true
+	}
+
+	return Key{}, false
+}
+
+// An EntityList contains one or more Entities.
+type EntityList []*Entity
+
+// KeysById returns the set of keys that have the given key id.
+func (el EntityList) KeysById(id uint64) (keys []Key) {
+	for _, e := range el {
+		if e.PrimaryKey.KeyId == id {
+			var selfSig *packet.Signature
+			for _, ident := range e.Identities {
+				if selfSig == nil {
+					selfSig = ident.SelfSignature
+				} else if ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {
+					selfSig = ident.SelfSignature
+					break
+				}
+			}
+			keys = append(keys, Key{e, e.PrimaryKey, e.PrivateKey, selfSig})
+		}
+
+		for _, subKey := range e.Subkeys {
+			if subKey.PublicKey.KeyId == id {
+				keys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})
+			}
+		}
+	}
+	return
+}
+
+// KeysByIdAndUsage returns the set of keys with the given id that also meet
+// the key usage given by requiredUsage.  The requiredUsage is expressed as
+// the bitwise-OR of packet.KeyFlag* values.
+func (el EntityList) KeysByIdUsage(id uint64, requiredUsage byte) (keys []Key) {
+	for _, key := range el.KeysById(id) {
+		if len(key.Entity.Revocations) > 0 {
+			continue
+		}
+
+		if key.SelfSignature.RevocationReason != nil {
+			continue
+		}
+
+		if key.SelfSignature.FlagsValid && requiredUsage != 0 {
+			var usage byte
+			if key.SelfSignature.FlagCertify {
+				usage |= packet.KeyFlagCertify
+			}
+			if key.SelfSignature.FlagSign {
+				usage |= packet.KeyFlagSign
+			}
+			if key.SelfSignature.FlagEncryptCommunications {
+				usage |= packet.KeyFlagEncryptCommunications
+			}
+			if key.SelfSignature.FlagEncryptStorage {
+				usage |= packet.KeyFlagEncryptStorage
+			}
+			if usage&requiredUsage != requiredUsage {
+				continue
+			}
+		}
+
+		keys = append(keys, key)
+	}
+	return
+}
+
+// DecryptionKeys returns all private keys that are valid for decryption.
+func (el EntityList) DecryptionKeys() (keys []Key) {
+	for _, e := range el {
+		for _, subKey := range e.Subkeys {
+			if subKey.PrivateKey != nil && (!subKey.Sig.FlagsValid || subKey.Sig.FlagEncryptStorage || subKey.Sig.FlagEncryptCommunications) {
+				keys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})
+			}
+		}
+	}
+	return
+}
+
+// ReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.
+func ReadArmoredKeyRing(r io.Reader) (EntityList, error) {
+	block, err := armor.Decode(r)
+	if err == io.EOF {
+		return nil, errors.InvalidArgumentError("no armored data found")
+	}
+	if err != nil {
+		return nil, err
+	}
+	if block.Type != PublicKeyType && block.Type != PrivateKeyType {
+		return nil, errors.InvalidArgumentError("expected public or private key block, got: " + block.Type)
+	}
+
+	return ReadKeyRing(block.Body)
+}
+
+// ReadKeyRing reads one or more public/private keys. Unsupported keys are
+// ignored as long as at least a single valid key is found.
+func ReadKeyRing(r io.Reader) (el EntityList, err error) {
+	packets := packet.NewReader(r)
+	var lastUnsupportedError error
+
+	for {
+		var e *Entity
+		e, err = ReadEntity(packets)
+		if err != nil {
+			// TODO: warn about skipped unsupported/unreadable keys
+			if _, ok := err.(errors.UnsupportedError); ok {
+				lastUnsupportedError = err
+				err = readToNextPublicKey(packets)
+			} else if _, ok := err.(errors.StructuralError); ok {
+				// Skip unreadable, badly-formatted keys
+				lastUnsupportedError = err
+				err = readToNextPublicKey(packets)
+			}
+			if err == io.EOF {
+				err = nil
+				break
+			}
+			if err != nil {
+				el = nil
+				break
+			}
+		} else {
+			el = append(el, e)
+		}
+	}
+
+	if len(el) == 0 && err == nil {
+		err = lastUnsupportedError
+	}
+	return
+}
+
+// readToNextPublicKey reads packets until the start of the entity and leaves
+// the first packet of the new entity in the Reader.
+func readToNextPublicKey(packets *packet.Reader) (err error) {
+	var p packet.Packet
+	for {
+		p, err = packets.Next()
+		if err == io.EOF {
+			return
+		} else if err != nil {
+			if _, ok := err.(errors.UnsupportedError); ok {
+				err = nil
+				continue
+			}
+			return
+		}
+
+		if pk, ok := p.(*packet.PublicKey); ok && !pk.IsSubkey {
+			packets.Unread(p)
+			return
+		}
+	}
+}
+
+// ReadEntity reads an entity (public key, identities, subkeys etc) from the
+// given Reader.
+func ReadEntity(packets *packet.Reader) (*Entity, error) {
+	e := new(Entity)
+	e.Identities = make(map[string]*Identity)
+
+	p, err := packets.Next()
+	if err != nil {
+		return nil, err
+	}
+
+	var ok bool
+	if e.PrimaryKey, ok = p.(*packet.PublicKey); !ok {
+		if e.PrivateKey, ok = p.(*packet.PrivateKey); !ok {
+			packets.Unread(p)
+			return nil, errors.StructuralError("first packet was not a public/private key")
+		}
+		e.PrimaryKey = &e.PrivateKey.PublicKey
+	}
+
+	if !e.PrimaryKey.PubKeyAlgo.CanSign() {
+		return nil, errors.StructuralError("primary key cannot be used for signatures")
+	}
+
+	var current *Identity
+	var revocations []*packet.Signature
+EachPacket:
+	for {
+		p, err := packets.Next()
+		if err == io.EOF {
+			break
+		} else if err != nil {
+			return nil, err
+		}
+
+		switch pkt := p.(type) {
+		case *packet.UserId:
+			current = new(Identity)
+			current.Name = pkt.Id
+			current.UserId = pkt
+			e.Identities[pkt.Id] = current
+
+			for {
+				p, err = packets.Next()
+				if err == io.EOF {
+					return nil, io.ErrUnexpectedEOF
+				} else if err != nil {
+					return nil, err
+				}
+
+				sig, ok := p.(*packet.Signature)
+				if !ok {
+					return nil, errors.StructuralError("user ID packet not followed by self-signature")
+				}
+
+				if (sig.SigType == packet.SigTypePositiveCert || sig.SigType == packet.SigTypeGenericCert) && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {
+					if err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, e.PrimaryKey, sig); err != nil {
+						return nil, errors.StructuralError("user ID self-signature invalid: " + err.Error())
+					}
+					current.SelfSignature = sig
+					break
+				}
+				current.Signatures = append(current.Signatures, sig)
+			}
+		case *packet.Signature:
+			if pkt.SigType == packet.SigTypeKeyRevocation {
+				revocations = append(revocations, pkt)
+			} else if pkt.SigType == packet.SigTypeDirectSignature {
+				// TODO: RFC4880 5.2.1 permits signatures
+				// directly on keys (eg. to bind additional
+				// revocation keys).
+			} else if current == nil {
+				return nil, errors.StructuralError("signature packet found before user id packet")
+			} else {
+				current.Signatures = append(current.Signatures, pkt)
+			}
+		case *packet.PrivateKey:
+			if pkt.IsSubkey == false {
+				packets.Unread(p)
+				break EachPacket
+			}
+			err = addSubkey(e, packets, &pkt.PublicKey, pkt)
+			if err != nil {
+				return nil, err
+			}
+		case *packet.PublicKey:
+			if pkt.IsSubkey == false {
+				packets.Unread(p)
+				break EachPacket
+			}
+			err = addSubkey(e, packets, pkt, nil)
+			if err != nil {
+				return nil, err
+			}
+		default:
+			// we ignore unknown packets
+		}
+	}
+
+	if len(e.Identities) == 0 {
+		return nil, errors.StructuralError("entity without any identities")
+	}
+
+	for _, revocation := range revocations {
+		err = e.PrimaryKey.VerifyRevocationSignature(revocation)
+		if err == nil {
+			e.Revocations = append(e.Revocations, revocation)
+		} else {
+			// TODO: RFC 4880 5.2.3.15 defines revocation keys.
+			return nil, errors.StructuralError("revocation signature signed by alternate key")
+		}
+	}
+
+	return e, nil
+}
+
+func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *packet.PrivateKey) error {
+	var subKey Subkey
+	subKey.PublicKey = pub
+	subKey.PrivateKey = priv
+	p, err := packets.Next()
+	if err == io.EOF {
+		return io.ErrUnexpectedEOF
+	}
+	if err != nil {
+		return errors.StructuralError("subkey signature invalid: " + err.Error())
+	}
+	var ok bool
+	subKey.Sig, ok = p.(*packet.Signature)
+	if !ok {
+		return errors.StructuralError("subkey packet not followed by signature")
+	}
+	if subKey.Sig.SigType != packet.SigTypeSubkeyBinding && subKey.Sig.SigType != packet.SigTypeSubkeyRevocation {
+		return errors.StructuralError("subkey signature with wrong type")
+	}
+	err = e.PrimaryKey.VerifyKeySignature(subKey.PublicKey, subKey.Sig)
+	if err != nil {
+		return errors.StructuralError("subkey signature invalid: " + err.Error())
+	}
+	e.Subkeys = append(e.Subkeys, subKey)
+	return nil
+}
+
+const defaultRSAKeyBits = 2048
+
+// NewEntity returns an Entity that contains a fresh RSA/RSA keypair with a
+// single identity composed of the given full name, comment and email, any of
+// which may be empty but must not contain any of "()<>\x00".
+// If config is nil, sensible defaults will be used.
+func NewEntity(name, comment, email string, config *packet.Config) (*Entity, error) {
+	currentTime := config.Now()
+
+	bits := defaultRSAKeyBits
+	if config != nil && config.RSABits != 0 {
+		bits = config.RSABits
+	}
+
+	uid := packet.NewUserId(name, comment, email)
+	if uid == nil {
+		return nil, errors.InvalidArgumentError("user id field contained invalid characters")
+	}
+	signingPriv, err := rsa.GenerateKey(config.Random(), bits)
+	if err != nil {
+		return nil, err
+	}
+	encryptingPriv, err := rsa.GenerateKey(config.Random(), bits)
+	if err != nil {
+		return nil, err
+	}
+
+	e := &Entity{
+		PrimaryKey: packet.NewRSAPublicKey(currentTime, &signingPriv.PublicKey),
+		PrivateKey: packet.NewRSAPrivateKey(currentTime, signingPriv),
+		Identities: make(map[string]*Identity),
+	}
+	isPrimaryId := true
+	e.Identities[uid.Id] = &Identity{
+		Name:   uid.Id,
+		UserId: uid,
+		SelfSignature: &packet.Signature{
+			CreationTime: currentTime,
+			SigType:      packet.SigTypePositiveCert,
+			PubKeyAlgo:   packet.PubKeyAlgoRSA,
+			Hash:         config.Hash(),
+			IsPrimaryId:  &isPrimaryId,
+			FlagsValid:   true,
+			FlagSign:     true,
+			FlagCertify:  true,
+			IssuerKeyId:  &e.PrimaryKey.KeyId,
+		},
+	}
+
+	// If the user passes in a DefaultHash via packet.Config,
+	// set the PreferredHash for the SelfSignature.
+	if config != nil && config.DefaultHash != 0 {
+		e.Identities[uid.Id].SelfSignature.PreferredHash = []uint8{hashToHashId(config.DefaultHash)}
+	}
+
+	// Likewise for DefaultCipher.
+	if config != nil && config.DefaultCipher != 0 {
+		e.Identities[uid.Id].SelfSignature.PreferredSymmetric = []uint8{uint8(config.DefaultCipher)}
+	}
+
+	e.Subkeys = make([]Subkey, 1)
+	e.Subkeys[0] = Subkey{
+		PublicKey:  packet.NewRSAPublicKey(currentTime, &encryptingPriv.PublicKey),
+		PrivateKey: packet.NewRSAPrivateKey(currentTime, encryptingPriv),
+		Sig: &packet.Signature{
+			CreationTime:              currentTime,
+			SigType:                   packet.SigTypeSubkeyBinding,
+			PubKeyAlgo:                packet.PubKeyAlgoRSA,
+			Hash:                      config.Hash(),
+			FlagsValid:                true,
+			FlagEncryptStorage:        true,
+			FlagEncryptCommunications: true,
+			IssuerKeyId:               &e.PrimaryKey.KeyId,
+		},
+	}
+	e.Subkeys[0].PublicKey.IsSubkey = true
+	e.Subkeys[0].PrivateKey.IsSubkey = true
+
+	return e, nil
+}
+
+// SerializePrivate serializes an Entity, including private key material, to
+// the given Writer. For now, it must only be used on an Entity returned from
+// NewEntity.
+// If config is nil, sensible defaults will be used.
+func (e *Entity) SerializePrivate(w io.Writer, config *packet.Config) (err error) {
+	err = e.PrivateKey.Serialize(w)
+	if err != nil {
+		return
+	}
+	for _, ident := range e.Identities {
+		err = ident.UserId.Serialize(w)
+		if err != nil {
+			return
+		}
+		err = ident.SelfSignature.SignUserId(ident.UserId.Id, e.PrimaryKey, e.PrivateKey, config)
+		if err != nil {
+			return
+		}
+		err = ident.SelfSignature.Serialize(w)
+		if err != nil {
+			return
+		}
+	}
+	for _, subkey := range e.Subkeys {
+		err = subkey.PrivateKey.Serialize(w)
+		if err != nil {
+			return
+		}
+		err = subkey.Sig.SignKey(subkey.PublicKey, e.PrivateKey, config)
+		if err != nil {
+			return
+		}
+		err = subkey.Sig.Serialize(w)
+		if err != nil {
+			return
+		}
+	}
+	return nil
+}
+
+// Serialize writes the public part of the given Entity to w. (No private
+// key material will be output).
+func (e *Entity) Serialize(w io.Writer) error {
+	err := e.PrimaryKey.Serialize(w)
+	if err != nil {
+		return err
+	}
+	for _, ident := range e.Identities {
+		err = ident.UserId.Serialize(w)
+		if err != nil {
+			return err
+		}
+		err = ident.SelfSignature.Serialize(w)
+		if err != nil {
+			return err
+		}
+		for _, sig := range ident.Signatures {
+			err = sig.Serialize(w)
+			if err != nil {
+				return err
+			}
+		}
+	}
+	for _, subkey := range e.Subkeys {
+		err = subkey.PublicKey.Serialize(w)
+		if err != nil {
+			return err
+		}
+		err = subkey.Sig.Serialize(w)
+		if err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+// SignIdentity adds a signature to e, from signer, attesting that identity is
+// associated with e. The provided identity must already be an element of
+// e.Identities and the private key of signer must have been decrypted if
+// necessary.
+// If config is nil, sensible defaults will be used.
+func (e *Entity) SignIdentity(identity string, signer *Entity, config *packet.Config) error {
+	if signer.PrivateKey == nil {
+		return errors.InvalidArgumentError("signing Entity must have a private key")
+	}
+	if signer.PrivateKey.Encrypted {
+		return errors.InvalidArgumentError("signing Entity's private key must be decrypted")
+	}
+	ident, ok := e.Identities[identity]
+	if !ok {
+		return errors.InvalidArgumentError("given identity string not found in Entity")
+	}
+
+	sig := &packet.Signature{
+		SigType:      packet.SigTypeGenericCert,
+		PubKeyAlgo:   signer.PrivateKey.PubKeyAlgo,
+		Hash:         config.Hash(),
+		CreationTime: config.Now(),
+		IssuerKeyId:  &signer.PrivateKey.KeyId,
+	}
+	if err := sig.SignUserId(identity, e.PrimaryKey, signer.PrivateKey, config); err != nil {
+		return err
+	}
+	ident.Signatures = append(ident.Signatures, sig)
+	return nil
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/compressed.go b/vendor/golang.org/x/crypto/openpgp/packet/compressed.go
new file mode 100644
index 0000000..e8f0b5c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/compressed.go
@@ -0,0 +1,123 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"compress/bzip2"
+	"compress/flate"
+	"compress/zlib"
+	"golang.org/x/crypto/openpgp/errors"
+	"io"
+	"strconv"
+)
+
+// Compressed represents a compressed OpenPGP packet. The decompressed contents
+// will contain more OpenPGP packets. See RFC 4880, section 5.6.
+type Compressed struct {
+	Body io.Reader
+}
+
+const (
+	NoCompression      = flate.NoCompression
+	BestSpeed          = flate.BestSpeed
+	BestCompression    = flate.BestCompression
+	DefaultCompression = flate.DefaultCompression
+)
+
+// CompressionConfig contains compressor configuration settings.
+type CompressionConfig struct {
+	// Level is the compression level to use. It must be set to
+	// between -1 and 9, with -1 causing the compressor to use the
+	// default compression level, 0 causing the compressor to use
+	// no compression and 1 to 9 representing increasing (better,
+	// slower) compression levels. If Level is less than -1 or
+	// more then 9, a non-nil error will be returned during
+	// encryption. See the constants above for convenient common
+	// settings for Level.
+	Level int
+}
+
+func (c *Compressed) parse(r io.Reader) error {
+	var buf [1]byte
+	_, err := readFull(r, buf[:])
+	if err != nil {
+		return err
+	}
+
+	switch buf[0] {
+	case 1:
+		c.Body = flate.NewReader(r)
+	case 2:
+		c.Body, err = zlib.NewReader(r)
+	case 3:
+		c.Body = bzip2.NewReader(r)
+	default:
+		err = errors.UnsupportedError("unknown compression algorithm: " + strconv.Itoa(int(buf[0])))
+	}
+
+	return err
+}
+
+// compressedWriterCloser represents the serialized compression stream
+// header and the compressor. Its Close() method ensures that both the
+// compressor and serialized stream header are closed. Its Write()
+// method writes to the compressor.
+type compressedWriteCloser struct {
+	sh io.Closer      // Stream Header
+	c  io.WriteCloser // Compressor
+}
+
+func (cwc compressedWriteCloser) Write(p []byte) (int, error) {
+	return cwc.c.Write(p)
+}
+
+func (cwc compressedWriteCloser) Close() (err error) {
+	err = cwc.c.Close()
+	if err != nil {
+		return err
+	}
+
+	return cwc.sh.Close()
+}
+
+// SerializeCompressed serializes a compressed data packet to w and
+// returns a WriteCloser to which the literal data packets themselves
+// can be written and which MUST be closed on completion. If cc is
+// nil, sensible defaults will be used to configure the compression
+// algorithm.
+func SerializeCompressed(w io.WriteCloser, algo CompressionAlgo, cc *CompressionConfig) (literaldata io.WriteCloser, err error) {
+	compressed, err := serializeStreamHeader(w, packetTypeCompressed)
+	if err != nil {
+		return
+	}
+
+	_, err = compressed.Write([]byte{uint8(algo)})
+	if err != nil {
+		return
+	}
+
+	level := DefaultCompression
+	if cc != nil {
+		level = cc.Level
+	}
+
+	var compressor io.WriteCloser
+	switch algo {
+	case CompressionZIP:
+		compressor, err = flate.NewWriter(compressed, level)
+	case CompressionZLIB:
+		compressor, err = zlib.NewWriterLevel(compressed, level)
+	default:
+		s := strconv.Itoa(int(algo))
+		err = errors.UnsupportedError("Unsupported compression algorithm: " + s)
+	}
+	if err != nil {
+		return
+	}
+
+	literaldata = compressedWriteCloser{compressed, compressor}
+
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/config.go b/vendor/golang.org/x/crypto/openpgp/packet/config.go
new file mode 100644
index 0000000..c76eecc
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/config.go
@@ -0,0 +1,91 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto"
+	"crypto/rand"
+	"io"
+	"time"
+)
+
+// Config collects a number of parameters along with sensible defaults.
+// A nil *Config is valid and results in all default values.
+type Config struct {
+	// Rand provides the source of entropy.
+	// If nil, the crypto/rand Reader is used.
+	Rand io.Reader
+	// DefaultHash is the default hash function to be used.
+	// If zero, SHA-256 is used.
+	DefaultHash crypto.Hash
+	// DefaultCipher is the cipher to be used.
+	// If zero, AES-128 is used.
+	DefaultCipher CipherFunction
+	// Time returns the current time as the number of seconds since the
+	// epoch. If Time is nil, time.Now is used.
+	Time func() time.Time
+	// DefaultCompressionAlgo is the compression algorithm to be
+	// applied to the plaintext before encryption. If zero, no
+	// compression is done.
+	DefaultCompressionAlgo CompressionAlgo
+	// CompressionConfig configures the compression settings.
+	CompressionConfig *CompressionConfig
+	// S2KCount is only used for symmetric encryption. It
+	// determines the strength of the passphrase stretching when
+	// the said passphrase is hashed to produce a key. S2KCount
+	// should be between 1024 and 65011712, inclusive. If Config
+	// is nil or S2KCount is 0, the value 65536 used. Not all
+	// values in the above range can be represented. S2KCount will
+	// be rounded up to the next representable value if it cannot
+	// be encoded exactly. When set, it is strongly encrouraged to
+	// use a value that is at least 65536. See RFC 4880 Section
+	// 3.7.1.3.
+	S2KCount int
+	// RSABits is the number of bits in new RSA keys made with NewEntity.
+	// If zero, then 2048 bit keys are created.
+	RSABits int
+}
+
+func (c *Config) Random() io.Reader {
+	if c == nil || c.Rand == nil {
+		return rand.Reader
+	}
+	return c.Rand
+}
+
+func (c *Config) Hash() crypto.Hash {
+	if c == nil || uint(c.DefaultHash) == 0 {
+		return crypto.SHA256
+	}
+	return c.DefaultHash
+}
+
+func (c *Config) Cipher() CipherFunction {
+	if c == nil || uint8(c.DefaultCipher) == 0 {
+		return CipherAES128
+	}
+	return c.DefaultCipher
+}
+
+func (c *Config) Now() time.Time {
+	if c == nil || c.Time == nil {
+		return time.Now()
+	}
+	return c.Time()
+}
+
+func (c *Config) Compression() CompressionAlgo {
+	if c == nil {
+		return CompressionNone
+	}
+	return c.DefaultCompressionAlgo
+}
+
+func (c *Config) PasswordHashIterations() int {
+	if c == nil || c.S2KCount == 0 {
+		return 0
+	}
+	return c.S2KCount
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/encrypted_key.go b/vendor/golang.org/x/crypto/openpgp/packet/encrypted_key.go
new file mode 100644
index 0000000..266840d
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/encrypted_key.go
@@ -0,0 +1,199 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto/rsa"
+	"encoding/binary"
+	"io"
+	"math/big"
+	"strconv"
+
+	"golang.org/x/crypto/openpgp/elgamal"
+	"golang.org/x/crypto/openpgp/errors"
+)
+
+const encryptedKeyVersion = 3
+
+// EncryptedKey represents a public-key encrypted session key. See RFC 4880,
+// section 5.1.
+type EncryptedKey struct {
+	KeyId      uint64
+	Algo       PublicKeyAlgorithm
+	CipherFunc CipherFunction // only valid after a successful Decrypt
+	Key        []byte         // only valid after a successful Decrypt
+
+	encryptedMPI1, encryptedMPI2 parsedMPI
+}
+
+func (e *EncryptedKey) parse(r io.Reader) (err error) {
+	var buf [10]byte
+	_, err = readFull(r, buf[:])
+	if err != nil {
+		return
+	}
+	if buf[0] != encryptedKeyVersion {
+		return errors.UnsupportedError("unknown EncryptedKey version " + strconv.Itoa(int(buf[0])))
+	}
+	e.KeyId = binary.BigEndian.Uint64(buf[1:9])
+	e.Algo = PublicKeyAlgorithm(buf[9])
+	switch e.Algo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:
+		e.encryptedMPI1.bytes, e.encryptedMPI1.bitLength, err = readMPI(r)
+	case PubKeyAlgoElGamal:
+		e.encryptedMPI1.bytes, e.encryptedMPI1.bitLength, err = readMPI(r)
+		if err != nil {
+			return
+		}
+		e.encryptedMPI2.bytes, e.encryptedMPI2.bitLength, err = readMPI(r)
+	}
+	_, err = consumeAll(r)
+	return
+}
+
+func checksumKeyMaterial(key []byte) uint16 {
+	var checksum uint16
+	for _, v := range key {
+		checksum += uint16(v)
+	}
+	return checksum
+}
+
+// Decrypt decrypts an encrypted session key with the given private key. The
+// private key must have been decrypted first.
+// If config is nil, sensible defaults will be used.
+func (e *EncryptedKey) Decrypt(priv *PrivateKey, config *Config) error {
+	var err error
+	var b []byte
+
+	// TODO(agl): use session key decryption routines here to avoid
+	// padding oracle attacks.
+	switch priv.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:
+		b, err = rsa.DecryptPKCS1v15(config.Random(), priv.PrivateKey.(*rsa.PrivateKey), e.encryptedMPI1.bytes)
+	case PubKeyAlgoElGamal:
+		c1 := new(big.Int).SetBytes(e.encryptedMPI1.bytes)
+		c2 := new(big.Int).SetBytes(e.encryptedMPI2.bytes)
+		b, err = elgamal.Decrypt(priv.PrivateKey.(*elgamal.PrivateKey), c1, c2)
+	default:
+		err = errors.InvalidArgumentError("cannot decrypted encrypted session key with private key of type " + strconv.Itoa(int(priv.PubKeyAlgo)))
+	}
+
+	if err != nil {
+		return err
+	}
+
+	e.CipherFunc = CipherFunction(b[0])
+	e.Key = b[1 : len(b)-2]
+	expectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])
+	checksum := checksumKeyMaterial(e.Key)
+	if checksum != expectedChecksum {
+		return errors.StructuralError("EncryptedKey checksum incorrect")
+	}
+
+	return nil
+}
+
+// Serialize writes the encrypted key packet, e, to w.
+func (e *EncryptedKey) Serialize(w io.Writer) error {
+	var mpiLen int
+	switch e.Algo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:
+		mpiLen = 2 + len(e.encryptedMPI1.bytes)
+	case PubKeyAlgoElGamal:
+		mpiLen = 2 + len(e.encryptedMPI1.bytes) + 2 + len(e.encryptedMPI2.bytes)
+	default:
+		return errors.InvalidArgumentError("don't know how to serialize encrypted key type " + strconv.Itoa(int(e.Algo)))
+	}
+
+	serializeHeader(w, packetTypeEncryptedKey, 1 /* version */ +8 /* key id */ +1 /* algo */ +mpiLen)
+
+	w.Write([]byte{encryptedKeyVersion})
+	binary.Write(w, binary.BigEndian, e.KeyId)
+	w.Write([]byte{byte(e.Algo)})
+
+	switch e.Algo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:
+		writeMPIs(w, e.encryptedMPI1)
+	case PubKeyAlgoElGamal:
+		writeMPIs(w, e.encryptedMPI1, e.encryptedMPI2)
+	default:
+		panic("internal error")
+	}
+
+	return nil
+}
+
+// SerializeEncryptedKey serializes an encrypted key packet to w that contains
+// key, encrypted to pub.
+// If config is nil, sensible defaults will be used.
+func SerializeEncryptedKey(w io.Writer, pub *PublicKey, cipherFunc CipherFunction, key []byte, config *Config) error {
+	var buf [10]byte
+	buf[0] = encryptedKeyVersion
+	binary.BigEndian.PutUint64(buf[1:9], pub.KeyId)
+	buf[9] = byte(pub.PubKeyAlgo)
+
+	keyBlock := make([]byte, 1 /* cipher type */ +len(key)+2 /* checksum */)
+	keyBlock[0] = byte(cipherFunc)
+	copy(keyBlock[1:], key)
+	checksum := checksumKeyMaterial(key)
+	keyBlock[1+len(key)] = byte(checksum >> 8)
+	keyBlock[1+len(key)+1] = byte(checksum)
+
+	switch pub.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly:
+		return serializeEncryptedKeyRSA(w, config.Random(), buf, pub.PublicKey.(*rsa.PublicKey), keyBlock)
+	case PubKeyAlgoElGamal:
+		return serializeEncryptedKeyElGamal(w, config.Random(), buf, pub.PublicKey.(*elgamal.PublicKey), keyBlock)
+	case PubKeyAlgoDSA, PubKeyAlgoRSASignOnly:
+		return errors.InvalidArgumentError("cannot encrypt to public key of type " + strconv.Itoa(int(pub.PubKeyAlgo)))
+	}
+
+	return errors.UnsupportedError("encrypting a key to public key of type " + strconv.Itoa(int(pub.PubKeyAlgo)))
+}
+
+func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) error {
+	cipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)
+	if err != nil {
+		return errors.InvalidArgumentError("RSA encryption failed: " + err.Error())
+	}
+
+	packetLen := 10 /* header length */ + 2 /* mpi size */ + len(cipherText)
+
+	err = serializeHeader(w, packetTypeEncryptedKey, packetLen)
+	if err != nil {
+		return err
+	}
+	_, err = w.Write(header[:])
+	if err != nil {
+		return err
+	}
+	return writeMPI(w, 8*uint16(len(cipherText)), cipherText)
+}
+
+func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) error {
+	c1, c2, err := elgamal.Encrypt(rand, pub, keyBlock)
+	if err != nil {
+		return errors.InvalidArgumentError("ElGamal encryption failed: " + err.Error())
+	}
+
+	packetLen := 10 /* header length */
+	packetLen += 2 /* mpi size */ + (c1.BitLen()+7)/8
+	packetLen += 2 /* mpi size */ + (c2.BitLen()+7)/8
+
+	err = serializeHeader(w, packetTypeEncryptedKey, packetLen)
+	if err != nil {
+		return err
+	}
+	_, err = w.Write(header[:])
+	if err != nil {
+		return err
+	}
+	err = writeBig(w, c1)
+	if err != nil {
+		return err
+	}
+	return writeBig(w, c2)
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/literal.go b/vendor/golang.org/x/crypto/openpgp/packet/literal.go
new file mode 100644
index 0000000..1a9ec6e
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/literal.go
@@ -0,0 +1,89 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"encoding/binary"
+	"io"
+)
+
+// LiteralData represents an encrypted file. See RFC 4880, section 5.9.
+type LiteralData struct {
+	IsBinary bool
+	FileName string
+	Time     uint32 // Unix epoch time. Either creation time or modification time. 0 means undefined.
+	Body     io.Reader
+}
+
+// ForEyesOnly returns whether the contents of the LiteralData have been marked
+// as especially sensitive.
+func (l *LiteralData) ForEyesOnly() bool {
+	return l.FileName == "_CONSOLE"
+}
+
+func (l *LiteralData) parse(r io.Reader) (err error) {
+	var buf [256]byte
+
+	_, err = readFull(r, buf[:2])
+	if err != nil {
+		return
+	}
+
+	l.IsBinary = buf[0] == 'b'
+	fileNameLen := int(buf[1])
+
+	_, err = readFull(r, buf[:fileNameLen])
+	if err != nil {
+		return
+	}
+
+	l.FileName = string(buf[:fileNameLen])
+
+	_, err = readFull(r, buf[:4])
+	if err != nil {
+		return
+	}
+
+	l.Time = binary.BigEndian.Uint32(buf[:4])
+	l.Body = r
+	return
+}
+
+// SerializeLiteral serializes a literal data packet to w and returns a
+// WriteCloser to which the data itself can be written and which MUST be closed
+// on completion. The fileName is truncated to 255 bytes.
+func SerializeLiteral(w io.WriteCloser, isBinary bool, fileName string, time uint32) (plaintext io.WriteCloser, err error) {
+	var buf [4]byte
+	buf[0] = 't'
+	if isBinary {
+		buf[0] = 'b'
+	}
+	if len(fileName) > 255 {
+		fileName = fileName[:255]
+	}
+	buf[1] = byte(len(fileName))
+
+	inner, err := serializeStreamHeader(w, packetTypeLiteralData)
+	if err != nil {
+		return
+	}
+
+	_, err = inner.Write(buf[:2])
+	if err != nil {
+		return
+	}
+	_, err = inner.Write([]byte(fileName))
+	if err != nil {
+		return
+	}
+	binary.BigEndian.PutUint32(buf[:], time)
+	_, err = inner.Write(buf[:])
+	if err != nil {
+		return
+	}
+
+	plaintext = inner
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/ocfb.go b/vendor/golang.org/x/crypto/openpgp/packet/ocfb.go
new file mode 100644
index 0000000..ce2a33a
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/ocfb.go
@@ -0,0 +1,143 @@
+// Copyright 2010 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// OpenPGP CFB Mode. http://tools.ietf.org/html/rfc4880#section-13.9
+
+package packet
+
+import (
+	"crypto/cipher"
+)
+
+type ocfbEncrypter struct {
+	b       cipher.Block
+	fre     []byte
+	outUsed int
+}
+
+// An OCFBResyncOption determines if the "resynchronization step" of OCFB is
+// performed.
+type OCFBResyncOption bool
+
+const (
+	OCFBResync   OCFBResyncOption = true
+	OCFBNoResync OCFBResyncOption = false
+)
+
+// NewOCFBEncrypter returns a cipher.Stream which encrypts data with OpenPGP's
+// cipher feedback mode using the given cipher.Block, and an initial amount of
+// ciphertext.  randData must be random bytes and be the same length as the
+// cipher.Block's block size. Resync determines if the "resynchronization step"
+// from RFC 4880, 13.9 step 7 is performed. Different parts of OpenPGP vary on
+// this point.
+func NewOCFBEncrypter(block cipher.Block, randData []byte, resync OCFBResyncOption) (cipher.Stream, []byte) {
+	blockSize := block.BlockSize()
+	if len(randData) != blockSize {
+		return nil, nil
+	}
+
+	x := &ocfbEncrypter{
+		b:       block,
+		fre:     make([]byte, blockSize),
+		outUsed: 0,
+	}
+	prefix := make([]byte, blockSize+2)
+
+	block.Encrypt(x.fre, x.fre)
+	for i := 0; i < blockSize; i++ {
+		prefix[i] = randData[i] ^ x.fre[i]
+	}
+
+	block.Encrypt(x.fre, prefix[:blockSize])
+	prefix[blockSize] = x.fre[0] ^ randData[blockSize-2]
+	prefix[blockSize+1] = x.fre[1] ^ randData[blockSize-1]
+
+	if resync {
+		block.Encrypt(x.fre, prefix[2:])
+	} else {
+		x.fre[0] = prefix[blockSize]
+		x.fre[1] = prefix[blockSize+1]
+		x.outUsed = 2
+	}
+	return x, prefix
+}
+
+func (x *ocfbEncrypter) XORKeyStream(dst, src []byte) {
+	for i := 0; i < len(src); i++ {
+		if x.outUsed == len(x.fre) {
+			x.b.Encrypt(x.fre, x.fre)
+			x.outUsed = 0
+		}
+
+		x.fre[x.outUsed] ^= src[i]
+		dst[i] = x.fre[x.outUsed]
+		x.outUsed++
+	}
+}
+
+type ocfbDecrypter struct {
+	b       cipher.Block
+	fre     []byte
+	outUsed int
+}
+
+// NewOCFBDecrypter returns a cipher.Stream which decrypts data with OpenPGP's
+// cipher feedback mode using the given cipher.Block. Prefix must be the first
+// blockSize + 2 bytes of the ciphertext, where blockSize is the cipher.Block's
+// block size. If an incorrect key is detected then nil is returned. On
+// successful exit, blockSize+2 bytes of decrypted data are written into
+// prefix. Resync determines if the "resynchronization step" from RFC 4880,
+// 13.9 step 7 is performed. Different parts of OpenPGP vary on this point.
+func NewOCFBDecrypter(block cipher.Block, prefix []byte, resync OCFBResyncOption) cipher.Stream {
+	blockSize := block.BlockSize()
+	if len(prefix) != blockSize+2 {
+		return nil
+	}
+
+	x := &ocfbDecrypter{
+		b:       block,
+		fre:     make([]byte, blockSize),
+		outUsed: 0,
+	}
+	prefixCopy := make([]byte, len(prefix))
+	copy(prefixCopy, prefix)
+
+	block.Encrypt(x.fre, x.fre)
+	for i := 0; i < blockSize; i++ {
+		prefixCopy[i] ^= x.fre[i]
+	}
+
+	block.Encrypt(x.fre, prefix[:blockSize])
+	prefixCopy[blockSize] ^= x.fre[0]
+	prefixCopy[blockSize+1] ^= x.fre[1]
+
+	if prefixCopy[blockSize-2] != prefixCopy[blockSize] ||
+		prefixCopy[blockSize-1] != prefixCopy[blockSize+1] {
+		return nil
+	}
+
+	if resync {
+		block.Encrypt(x.fre, prefix[2:])
+	} else {
+		x.fre[0] = prefix[blockSize]
+		x.fre[1] = prefix[blockSize+1]
+		x.outUsed = 2
+	}
+	copy(prefix, prefixCopy)
+	return x
+}
+
+func (x *ocfbDecrypter) XORKeyStream(dst, src []byte) {
+	for i := 0; i < len(src); i++ {
+		if x.outUsed == len(x.fre) {
+			x.b.Encrypt(x.fre, x.fre)
+			x.outUsed = 0
+		}
+
+		c := src[i]
+		dst[i] = x.fre[x.outUsed] ^ src[i]
+		x.fre[x.outUsed] = c
+		x.outUsed++
+	}
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/one_pass_signature.go b/vendor/golang.org/x/crypto/openpgp/packet/one_pass_signature.go
new file mode 100644
index 0000000..1713503
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/one_pass_signature.go
@@ -0,0 +1,73 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto"
+	"encoding/binary"
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/s2k"
+	"io"
+	"strconv"
+)
+
+// OnePassSignature represents a one-pass signature packet. See RFC 4880,
+// section 5.4.
+type OnePassSignature struct {
+	SigType    SignatureType
+	Hash       crypto.Hash
+	PubKeyAlgo PublicKeyAlgorithm
+	KeyId      uint64
+	IsLast     bool
+}
+
+const onePassSignatureVersion = 3
+
+func (ops *OnePassSignature) parse(r io.Reader) (err error) {
+	var buf [13]byte
+
+	_, err = readFull(r, buf[:])
+	if err != nil {
+		return
+	}
+	if buf[0] != onePassSignatureVersion {
+		err = errors.UnsupportedError("one-pass-signature packet version " + strconv.Itoa(int(buf[0])))
+	}
+
+	var ok bool
+	ops.Hash, ok = s2k.HashIdToHash(buf[2])
+	if !ok {
+		return errors.UnsupportedError("hash function: " + strconv.Itoa(int(buf[2])))
+	}
+
+	ops.SigType = SignatureType(buf[1])
+	ops.PubKeyAlgo = PublicKeyAlgorithm(buf[3])
+	ops.KeyId = binary.BigEndian.Uint64(buf[4:12])
+	ops.IsLast = buf[12] != 0
+	return
+}
+
+// Serialize marshals the given OnePassSignature to w.
+func (ops *OnePassSignature) Serialize(w io.Writer) error {
+	var buf [13]byte
+	buf[0] = onePassSignatureVersion
+	buf[1] = uint8(ops.SigType)
+	var ok bool
+	buf[2], ok = s2k.HashToHashId(ops.Hash)
+	if !ok {
+		return errors.UnsupportedError("hash type: " + strconv.Itoa(int(ops.Hash)))
+	}
+	buf[3] = uint8(ops.PubKeyAlgo)
+	binary.BigEndian.PutUint64(buf[4:12], ops.KeyId)
+	if ops.IsLast {
+		buf[12] = 1
+	}
+
+	if err := serializeHeader(w, packetTypeOnePassSignature, len(buf)); err != nil {
+		return err
+	}
+	_, err := w.Write(buf[:])
+	return err
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/opaque.go b/vendor/golang.org/x/crypto/openpgp/packet/opaque.go
new file mode 100644
index 0000000..456d807
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/opaque.go
@@ -0,0 +1,162 @@
+// Copyright 2012 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"io"
+	"io/ioutil"
+
+	"golang.org/x/crypto/openpgp/errors"
+)
+
+// OpaquePacket represents an OpenPGP packet as raw, unparsed data. This is
+// useful for splitting and storing the original packet contents separately,
+// handling unsupported packet types or accessing parts of the packet not yet
+// implemented by this package.
+type OpaquePacket struct {
+	// Packet type
+	Tag uint8
+	// Reason why the packet was parsed opaquely
+	Reason error
+	// Binary contents of the packet data
+	Contents []byte
+}
+
+func (op *OpaquePacket) parse(r io.Reader) (err error) {
+	op.Contents, err = ioutil.ReadAll(r)
+	return
+}
+
+// Serialize marshals the packet to a writer in its original form, including
+// the packet header.
+func (op *OpaquePacket) Serialize(w io.Writer) (err error) {
+	err = serializeHeader(w, packetType(op.Tag), len(op.Contents))
+	if err == nil {
+		_, err = w.Write(op.Contents)
+	}
+	return
+}
+
+// Parse attempts to parse the opaque contents into a structure supported by
+// this package. If the packet is not known then the result will be another
+// OpaquePacket.
+func (op *OpaquePacket) Parse() (p Packet, err error) {
+	hdr := bytes.NewBuffer(nil)
+	err = serializeHeader(hdr, packetType(op.Tag), len(op.Contents))
+	if err != nil {
+		op.Reason = err
+		return op, err
+	}
+	p, err = Read(io.MultiReader(hdr, bytes.NewBuffer(op.Contents)))
+	if err != nil {
+		op.Reason = err
+		p = op
+	}
+	return
+}
+
+// OpaqueReader reads OpaquePackets from an io.Reader.
+type OpaqueReader struct {
+	r io.Reader
+}
+
+func NewOpaqueReader(r io.Reader) *OpaqueReader {
+	return &OpaqueReader{r: r}
+}
+
+// Read the next OpaquePacket.
+func (or *OpaqueReader) Next() (op *OpaquePacket, err error) {
+	tag, _, contents, err := readHeader(or.r)
+	if err != nil {
+		return
+	}
+	op = &OpaquePacket{Tag: uint8(tag), Reason: err}
+	err = op.parse(contents)
+	if err != nil {
+		consumeAll(contents)
+	}
+	return
+}
+
+// OpaqueSubpacket represents an unparsed OpenPGP subpacket,
+// as found in signature and user attribute packets.
+type OpaqueSubpacket struct {
+	SubType  uint8
+	Contents []byte
+}
+
+// OpaqueSubpackets extracts opaque, unparsed OpenPGP subpackets from
+// their byte representation.
+func OpaqueSubpackets(contents []byte) (result []*OpaqueSubpacket, err error) {
+	var (
+		subHeaderLen int
+		subPacket    *OpaqueSubpacket
+	)
+	for len(contents) > 0 {
+		subHeaderLen, subPacket, err = nextSubpacket(contents)
+		if err != nil {
+			break
+		}
+		result = append(result, subPacket)
+		contents = contents[subHeaderLen+len(subPacket.Contents):]
+	}
+	return
+}
+
+func nextSubpacket(contents []byte) (subHeaderLen int, subPacket *OpaqueSubpacket, err error) {
+	// RFC 4880, section 5.2.3.1
+	var subLen uint32
+	if len(contents) < 1 {
+		goto Truncated
+	}
+	subPacket = &OpaqueSubpacket{}
+	switch {
+	case contents[0] < 192:
+		subHeaderLen = 2 // 1 length byte, 1 subtype byte
+		if len(contents) < subHeaderLen {
+			goto Truncated
+		}
+		subLen = uint32(contents[0])
+		contents = contents[1:]
+	case contents[0] < 255:
+		subHeaderLen = 3 // 2 length bytes, 1 subtype
+		if len(contents) < subHeaderLen {
+			goto Truncated
+		}
+		subLen = uint32(contents[0]-192)<<8 + uint32(contents[1]) + 192
+		contents = contents[2:]
+	default:
+		subHeaderLen = 6 // 5 length bytes, 1 subtype
+		if len(contents) < subHeaderLen {
+			goto Truncated
+		}
+		subLen = uint32(contents[1])<<24 |
+			uint32(contents[2])<<16 |
+			uint32(contents[3])<<8 |
+			uint32(contents[4])
+		contents = contents[5:]
+	}
+	if subLen > uint32(len(contents)) || subLen == 0 {
+		goto Truncated
+	}
+	subPacket.SubType = contents[0]
+	subPacket.Contents = contents[1:subLen]
+	return
+Truncated:
+	err = errors.StructuralError("subpacket truncated")
+	return
+}
+
+func (osp *OpaqueSubpacket) Serialize(w io.Writer) (err error) {
+	buf := make([]byte, 6)
+	n := serializeSubpacketLength(buf, len(osp.Contents)+1)
+	buf[n] = osp.SubType
+	if _, err = w.Write(buf[:n+1]); err != nil {
+		return
+	}
+	_, err = w.Write(osp.Contents)
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/packet.go b/vendor/golang.org/x/crypto/openpgp/packet/packet.go
new file mode 100644
index 0000000..3eded93
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/packet.go
@@ -0,0 +1,537 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package packet implements parsing and serialization of OpenPGP packets, as
+// specified in RFC 4880.
+package packet // import "golang.org/x/crypto/openpgp/packet"
+
+import (
+	"bufio"
+	"crypto/aes"
+	"crypto/cipher"
+	"crypto/des"
+	"golang.org/x/crypto/cast5"
+	"golang.org/x/crypto/openpgp/errors"
+	"io"
+	"math/big"
+)
+
+// readFull is the same as io.ReadFull except that reading zero bytes returns
+// ErrUnexpectedEOF rather than EOF.
+func readFull(r io.Reader, buf []byte) (n int, err error) {
+	n, err = io.ReadFull(r, buf)
+	if err == io.EOF {
+		err = io.ErrUnexpectedEOF
+	}
+	return
+}
+
+// readLength reads an OpenPGP length from r. See RFC 4880, section 4.2.2.
+func readLength(r io.Reader) (length int64, isPartial bool, err error) {
+	var buf [4]byte
+	_, err = readFull(r, buf[:1])
+	if err != nil {
+		return
+	}
+	switch {
+	case buf[0] < 192:
+		length = int64(buf[0])
+	case buf[0] < 224:
+		length = int64(buf[0]-192) << 8
+		_, err = readFull(r, buf[0:1])
+		if err != nil {
+			return
+		}
+		length += int64(buf[0]) + 192
+	case buf[0] < 255:
+		length = int64(1) << (buf[0] & 0x1f)
+		isPartial = true
+	default:
+		_, err = readFull(r, buf[0:4])
+		if err != nil {
+			return
+		}
+		length = int64(buf[0])<<24 |
+			int64(buf[1])<<16 |
+			int64(buf[2])<<8 |
+			int64(buf[3])
+	}
+	return
+}
+
+// partialLengthReader wraps an io.Reader and handles OpenPGP partial lengths.
+// The continuation lengths are parsed and removed from the stream and EOF is
+// returned at the end of the packet. See RFC 4880, section 4.2.2.4.
+type partialLengthReader struct {
+	r         io.Reader
+	remaining int64
+	isPartial bool
+}
+
+func (r *partialLengthReader) Read(p []byte) (n int, err error) {
+	for r.remaining == 0 {
+		if !r.isPartial {
+			return 0, io.EOF
+		}
+		r.remaining, r.isPartial, err = readLength(r.r)
+		if err != nil {
+			return 0, err
+		}
+	}
+
+	toRead := int64(len(p))
+	if toRead > r.remaining {
+		toRead = r.remaining
+	}
+
+	n, err = r.r.Read(p[:int(toRead)])
+	r.remaining -= int64(n)
+	if n < int(toRead) && err == io.EOF {
+		err = io.ErrUnexpectedEOF
+	}
+	return
+}
+
+// partialLengthWriter writes a stream of data using OpenPGP partial lengths.
+// See RFC 4880, section 4.2.2.4.
+type partialLengthWriter struct {
+	w          io.WriteCloser
+	lengthByte [1]byte
+}
+
+func (w *partialLengthWriter) Write(p []byte) (n int, err error) {
+	for len(p) > 0 {
+		for power := uint(14); power < 32; power-- {
+			l := 1 << power
+			if len(p) >= l {
+				w.lengthByte[0] = 224 + uint8(power)
+				_, err = w.w.Write(w.lengthByte[:])
+				if err != nil {
+					return
+				}
+				var m int
+				m, err = w.w.Write(p[:l])
+				n += m
+				if err != nil {
+					return
+				}
+				p = p[l:]
+				break
+			}
+		}
+	}
+	return
+}
+
+func (w *partialLengthWriter) Close() error {
+	w.lengthByte[0] = 0
+	_, err := w.w.Write(w.lengthByte[:])
+	if err != nil {
+		return err
+	}
+	return w.w.Close()
+}
+
+// A spanReader is an io.LimitReader, but it returns ErrUnexpectedEOF if the
+// underlying Reader returns EOF before the limit has been reached.
+type spanReader struct {
+	r io.Reader
+	n int64
+}
+
+func (l *spanReader) Read(p []byte) (n int, err error) {
+	if l.n <= 0 {
+		return 0, io.EOF
+	}
+	if int64(len(p)) > l.n {
+		p = p[0:l.n]
+	}
+	n, err = l.r.Read(p)
+	l.n -= int64(n)
+	if l.n > 0 && err == io.EOF {
+		err = io.ErrUnexpectedEOF
+	}
+	return
+}
+
+// readHeader parses a packet header and returns an io.Reader which will return
+// the contents of the packet. See RFC 4880, section 4.2.
+func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader, err error) {
+	var buf [4]byte
+	_, err = io.ReadFull(r, buf[:1])
+	if err != nil {
+		return
+	}
+	if buf[0]&0x80 == 0 {
+		err = errors.StructuralError("tag byte does not have MSB set")
+		return
+	}
+	if buf[0]&0x40 == 0 {
+		// Old format packet
+		tag = packetType((buf[0] & 0x3f) >> 2)
+		lengthType := buf[0] & 3
+		if lengthType == 3 {
+			length = -1
+			contents = r
+			return
+		}
+		lengthBytes := 1 << lengthType
+		_, err = readFull(r, buf[0:lengthBytes])
+		if err != nil {
+			return
+		}
+		for i := 0; i < lengthBytes; i++ {
+			length <<= 8
+			length |= int64(buf[i])
+		}
+		contents = &spanReader{r, length}
+		return
+	}
+
+	// New format packet
+	tag = packetType(buf[0] & 0x3f)
+	length, isPartial, err := readLength(r)
+	if err != nil {
+		return
+	}
+	if isPartial {
+		contents = &partialLengthReader{
+			remaining: length,
+			isPartial: true,
+			r:         r,
+		}
+		length = -1
+	} else {
+		contents = &spanReader{r, length}
+	}
+	return
+}
+
+// serializeHeader writes an OpenPGP packet header to w. See RFC 4880, section
+// 4.2.
+func serializeHeader(w io.Writer, ptype packetType, length int) (err error) {
+	var buf [6]byte
+	var n int
+
+	buf[0] = 0x80 | 0x40 | byte(ptype)
+	if length < 192 {
+		buf[1] = byte(length)
+		n = 2
+	} else if length < 8384 {
+		length -= 192
+		buf[1] = 192 + byte(length>>8)
+		buf[2] = byte(length)
+		n = 3
+	} else {
+		buf[1] = 255
+		buf[2] = byte(length >> 24)
+		buf[3] = byte(length >> 16)
+		buf[4] = byte(length >> 8)
+		buf[5] = byte(length)
+		n = 6
+	}
+
+	_, err = w.Write(buf[:n])
+	return
+}
+
+// serializeStreamHeader writes an OpenPGP packet header to w where the
+// length of the packet is unknown. It returns a io.WriteCloser which can be
+// used to write the contents of the packet. See RFC 4880, section 4.2.
+func serializeStreamHeader(w io.WriteCloser, ptype packetType) (out io.WriteCloser, err error) {
+	var buf [1]byte
+	buf[0] = 0x80 | 0x40 | byte(ptype)
+	_, err = w.Write(buf[:])
+	if err != nil {
+		return
+	}
+	out = &partialLengthWriter{w: w}
+	return
+}
+
+// Packet represents an OpenPGP packet. Users are expected to try casting
+// instances of this interface to specific packet types.
+type Packet interface {
+	parse(io.Reader) error
+}
+
+// consumeAll reads from the given Reader until error, returning the number of
+// bytes read.
+func consumeAll(r io.Reader) (n int64, err error) {
+	var m int
+	var buf [1024]byte
+
+	for {
+		m, err = r.Read(buf[:])
+		n += int64(m)
+		if err == io.EOF {
+			err = nil
+			return
+		}
+		if err != nil {
+			return
+		}
+	}
+}
+
+// packetType represents the numeric ids of the different OpenPGP packet types. See
+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-2
+type packetType uint8
+
+const (
+	packetTypeEncryptedKey              packetType = 1
+	packetTypeSignature                 packetType = 2
+	packetTypeSymmetricKeyEncrypted     packetType = 3
+	packetTypeOnePassSignature          packetType = 4
+	packetTypePrivateKey                packetType = 5
+	packetTypePublicKey                 packetType = 6
+	packetTypePrivateSubkey             packetType = 7
+	packetTypeCompressed                packetType = 8
+	packetTypeSymmetricallyEncrypted    packetType = 9
+	packetTypeLiteralData               packetType = 11
+	packetTypeUserId                    packetType = 13
+	packetTypePublicSubkey              packetType = 14
+	packetTypeUserAttribute             packetType = 17
+	packetTypeSymmetricallyEncryptedMDC packetType = 18
+)
+
+// peekVersion detects the version of a public key packet about to
+// be read. A bufio.Reader at the original position of the io.Reader
+// is returned.
+func peekVersion(r io.Reader) (bufr *bufio.Reader, ver byte, err error) {
+	bufr = bufio.NewReader(r)
+	var verBuf []byte
+	if verBuf, err = bufr.Peek(1); err != nil {
+		return
+	}
+	ver = verBuf[0]
+	return
+}
+
+// Read reads a single OpenPGP packet from the given io.Reader. If there is an
+// error parsing a packet, the whole packet is consumed from the input.
+func Read(r io.Reader) (p Packet, err error) {
+	tag, _, contents, err := readHeader(r)
+	if err != nil {
+		return
+	}
+
+	switch tag {
+	case packetTypeEncryptedKey:
+		p = new(EncryptedKey)
+	case packetTypeSignature:
+		var version byte
+		// Detect signature version
+		if contents, version, err = peekVersion(contents); err != nil {
+			return
+		}
+		if version < 4 {
+			p = new(SignatureV3)
+		} else {
+			p = new(Signature)
+		}
+	case packetTypeSymmetricKeyEncrypted:
+		p = new(SymmetricKeyEncrypted)
+	case packetTypeOnePassSignature:
+		p = new(OnePassSignature)
+	case packetTypePrivateKey, packetTypePrivateSubkey:
+		pk := new(PrivateKey)
+		if tag == packetTypePrivateSubkey {
+			pk.IsSubkey = true
+		}
+		p = pk
+	case packetTypePublicKey, packetTypePublicSubkey:
+		var version byte
+		if contents, version, err = peekVersion(contents); err != nil {
+			return
+		}
+		isSubkey := tag == packetTypePublicSubkey
+		if version < 4 {
+			p = &PublicKeyV3{IsSubkey: isSubkey}
+		} else {
+			p = &PublicKey{IsSubkey: isSubkey}
+		}
+	case packetTypeCompressed:
+		p = new(Compressed)
+	case packetTypeSymmetricallyEncrypted:
+		p = new(SymmetricallyEncrypted)
+	case packetTypeLiteralData:
+		p = new(LiteralData)
+	case packetTypeUserId:
+		p = new(UserId)
+	case packetTypeUserAttribute:
+		p = new(UserAttribute)
+	case packetTypeSymmetricallyEncryptedMDC:
+		se := new(SymmetricallyEncrypted)
+		se.MDC = true
+		p = se
+	default:
+		err = errors.UnknownPacketTypeError(tag)
+	}
+	if p != nil {
+		err = p.parse(contents)
+	}
+	if err != nil {
+		consumeAll(contents)
+	}
+	return
+}
+
+// SignatureType represents the different semantic meanings of an OpenPGP
+// signature. See RFC 4880, section 5.2.1.
+type SignatureType uint8
+
+const (
+	SigTypeBinary            SignatureType = 0
+	SigTypeText                            = 1
+	SigTypeGenericCert                     = 0x10
+	SigTypePersonaCert                     = 0x11
+	SigTypeCasualCert                      = 0x12
+	SigTypePositiveCert                    = 0x13
+	SigTypeSubkeyBinding                   = 0x18
+	SigTypePrimaryKeyBinding               = 0x19
+	SigTypeDirectSignature                 = 0x1F
+	SigTypeKeyRevocation                   = 0x20
+	SigTypeSubkeyRevocation                = 0x28
+)
+
+// PublicKeyAlgorithm represents the different public key system specified for
+// OpenPGP. See
+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-12
+type PublicKeyAlgorithm uint8
+
+const (
+	PubKeyAlgoRSA            PublicKeyAlgorithm = 1
+	PubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2
+	PubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3
+	PubKeyAlgoElGamal        PublicKeyAlgorithm = 16
+	PubKeyAlgoDSA            PublicKeyAlgorithm = 17
+	// RFC 6637, Section 5.
+	PubKeyAlgoECDH  PublicKeyAlgorithm = 18
+	PubKeyAlgoECDSA PublicKeyAlgorithm = 19
+)
+
+// CanEncrypt returns true if it's possible to encrypt a message to a public
+// key of the given type.
+func (pka PublicKeyAlgorithm) CanEncrypt() bool {
+	switch pka {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoElGamal:
+		return true
+	}
+	return false
+}
+
+// CanSign returns true if it's possible for a public key of the given type to
+// sign a message.
+func (pka PublicKeyAlgorithm) CanSign() bool {
+	switch pka {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA, PubKeyAlgoECDSA:
+		return true
+	}
+	return false
+}
+
+// CipherFunction represents the different block ciphers specified for OpenPGP. See
+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-13
+type CipherFunction uint8
+
+const (
+	Cipher3DES   CipherFunction = 2
+	CipherCAST5  CipherFunction = 3
+	CipherAES128 CipherFunction = 7
+	CipherAES192 CipherFunction = 8
+	CipherAES256 CipherFunction = 9
+)
+
+// KeySize returns the key size, in bytes, of cipher.
+func (cipher CipherFunction) KeySize() int {
+	switch cipher {
+	case Cipher3DES:
+		return 24
+	case CipherCAST5:
+		return cast5.KeySize
+	case CipherAES128:
+		return 16
+	case CipherAES192:
+		return 24
+	case CipherAES256:
+		return 32
+	}
+	return 0
+}
+
+// blockSize returns the block size, in bytes, of cipher.
+func (cipher CipherFunction) blockSize() int {
+	switch cipher {
+	case Cipher3DES:
+		return des.BlockSize
+	case CipherCAST5:
+		return 8
+	case CipherAES128, CipherAES192, CipherAES256:
+		return 16
+	}
+	return 0
+}
+
+// new returns a fresh instance of the given cipher.
+func (cipher CipherFunction) new(key []byte) (block cipher.Block) {
+	switch cipher {
+	case Cipher3DES:
+		block, _ = des.NewTripleDESCipher(key)
+	case CipherCAST5:
+		block, _ = cast5.NewCipher(key)
+	case CipherAES128, CipherAES192, CipherAES256:
+		block, _ = aes.NewCipher(key)
+	}
+	return
+}
+
+// readMPI reads a big integer from r. The bit length returned is the bit
+// length that was specified in r. This is preserved so that the integer can be
+// reserialized exactly.
+func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err error) {
+	var buf [2]byte
+	_, err = readFull(r, buf[0:])
+	if err != nil {
+		return
+	}
+	bitLength = uint16(buf[0])<<8 | uint16(buf[1])
+	numBytes := (int(bitLength) + 7) / 8
+	mpi = make([]byte, numBytes)
+	_, err = readFull(r, mpi)
+	return
+}
+
+// mpiLength returns the length of the given *big.Int when serialized as an
+// MPI.
+func mpiLength(n *big.Int) (mpiLengthInBytes int) {
+	mpiLengthInBytes = 2 /* MPI length */
+	mpiLengthInBytes += (n.BitLen() + 7) / 8
+	return
+}
+
+// writeMPI serializes a big integer to w.
+func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err error) {
+	_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})
+	if err == nil {
+		_, err = w.Write(mpiBytes)
+	}
+	return
+}
+
+// writeBig serializes a *big.Int to w.
+func writeBig(w io.Writer, i *big.Int) error {
+	return writeMPI(w, uint16(i.BitLen()), i.Bytes())
+}
+
+// CompressionAlgo Represents the different compression algorithms
+// supported by OpenPGP (except for BZIP2, which is not currently
+// supported). See Section 9.3 of RFC 4880.
+type CompressionAlgo uint8
+
+const (
+	CompressionNone CompressionAlgo = 0
+	CompressionZIP  CompressionAlgo = 1
+	CompressionZLIB CompressionAlgo = 2
+)
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/private_key.go b/vendor/golang.org/x/crypto/openpgp/packet/private_key.go
new file mode 100644
index 0000000..34734cc
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/private_key.go
@@ -0,0 +1,380 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"crypto"
+	"crypto/cipher"
+	"crypto/dsa"
+	"crypto/ecdsa"
+	"crypto/rsa"
+	"crypto/sha1"
+	"io"
+	"io/ioutil"
+	"math/big"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/elgamal"
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/s2k"
+)
+
+// PrivateKey represents a possibly encrypted private key. See RFC 4880,
+// section 5.5.3.
+type PrivateKey struct {
+	PublicKey
+	Encrypted     bool // if true then the private key is unavailable until Decrypt has been called.
+	encryptedData []byte
+	cipher        CipherFunction
+	s2k           func(out, in []byte)
+	PrivateKey    interface{} // An *{rsa|dsa|ecdsa}.PrivateKey or a crypto.Signer.
+	sha1Checksum  bool
+	iv            []byte
+}
+
+func NewRSAPrivateKey(currentTime time.Time, priv *rsa.PrivateKey) *PrivateKey {
+	pk := new(PrivateKey)
+	pk.PublicKey = *NewRSAPublicKey(currentTime, &priv.PublicKey)
+	pk.PrivateKey = priv
+	return pk
+}
+
+func NewDSAPrivateKey(currentTime time.Time, priv *dsa.PrivateKey) *PrivateKey {
+	pk := new(PrivateKey)
+	pk.PublicKey = *NewDSAPublicKey(currentTime, &priv.PublicKey)
+	pk.PrivateKey = priv
+	return pk
+}
+
+func NewElGamalPrivateKey(currentTime time.Time, priv *elgamal.PrivateKey) *PrivateKey {
+	pk := new(PrivateKey)
+	pk.PublicKey = *NewElGamalPublicKey(currentTime, &priv.PublicKey)
+	pk.PrivateKey = priv
+	return pk
+}
+
+func NewECDSAPrivateKey(currentTime time.Time, priv *ecdsa.PrivateKey) *PrivateKey {
+	pk := new(PrivateKey)
+	pk.PublicKey = *NewECDSAPublicKey(currentTime, &priv.PublicKey)
+	pk.PrivateKey = priv
+	return pk
+}
+
+// NewSignerPrivateKey creates a sign-only PrivateKey from a crypto.Signer that
+// implements RSA or ECDSA.
+func NewSignerPrivateKey(currentTime time.Time, signer crypto.Signer) *PrivateKey {
+	pk := new(PrivateKey)
+	switch pubkey := signer.Public().(type) {
+	case rsa.PublicKey:
+		pk.PublicKey = *NewRSAPublicKey(currentTime, &pubkey)
+		pk.PubKeyAlgo = PubKeyAlgoRSASignOnly
+	case ecdsa.PublicKey:
+		pk.PublicKey = *NewECDSAPublicKey(currentTime, &pubkey)
+	default:
+		panic("openpgp: unknown crypto.Signer type in NewSignerPrivateKey")
+	}
+	pk.PrivateKey = signer
+	return pk
+}
+
+func (pk *PrivateKey) parse(r io.Reader) (err error) {
+	err = (&pk.PublicKey).parse(r)
+	if err != nil {
+		return
+	}
+	var buf [1]byte
+	_, err = readFull(r, buf[:])
+	if err != nil {
+		return
+	}
+
+	s2kType := buf[0]
+
+	switch s2kType {
+	case 0:
+		pk.s2k = nil
+		pk.Encrypted = false
+	case 254, 255:
+		_, err = readFull(r, buf[:])
+		if err != nil {
+			return
+		}
+		pk.cipher = CipherFunction(buf[0])
+		pk.Encrypted = true
+		pk.s2k, err = s2k.Parse(r)
+		if err != nil {
+			return
+		}
+		if s2kType == 254 {
+			pk.sha1Checksum = true
+		}
+	default:
+		return errors.UnsupportedError("deprecated s2k function in private key")
+	}
+
+	if pk.Encrypted {
+		blockSize := pk.cipher.blockSize()
+		if blockSize == 0 {
+			return errors.UnsupportedError("unsupported cipher in private key: " + strconv.Itoa(int(pk.cipher)))
+		}
+		pk.iv = make([]byte, blockSize)
+		_, err = readFull(r, pk.iv)
+		if err != nil {
+			return
+		}
+	}
+
+	pk.encryptedData, err = ioutil.ReadAll(r)
+	if err != nil {
+		return
+	}
+
+	if !pk.Encrypted {
+		return pk.parsePrivateKey(pk.encryptedData)
+	}
+
+	return
+}
+
+func mod64kHash(d []byte) uint16 {
+	var h uint16
+	for _, b := range d {
+		h += uint16(b)
+	}
+	return h
+}
+
+func (pk *PrivateKey) Serialize(w io.Writer) (err error) {
+	// TODO(agl): support encrypted private keys
+	buf := bytes.NewBuffer(nil)
+	err = pk.PublicKey.serializeWithoutHeaders(buf)
+	if err != nil {
+		return
+	}
+	buf.WriteByte(0 /* no encryption */)
+
+	privateKeyBuf := bytes.NewBuffer(nil)
+
+	switch priv := pk.PrivateKey.(type) {
+	case *rsa.PrivateKey:
+		err = serializeRSAPrivateKey(privateKeyBuf, priv)
+	case *dsa.PrivateKey:
+		err = serializeDSAPrivateKey(privateKeyBuf, priv)
+	case *elgamal.PrivateKey:
+		err = serializeElGamalPrivateKey(privateKeyBuf, priv)
+	case *ecdsa.PrivateKey:
+		err = serializeECDSAPrivateKey(privateKeyBuf, priv)
+	default:
+		err = errors.InvalidArgumentError("unknown private key type")
+	}
+	if err != nil {
+		return
+	}
+
+	ptype := packetTypePrivateKey
+	contents := buf.Bytes()
+	privateKeyBytes := privateKeyBuf.Bytes()
+	if pk.IsSubkey {
+		ptype = packetTypePrivateSubkey
+	}
+	err = serializeHeader(w, ptype, len(contents)+len(privateKeyBytes)+2)
+	if err != nil {
+		return
+	}
+	_, err = w.Write(contents)
+	if err != nil {
+		return
+	}
+	_, err = w.Write(privateKeyBytes)
+	if err != nil {
+		return
+	}
+
+	checksum := mod64kHash(privateKeyBytes)
+	var checksumBytes [2]byte
+	checksumBytes[0] = byte(checksum >> 8)
+	checksumBytes[1] = byte(checksum)
+	_, err = w.Write(checksumBytes[:])
+
+	return
+}
+
+func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) error {
+	err := writeBig(w, priv.D)
+	if err != nil {
+		return err
+	}
+	err = writeBig(w, priv.Primes[1])
+	if err != nil {
+		return err
+	}
+	err = writeBig(w, priv.Primes[0])
+	if err != nil {
+		return err
+	}
+	return writeBig(w, priv.Precomputed.Qinv)
+}
+
+func serializeDSAPrivateKey(w io.Writer, priv *dsa.PrivateKey) error {
+	return writeBig(w, priv.X)
+}
+
+func serializeElGamalPrivateKey(w io.Writer, priv *elgamal.PrivateKey) error {
+	return writeBig(w, priv.X)
+}
+
+func serializeECDSAPrivateKey(w io.Writer, priv *ecdsa.PrivateKey) error {
+	return writeBig(w, priv.D)
+}
+
+// Decrypt decrypts an encrypted private key using a passphrase.
+func (pk *PrivateKey) Decrypt(passphrase []byte) error {
+	if !pk.Encrypted {
+		return nil
+	}
+
+	key := make([]byte, pk.cipher.KeySize())
+	pk.s2k(key, passphrase)
+	block := pk.cipher.new(key)
+	cfb := cipher.NewCFBDecrypter(block, pk.iv)
+
+	data := make([]byte, len(pk.encryptedData))
+	cfb.XORKeyStream(data, pk.encryptedData)
+
+	if pk.sha1Checksum {
+		if len(data) < sha1.Size {
+			return errors.StructuralError("truncated private key data")
+		}
+		h := sha1.New()
+		h.Write(data[:len(data)-sha1.Size])
+		sum := h.Sum(nil)
+		if !bytes.Equal(sum, data[len(data)-sha1.Size:]) {
+			return errors.StructuralError("private key checksum failure")
+		}
+		data = data[:len(data)-sha1.Size]
+	} else {
+		if len(data) < 2 {
+			return errors.StructuralError("truncated private key data")
+		}
+		var sum uint16
+		for i := 0; i < len(data)-2; i++ {
+			sum += uint16(data[i])
+		}
+		if data[len(data)-2] != uint8(sum>>8) ||
+			data[len(data)-1] != uint8(sum) {
+			return errors.StructuralError("private key checksum failure")
+		}
+		data = data[:len(data)-2]
+	}
+
+	return pk.parsePrivateKey(data)
+}
+
+func (pk *PrivateKey) parsePrivateKey(data []byte) (err error) {
+	switch pk.PublicKey.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoRSAEncryptOnly:
+		return pk.parseRSAPrivateKey(data)
+	case PubKeyAlgoDSA:
+		return pk.parseDSAPrivateKey(data)
+	case PubKeyAlgoElGamal:
+		return pk.parseElGamalPrivateKey(data)
+	case PubKeyAlgoECDSA:
+		return pk.parseECDSAPrivateKey(data)
+	}
+	panic("impossible")
+}
+
+func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err error) {
+	rsaPub := pk.PublicKey.PublicKey.(*rsa.PublicKey)
+	rsaPriv := new(rsa.PrivateKey)
+	rsaPriv.PublicKey = *rsaPub
+
+	buf := bytes.NewBuffer(data)
+	d, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+	p, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+	q, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+
+	rsaPriv.D = new(big.Int).SetBytes(d)
+	rsaPriv.Primes = make([]*big.Int, 2)
+	rsaPriv.Primes[0] = new(big.Int).SetBytes(p)
+	rsaPriv.Primes[1] = new(big.Int).SetBytes(q)
+	if err := rsaPriv.Validate(); err != nil {
+		return err
+	}
+	rsaPriv.Precompute()
+	pk.PrivateKey = rsaPriv
+	pk.Encrypted = false
+	pk.encryptedData = nil
+
+	return nil
+}
+
+func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err error) {
+	dsaPub := pk.PublicKey.PublicKey.(*dsa.PublicKey)
+	dsaPriv := new(dsa.PrivateKey)
+	dsaPriv.PublicKey = *dsaPub
+
+	buf := bytes.NewBuffer(data)
+	x, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+
+	dsaPriv.X = new(big.Int).SetBytes(x)
+	pk.PrivateKey = dsaPriv
+	pk.Encrypted = false
+	pk.encryptedData = nil
+
+	return nil
+}
+
+func (pk *PrivateKey) parseElGamalPrivateKey(data []byte) (err error) {
+	pub := pk.PublicKey.PublicKey.(*elgamal.PublicKey)
+	priv := new(elgamal.PrivateKey)
+	priv.PublicKey = *pub
+
+	buf := bytes.NewBuffer(data)
+	x, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+
+	priv.X = new(big.Int).SetBytes(x)
+	pk.PrivateKey = priv
+	pk.Encrypted = false
+	pk.encryptedData = nil
+
+	return nil
+}
+
+func (pk *PrivateKey) parseECDSAPrivateKey(data []byte) (err error) {
+	ecdsaPub := pk.PublicKey.PublicKey.(*ecdsa.PublicKey)
+
+	buf := bytes.NewBuffer(data)
+	d, _, err := readMPI(buf)
+	if err != nil {
+		return
+	}
+
+	pk.PrivateKey = &ecdsa.PrivateKey{
+		PublicKey: *ecdsaPub,
+		D:         new(big.Int).SetBytes(d),
+	}
+	pk.Encrypted = false
+	pk.encryptedData = nil
+
+	return nil
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/public_key.go b/vendor/golang.org/x/crypto/openpgp/packet/public_key.go
new file mode 100644
index 0000000..ead2623
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/public_key.go
@@ -0,0 +1,748 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"crypto"
+	"crypto/dsa"
+	"crypto/ecdsa"
+	"crypto/elliptic"
+	"crypto/rsa"
+	"crypto/sha1"
+	_ "crypto/sha256"
+	_ "crypto/sha512"
+	"encoding/binary"
+	"fmt"
+	"hash"
+	"io"
+	"math/big"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/elgamal"
+	"golang.org/x/crypto/openpgp/errors"
+)
+
+var (
+	// NIST curve P-256
+	oidCurveP256 []byte = []byte{0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07}
+	// NIST curve P-384
+	oidCurveP384 []byte = []byte{0x2B, 0x81, 0x04, 0x00, 0x22}
+	// NIST curve P-521
+	oidCurveP521 []byte = []byte{0x2B, 0x81, 0x04, 0x00, 0x23}
+)
+
+const maxOIDLength = 8
+
+// ecdsaKey stores the algorithm-specific fields for ECDSA keys.
+// as defined in RFC 6637, Section 9.
+type ecdsaKey struct {
+	// oid contains the OID byte sequence identifying the elliptic curve used
+	oid []byte
+	// p contains the elliptic curve point that represents the public key
+	p parsedMPI
+}
+
+// parseOID reads the OID for the curve as defined in RFC 6637, Section 9.
+func parseOID(r io.Reader) (oid []byte, err error) {
+	buf := make([]byte, maxOIDLength)
+	if _, err = readFull(r, buf[:1]); err != nil {
+		return
+	}
+	oidLen := buf[0]
+	if int(oidLen) > len(buf) {
+		err = errors.UnsupportedError("invalid oid length: " + strconv.Itoa(int(oidLen)))
+		return
+	}
+	oid = buf[:oidLen]
+	_, err = readFull(r, oid)
+	return
+}
+
+func (f *ecdsaKey) parse(r io.Reader) (err error) {
+	if f.oid, err = parseOID(r); err != nil {
+		return err
+	}
+	f.p.bytes, f.p.bitLength, err = readMPI(r)
+	return
+}
+
+func (f *ecdsaKey) serialize(w io.Writer) (err error) {
+	buf := make([]byte, maxOIDLength+1)
+	buf[0] = byte(len(f.oid))
+	copy(buf[1:], f.oid)
+	if _, err = w.Write(buf[:len(f.oid)+1]); err != nil {
+		return
+	}
+	return writeMPIs(w, f.p)
+}
+
+func (f *ecdsaKey) newECDSA() (*ecdsa.PublicKey, error) {
+	var c elliptic.Curve
+	if bytes.Equal(f.oid, oidCurveP256) {
+		c = elliptic.P256()
+	} else if bytes.Equal(f.oid, oidCurveP384) {
+		c = elliptic.P384()
+	} else if bytes.Equal(f.oid, oidCurveP521) {
+		c = elliptic.P521()
+	} else {
+		return nil, errors.UnsupportedError(fmt.Sprintf("unsupported oid: %x", f.oid))
+	}
+	x, y := elliptic.Unmarshal(c, f.p.bytes)
+	if x == nil {
+		return nil, errors.UnsupportedError("failed to parse EC point")
+	}
+	return &ecdsa.PublicKey{Curve: c, X: x, Y: y}, nil
+}
+
+func (f *ecdsaKey) byteLen() int {
+	return 1 + len(f.oid) + 2 + len(f.p.bytes)
+}
+
+type kdfHashFunction byte
+type kdfAlgorithm byte
+
+// ecdhKdf stores key derivation function parameters
+// used for ECDH encryption. See RFC 6637, Section 9.
+type ecdhKdf struct {
+	KdfHash kdfHashFunction
+	KdfAlgo kdfAlgorithm
+}
+
+func (f *ecdhKdf) parse(r io.Reader) (err error) {
+	buf := make([]byte, 1)
+	if _, err = readFull(r, buf); err != nil {
+		return
+	}
+	kdfLen := int(buf[0])
+	if kdfLen < 3 {
+		return errors.UnsupportedError("Unsupported ECDH KDF length: " + strconv.Itoa(kdfLen))
+	}
+	buf = make([]byte, kdfLen)
+	if _, err = readFull(r, buf); err != nil {
+		return
+	}
+	reserved := int(buf[0])
+	f.KdfHash = kdfHashFunction(buf[1])
+	f.KdfAlgo = kdfAlgorithm(buf[2])
+	if reserved != 0x01 {
+		return errors.UnsupportedError("Unsupported KDF reserved field: " + strconv.Itoa(reserved))
+	}
+	return
+}
+
+func (f *ecdhKdf) serialize(w io.Writer) (err error) {
+	buf := make([]byte, 4)
+	// See RFC 6637, Section 9, Algorithm-Specific Fields for ECDH keys.
+	buf[0] = byte(0x03) // Length of the following fields
+	buf[1] = byte(0x01) // Reserved for future extensions, must be 1 for now
+	buf[2] = byte(f.KdfHash)
+	buf[3] = byte(f.KdfAlgo)
+	_, err = w.Write(buf[:])
+	return
+}
+
+func (f *ecdhKdf) byteLen() int {
+	return 4
+}
+
+// PublicKey represents an OpenPGP public key. See RFC 4880, section 5.5.2.
+type PublicKey struct {
+	CreationTime time.Time
+	PubKeyAlgo   PublicKeyAlgorithm
+	PublicKey    interface{} // *rsa.PublicKey, *dsa.PublicKey or *ecdsa.PublicKey
+	Fingerprint  [20]byte
+	KeyId        uint64
+	IsSubkey     bool
+
+	n, e, p, q, g, y parsedMPI
+
+	// RFC 6637 fields
+	ec   *ecdsaKey
+	ecdh *ecdhKdf
+}
+
+// signingKey provides a convenient abstraction over signature verification
+// for v3 and v4 public keys.
+type signingKey interface {
+	SerializeSignaturePrefix(io.Writer)
+	serializeWithoutHeaders(io.Writer) error
+}
+
+func fromBig(n *big.Int) parsedMPI {
+	return parsedMPI{
+		bytes:     n.Bytes(),
+		bitLength: uint16(n.BitLen()),
+	}
+}
+
+// NewRSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.
+func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey) *PublicKey {
+	pk := &PublicKey{
+		CreationTime: creationTime,
+		PubKeyAlgo:   PubKeyAlgoRSA,
+		PublicKey:    pub,
+		n:            fromBig(pub.N),
+		e:            fromBig(big.NewInt(int64(pub.E))),
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return pk
+}
+
+// NewDSAPublicKey returns a PublicKey that wraps the given dsa.PublicKey.
+func NewDSAPublicKey(creationTime time.Time, pub *dsa.PublicKey) *PublicKey {
+	pk := &PublicKey{
+		CreationTime: creationTime,
+		PubKeyAlgo:   PubKeyAlgoDSA,
+		PublicKey:    pub,
+		p:            fromBig(pub.P),
+		q:            fromBig(pub.Q),
+		g:            fromBig(pub.G),
+		y:            fromBig(pub.Y),
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return pk
+}
+
+// NewElGamalPublicKey returns a PublicKey that wraps the given elgamal.PublicKey.
+func NewElGamalPublicKey(creationTime time.Time, pub *elgamal.PublicKey) *PublicKey {
+	pk := &PublicKey{
+		CreationTime: creationTime,
+		PubKeyAlgo:   PubKeyAlgoElGamal,
+		PublicKey:    pub,
+		p:            fromBig(pub.P),
+		g:            fromBig(pub.G),
+		y:            fromBig(pub.Y),
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return pk
+}
+
+func NewECDSAPublicKey(creationTime time.Time, pub *ecdsa.PublicKey) *PublicKey {
+	pk := &PublicKey{
+		CreationTime: creationTime,
+		PubKeyAlgo:   PubKeyAlgoECDSA,
+		PublicKey:    pub,
+		ec:           new(ecdsaKey),
+	}
+
+	switch pub.Curve {
+	case elliptic.P256():
+		pk.ec.oid = oidCurveP256
+	case elliptic.P384():
+		pk.ec.oid = oidCurveP384
+	case elliptic.P521():
+		pk.ec.oid = oidCurveP521
+	default:
+		panic("unknown elliptic curve")
+	}
+
+	pk.ec.p.bytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)
+	pk.ec.p.bitLength = uint16(8 * len(pk.ec.p.bytes))
+
+	pk.setFingerPrintAndKeyId()
+	return pk
+}
+
+func (pk *PublicKey) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.5.2
+	var buf [6]byte
+	_, err = readFull(r, buf[:])
+	if err != nil {
+		return
+	}
+	if buf[0] != 4 {
+		return errors.UnsupportedError("public key version")
+	}
+	pk.CreationTime = time.Unix(int64(uint32(buf[1])<<24|uint32(buf[2])<<16|uint32(buf[3])<<8|uint32(buf[4])), 0)
+	pk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		err = pk.parseRSA(r)
+	case PubKeyAlgoDSA:
+		err = pk.parseDSA(r)
+	case PubKeyAlgoElGamal:
+		err = pk.parseElGamal(r)
+	case PubKeyAlgoECDSA:
+		pk.ec = new(ecdsaKey)
+		if err = pk.ec.parse(r); err != nil {
+			return err
+		}
+		pk.PublicKey, err = pk.ec.newECDSA()
+	case PubKeyAlgoECDH:
+		pk.ec = new(ecdsaKey)
+		if err = pk.ec.parse(r); err != nil {
+			return
+		}
+		pk.ecdh = new(ecdhKdf)
+		if err = pk.ecdh.parse(r); err != nil {
+			return
+		}
+		// The ECDH key is stored in an ecdsa.PublicKey for convenience.
+		pk.PublicKey, err = pk.ec.newECDSA()
+	default:
+		err = errors.UnsupportedError("public key type: " + strconv.Itoa(int(pk.PubKeyAlgo)))
+	}
+	if err != nil {
+		return
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return
+}
+
+func (pk *PublicKey) setFingerPrintAndKeyId() {
+	// RFC 4880, section 12.2
+	fingerPrint := sha1.New()
+	pk.SerializeSignaturePrefix(fingerPrint)
+	pk.serializeWithoutHeaders(fingerPrint)
+	copy(pk.Fingerprint[:], fingerPrint.Sum(nil))
+	pk.KeyId = binary.BigEndian.Uint64(pk.Fingerprint[12:20])
+}
+
+// parseRSA parses RSA public key material from the given Reader. See RFC 4880,
+// section 5.5.2.
+func (pk *PublicKey) parseRSA(r io.Reader) (err error) {
+	pk.n.bytes, pk.n.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.e.bytes, pk.e.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+
+	if len(pk.e.bytes) > 3 {
+		err = errors.UnsupportedError("large public exponent")
+		return
+	}
+	rsa := &rsa.PublicKey{
+		N: new(big.Int).SetBytes(pk.n.bytes),
+		E: 0,
+	}
+	for i := 0; i < len(pk.e.bytes); i++ {
+		rsa.E <<= 8
+		rsa.E |= int(pk.e.bytes[i])
+	}
+	pk.PublicKey = rsa
+	return
+}
+
+// parseDSA parses DSA public key material from the given Reader. See RFC 4880,
+// section 5.5.2.
+func (pk *PublicKey) parseDSA(r io.Reader) (err error) {
+	pk.p.bytes, pk.p.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.q.bytes, pk.q.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.g.bytes, pk.g.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.y.bytes, pk.y.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+
+	dsa := new(dsa.PublicKey)
+	dsa.P = new(big.Int).SetBytes(pk.p.bytes)
+	dsa.Q = new(big.Int).SetBytes(pk.q.bytes)
+	dsa.G = new(big.Int).SetBytes(pk.g.bytes)
+	dsa.Y = new(big.Int).SetBytes(pk.y.bytes)
+	pk.PublicKey = dsa
+	return
+}
+
+// parseElGamal parses ElGamal public key material from the given Reader. See
+// RFC 4880, section 5.5.2.
+func (pk *PublicKey) parseElGamal(r io.Reader) (err error) {
+	pk.p.bytes, pk.p.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.g.bytes, pk.g.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+	pk.y.bytes, pk.y.bitLength, err = readMPI(r)
+	if err != nil {
+		return
+	}
+
+	elgamal := new(elgamal.PublicKey)
+	elgamal.P = new(big.Int).SetBytes(pk.p.bytes)
+	elgamal.G = new(big.Int).SetBytes(pk.g.bytes)
+	elgamal.Y = new(big.Int).SetBytes(pk.y.bytes)
+	pk.PublicKey = elgamal
+	return
+}
+
+// SerializeSignaturePrefix writes the prefix for this public key to the given Writer.
+// The prefix is used when calculating a signature over this public key. See
+// RFC 4880, section 5.2.4.
+func (pk *PublicKey) SerializeSignaturePrefix(h io.Writer) {
+	var pLength uint16
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		pLength += 2 + uint16(len(pk.n.bytes))
+		pLength += 2 + uint16(len(pk.e.bytes))
+	case PubKeyAlgoDSA:
+		pLength += 2 + uint16(len(pk.p.bytes))
+		pLength += 2 + uint16(len(pk.q.bytes))
+		pLength += 2 + uint16(len(pk.g.bytes))
+		pLength += 2 + uint16(len(pk.y.bytes))
+	case PubKeyAlgoElGamal:
+		pLength += 2 + uint16(len(pk.p.bytes))
+		pLength += 2 + uint16(len(pk.g.bytes))
+		pLength += 2 + uint16(len(pk.y.bytes))
+	case PubKeyAlgoECDSA:
+		pLength += uint16(pk.ec.byteLen())
+	case PubKeyAlgoECDH:
+		pLength += uint16(pk.ec.byteLen())
+		pLength += uint16(pk.ecdh.byteLen())
+	default:
+		panic("unknown public key algorithm")
+	}
+	pLength += 6
+	h.Write([]byte{0x99, byte(pLength >> 8), byte(pLength)})
+	return
+}
+
+func (pk *PublicKey) Serialize(w io.Writer) (err error) {
+	length := 6 // 6 byte header
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		length += 2 + len(pk.n.bytes)
+		length += 2 + len(pk.e.bytes)
+	case PubKeyAlgoDSA:
+		length += 2 + len(pk.p.bytes)
+		length += 2 + len(pk.q.bytes)
+		length += 2 + len(pk.g.bytes)
+		length += 2 + len(pk.y.bytes)
+	case PubKeyAlgoElGamal:
+		length += 2 + len(pk.p.bytes)
+		length += 2 + len(pk.g.bytes)
+		length += 2 + len(pk.y.bytes)
+	case PubKeyAlgoECDSA:
+		length += pk.ec.byteLen()
+	case PubKeyAlgoECDH:
+		length += pk.ec.byteLen()
+		length += pk.ecdh.byteLen()
+	default:
+		panic("unknown public key algorithm")
+	}
+
+	packetType := packetTypePublicKey
+	if pk.IsSubkey {
+		packetType = packetTypePublicSubkey
+	}
+	err = serializeHeader(w, packetType, length)
+	if err != nil {
+		return
+	}
+	return pk.serializeWithoutHeaders(w)
+}
+
+// serializeWithoutHeaders marshals the PublicKey to w in the form of an
+// OpenPGP public key packet, not including the packet header.
+func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err error) {
+	var buf [6]byte
+	buf[0] = 4
+	t := uint32(pk.CreationTime.Unix())
+	buf[1] = byte(t >> 24)
+	buf[2] = byte(t >> 16)
+	buf[3] = byte(t >> 8)
+	buf[4] = byte(t)
+	buf[5] = byte(pk.PubKeyAlgo)
+
+	_, err = w.Write(buf[:])
+	if err != nil {
+		return
+	}
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		return writeMPIs(w, pk.n, pk.e)
+	case PubKeyAlgoDSA:
+		return writeMPIs(w, pk.p, pk.q, pk.g, pk.y)
+	case PubKeyAlgoElGamal:
+		return writeMPIs(w, pk.p, pk.g, pk.y)
+	case PubKeyAlgoECDSA:
+		return pk.ec.serialize(w)
+	case PubKeyAlgoECDH:
+		if err = pk.ec.serialize(w); err != nil {
+			return
+		}
+		return pk.ecdh.serialize(w)
+	}
+	return errors.InvalidArgumentError("bad public-key algorithm")
+}
+
+// CanSign returns true iff this public key can generate signatures
+func (pk *PublicKey) CanSign() bool {
+	return pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly && pk.PubKeyAlgo != PubKeyAlgoElGamal
+}
+
+// VerifySignature returns nil iff sig is a valid signature, made by this
+// public key, of the data hashed into signed. signed is mutated by this call.
+func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err error) {
+	if !pk.CanSign() {
+		return errors.InvalidArgumentError("public key cannot generate signatures")
+	}
+
+	signed.Write(sig.HashSuffix)
+	hashBytes := signed.Sum(nil)
+
+	if hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {
+		return errors.SignatureError("hash tag doesn't match")
+	}
+
+	if pk.PubKeyAlgo != sig.PubKeyAlgo {
+		return errors.InvalidArgumentError("public key and signature use different algorithms")
+	}
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		rsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)
+		err = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes)
+		if err != nil {
+			return errors.SignatureError("RSA verification failure")
+		}
+		return nil
+	case PubKeyAlgoDSA:
+		dsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)
+		// Need to truncate hashBytes to match FIPS 186-3 section 4.6.
+		subgroupSize := (dsaPublicKey.Q.BitLen() + 7) / 8
+		if len(hashBytes) > subgroupSize {
+			hashBytes = hashBytes[:subgroupSize]
+		}
+		if !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {
+			return errors.SignatureError("DSA verification failure")
+		}
+		return nil
+	case PubKeyAlgoECDSA:
+		ecdsaPublicKey := pk.PublicKey.(*ecdsa.PublicKey)
+		if !ecdsa.Verify(ecdsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.ECDSASigR.bytes), new(big.Int).SetBytes(sig.ECDSASigS.bytes)) {
+			return errors.SignatureError("ECDSA verification failure")
+		}
+		return nil
+	default:
+		return errors.SignatureError("Unsupported public key algorithm used in signature")
+	}
+}
+
+// VerifySignatureV3 returns nil iff sig is a valid signature, made by this
+// public key, of the data hashed into signed. signed is mutated by this call.
+func (pk *PublicKey) VerifySignatureV3(signed hash.Hash, sig *SignatureV3) (err error) {
+	if !pk.CanSign() {
+		return errors.InvalidArgumentError("public key cannot generate signatures")
+	}
+
+	suffix := make([]byte, 5)
+	suffix[0] = byte(sig.SigType)
+	binary.BigEndian.PutUint32(suffix[1:], uint32(sig.CreationTime.Unix()))
+	signed.Write(suffix)
+	hashBytes := signed.Sum(nil)
+
+	if hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {
+		return errors.SignatureError("hash tag doesn't match")
+	}
+
+	if pk.PubKeyAlgo != sig.PubKeyAlgo {
+		return errors.InvalidArgumentError("public key and signature use different algorithms")
+	}
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		rsaPublicKey := pk.PublicKey.(*rsa.PublicKey)
+		if err = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes); err != nil {
+			return errors.SignatureError("RSA verification failure")
+		}
+		return
+	case PubKeyAlgoDSA:
+		dsaPublicKey := pk.PublicKey.(*dsa.PublicKey)
+		// Need to truncate hashBytes to match FIPS 186-3 section 4.6.
+		subgroupSize := (dsaPublicKey.Q.BitLen() + 7) / 8
+		if len(hashBytes) > subgroupSize {
+			hashBytes = hashBytes[:subgroupSize]
+		}
+		if !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {
+			return errors.SignatureError("DSA verification failure")
+		}
+		return nil
+	default:
+		panic("shouldn't happen")
+	}
+}
+
+// keySignatureHash returns a Hash of the message that needs to be signed for
+// pk to assert a subkey relationship to signed.
+func keySignatureHash(pk, signed signingKey, hashFunc crypto.Hash) (h hash.Hash, err error) {
+	if !hashFunc.Available() {
+		return nil, errors.UnsupportedError("hash function")
+	}
+	h = hashFunc.New()
+
+	// RFC 4880, section 5.2.4
+	pk.SerializeSignaturePrefix(h)
+	pk.serializeWithoutHeaders(h)
+	signed.SerializeSignaturePrefix(h)
+	signed.serializeWithoutHeaders(h)
+	return
+}
+
+// VerifyKeySignature returns nil iff sig is a valid signature, made by this
+// public key, of signed.
+func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) error {
+	h, err := keySignatureHash(pk, signed, sig.Hash)
+	if err != nil {
+		return err
+	}
+	if err = pk.VerifySignature(h, sig); err != nil {
+		return err
+	}
+
+	if sig.FlagSign {
+		// Signing subkeys must be cross-signed. See
+		// https://www.gnupg.org/faq/subkey-cross-certify.html.
+		if sig.EmbeddedSignature == nil {
+			return errors.StructuralError("signing subkey is missing cross-signature")
+		}
+		// Verify the cross-signature. This is calculated over the same
+		// data as the main signature, so we cannot just recursively
+		// call signed.VerifyKeySignature(...)
+		if h, err = keySignatureHash(pk, signed, sig.EmbeddedSignature.Hash); err != nil {
+			return errors.StructuralError("error while hashing for cross-signature: " + err.Error())
+		}
+		if err := signed.VerifySignature(h, sig.EmbeddedSignature); err != nil {
+			return errors.StructuralError("error while verifying cross-signature: " + err.Error())
+		}
+	}
+
+	return nil
+}
+
+func keyRevocationHash(pk signingKey, hashFunc crypto.Hash) (h hash.Hash, err error) {
+	if !hashFunc.Available() {
+		return nil, errors.UnsupportedError("hash function")
+	}
+	h = hashFunc.New()
+
+	// RFC 4880, section 5.2.4
+	pk.SerializeSignaturePrefix(h)
+	pk.serializeWithoutHeaders(h)
+
+	return
+}
+
+// VerifyRevocationSignature returns nil iff sig is a valid signature, made by this
+// public key.
+func (pk *PublicKey) VerifyRevocationSignature(sig *Signature) (err error) {
+	h, err := keyRevocationHash(pk, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return pk.VerifySignature(h, sig)
+}
+
+// userIdSignatureHash returns a Hash of the message that needs to be signed
+// to assert that pk is a valid key for id.
+func userIdSignatureHash(id string, pk *PublicKey, hashFunc crypto.Hash) (h hash.Hash, err error) {
+	if !hashFunc.Available() {
+		return nil, errors.UnsupportedError("hash function")
+	}
+	h = hashFunc.New()
+
+	// RFC 4880, section 5.2.4
+	pk.SerializeSignaturePrefix(h)
+	pk.serializeWithoutHeaders(h)
+
+	var buf [5]byte
+	buf[0] = 0xb4
+	buf[1] = byte(len(id) >> 24)
+	buf[2] = byte(len(id) >> 16)
+	buf[3] = byte(len(id) >> 8)
+	buf[4] = byte(len(id))
+	h.Write(buf[:])
+	h.Write([]byte(id))
+
+	return
+}
+
+// VerifyUserIdSignature returns nil iff sig is a valid signature, made by this
+// public key, that id is the identity of pub.
+func (pk *PublicKey) VerifyUserIdSignature(id string, pub *PublicKey, sig *Signature) (err error) {
+	h, err := userIdSignatureHash(id, pub, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return pk.VerifySignature(h, sig)
+}
+
+// VerifyUserIdSignatureV3 returns nil iff sig is a valid signature, made by this
+// public key, that id is the identity of pub.
+func (pk *PublicKey) VerifyUserIdSignatureV3(id string, pub *PublicKey, sig *SignatureV3) (err error) {
+	h, err := userIdSignatureV3Hash(id, pub, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return pk.VerifySignatureV3(h, sig)
+}
+
+// KeyIdString returns the public key's fingerprint in capital hex
+// (e.g. "6C7EE1B8621CC013").
+func (pk *PublicKey) KeyIdString() string {
+	return fmt.Sprintf("%X", pk.Fingerprint[12:20])
+}
+
+// KeyIdShortString returns the short form of public key's fingerprint
+// in capital hex, as shown by gpg --list-keys (e.g. "621CC013").
+func (pk *PublicKey) KeyIdShortString() string {
+	return fmt.Sprintf("%X", pk.Fingerprint[16:20])
+}
+
+// A parsedMPI is used to store the contents of a big integer, along with the
+// bit length that was specified in the original input. This allows the MPI to
+// be reserialized exactly.
+type parsedMPI struct {
+	bytes     []byte
+	bitLength uint16
+}
+
+// writeMPIs is a utility function for serializing several big integers to the
+// given Writer.
+func writeMPIs(w io.Writer, mpis ...parsedMPI) (err error) {
+	for _, mpi := range mpis {
+		err = writeMPI(w, mpi.bitLength, mpi.bytes)
+		if err != nil {
+			return
+		}
+	}
+	return
+}
+
+// BitLength returns the bit length for the given public key.
+func (pk *PublicKey) BitLength() (bitLength uint16, err error) {
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		bitLength = pk.n.bitLength
+	case PubKeyAlgoDSA:
+		bitLength = pk.p.bitLength
+	case PubKeyAlgoElGamal:
+		bitLength = pk.p.bitLength
+	default:
+		err = errors.InvalidArgumentError("bad public-key algorithm")
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/public_key_v3.go b/vendor/golang.org/x/crypto/openpgp/packet/public_key_v3.go
new file mode 100644
index 0000000..5daf7b6
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/public_key_v3.go
@@ -0,0 +1,279 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto"
+	"crypto/md5"
+	"crypto/rsa"
+	"encoding/binary"
+	"fmt"
+	"hash"
+	"io"
+	"math/big"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/errors"
+)
+
+// PublicKeyV3 represents older, version 3 public keys. These keys are less secure and
+// should not be used for signing or encrypting. They are supported here only for
+// parsing version 3 key material and validating signatures.
+// See RFC 4880, section 5.5.2.
+type PublicKeyV3 struct {
+	CreationTime time.Time
+	DaysToExpire uint16
+	PubKeyAlgo   PublicKeyAlgorithm
+	PublicKey    *rsa.PublicKey
+	Fingerprint  [16]byte
+	KeyId        uint64
+	IsSubkey     bool
+
+	n, e parsedMPI
+}
+
+// newRSAPublicKeyV3 returns a PublicKey that wraps the given rsa.PublicKey.
+// Included here for testing purposes only. RFC 4880, section 5.5.2:
+// "an implementation MUST NOT generate a V3 key, but MAY accept it."
+func newRSAPublicKeyV3(creationTime time.Time, pub *rsa.PublicKey) *PublicKeyV3 {
+	pk := &PublicKeyV3{
+		CreationTime: creationTime,
+		PublicKey:    pub,
+		n:            fromBig(pub.N),
+		e:            fromBig(big.NewInt(int64(pub.E))),
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return pk
+}
+
+func (pk *PublicKeyV3) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.5.2
+	var buf [8]byte
+	if _, err = readFull(r, buf[:]); err != nil {
+		return
+	}
+	if buf[0] < 2 || buf[0] > 3 {
+		return errors.UnsupportedError("public key version")
+	}
+	pk.CreationTime = time.Unix(int64(uint32(buf[1])<<24|uint32(buf[2])<<16|uint32(buf[3])<<8|uint32(buf[4])), 0)
+	pk.DaysToExpire = binary.BigEndian.Uint16(buf[5:7])
+	pk.PubKeyAlgo = PublicKeyAlgorithm(buf[7])
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		err = pk.parseRSA(r)
+	default:
+		err = errors.UnsupportedError("public key type: " + strconv.Itoa(int(pk.PubKeyAlgo)))
+	}
+	if err != nil {
+		return
+	}
+
+	pk.setFingerPrintAndKeyId()
+	return
+}
+
+func (pk *PublicKeyV3) setFingerPrintAndKeyId() {
+	// RFC 4880, section 12.2
+	fingerPrint := md5.New()
+	fingerPrint.Write(pk.n.bytes)
+	fingerPrint.Write(pk.e.bytes)
+	fingerPrint.Sum(pk.Fingerprint[:0])
+	pk.KeyId = binary.BigEndian.Uint64(pk.n.bytes[len(pk.n.bytes)-8:])
+}
+
+// parseRSA parses RSA public key material from the given Reader. See RFC 4880,
+// section 5.5.2.
+func (pk *PublicKeyV3) parseRSA(r io.Reader) (err error) {
+	if pk.n.bytes, pk.n.bitLength, err = readMPI(r); err != nil {
+		return
+	}
+	if pk.e.bytes, pk.e.bitLength, err = readMPI(r); err != nil {
+		return
+	}
+
+	// RFC 4880 Section 12.2 requires the low 8 bytes of the
+	// modulus to form the key id.
+	if len(pk.n.bytes) < 8 {
+		return errors.StructuralError("v3 public key modulus is too short")
+	}
+	if len(pk.e.bytes) > 3 {
+		err = errors.UnsupportedError("large public exponent")
+		return
+	}
+	rsa := &rsa.PublicKey{N: new(big.Int).SetBytes(pk.n.bytes)}
+	for i := 0; i < len(pk.e.bytes); i++ {
+		rsa.E <<= 8
+		rsa.E |= int(pk.e.bytes[i])
+	}
+	pk.PublicKey = rsa
+	return
+}
+
+// SerializeSignaturePrefix writes the prefix for this public key to the given Writer.
+// The prefix is used when calculating a signature over this public key. See
+// RFC 4880, section 5.2.4.
+func (pk *PublicKeyV3) SerializeSignaturePrefix(w io.Writer) {
+	var pLength uint16
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		pLength += 2 + uint16(len(pk.n.bytes))
+		pLength += 2 + uint16(len(pk.e.bytes))
+	default:
+		panic("unknown public key algorithm")
+	}
+	pLength += 6
+	w.Write([]byte{0x99, byte(pLength >> 8), byte(pLength)})
+	return
+}
+
+func (pk *PublicKeyV3) Serialize(w io.Writer) (err error) {
+	length := 8 // 8 byte header
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		length += 2 + len(pk.n.bytes)
+		length += 2 + len(pk.e.bytes)
+	default:
+		panic("unknown public key algorithm")
+	}
+
+	packetType := packetTypePublicKey
+	if pk.IsSubkey {
+		packetType = packetTypePublicSubkey
+	}
+	if err = serializeHeader(w, packetType, length); err != nil {
+		return
+	}
+	return pk.serializeWithoutHeaders(w)
+}
+
+// serializeWithoutHeaders marshals the PublicKey to w in the form of an
+// OpenPGP public key packet, not including the packet header.
+func (pk *PublicKeyV3) serializeWithoutHeaders(w io.Writer) (err error) {
+	var buf [8]byte
+	// Version 3
+	buf[0] = 3
+	// Creation time
+	t := uint32(pk.CreationTime.Unix())
+	buf[1] = byte(t >> 24)
+	buf[2] = byte(t >> 16)
+	buf[3] = byte(t >> 8)
+	buf[4] = byte(t)
+	// Days to expire
+	buf[5] = byte(pk.DaysToExpire >> 8)
+	buf[6] = byte(pk.DaysToExpire)
+	// Public key algorithm
+	buf[7] = byte(pk.PubKeyAlgo)
+
+	if _, err = w.Write(buf[:]); err != nil {
+		return
+	}
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		return writeMPIs(w, pk.n, pk.e)
+	}
+	return errors.InvalidArgumentError("bad public-key algorithm")
+}
+
+// CanSign returns true iff this public key can generate signatures
+func (pk *PublicKeyV3) CanSign() bool {
+	return pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly
+}
+
+// VerifySignatureV3 returns nil iff sig is a valid signature, made by this
+// public key, of the data hashed into signed. signed is mutated by this call.
+func (pk *PublicKeyV3) VerifySignatureV3(signed hash.Hash, sig *SignatureV3) (err error) {
+	if !pk.CanSign() {
+		return errors.InvalidArgumentError("public key cannot generate signatures")
+	}
+
+	suffix := make([]byte, 5)
+	suffix[0] = byte(sig.SigType)
+	binary.BigEndian.PutUint32(suffix[1:], uint32(sig.CreationTime.Unix()))
+	signed.Write(suffix)
+	hashBytes := signed.Sum(nil)
+
+	if hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {
+		return errors.SignatureError("hash tag doesn't match")
+	}
+
+	if pk.PubKeyAlgo != sig.PubKeyAlgo {
+		return errors.InvalidArgumentError("public key and signature use different algorithms")
+	}
+
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		if err = rsa.VerifyPKCS1v15(pk.PublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes); err != nil {
+			return errors.SignatureError("RSA verification failure")
+		}
+		return
+	default:
+		// V3 public keys only support RSA.
+		panic("shouldn't happen")
+	}
+}
+
+// VerifyUserIdSignatureV3 returns nil iff sig is a valid signature, made by this
+// public key, that id is the identity of pub.
+func (pk *PublicKeyV3) VerifyUserIdSignatureV3(id string, pub *PublicKeyV3, sig *SignatureV3) (err error) {
+	h, err := userIdSignatureV3Hash(id, pk, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return pk.VerifySignatureV3(h, sig)
+}
+
+// VerifyKeySignatureV3 returns nil iff sig is a valid signature, made by this
+// public key, of signed.
+func (pk *PublicKeyV3) VerifyKeySignatureV3(signed *PublicKeyV3, sig *SignatureV3) (err error) {
+	h, err := keySignatureHash(pk, signed, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return pk.VerifySignatureV3(h, sig)
+}
+
+// userIdSignatureV3Hash returns a Hash of the message that needs to be signed
+// to assert that pk is a valid key for id.
+func userIdSignatureV3Hash(id string, pk signingKey, hfn crypto.Hash) (h hash.Hash, err error) {
+	if !hfn.Available() {
+		return nil, errors.UnsupportedError("hash function")
+	}
+	h = hfn.New()
+
+	// RFC 4880, section 5.2.4
+	pk.SerializeSignaturePrefix(h)
+	pk.serializeWithoutHeaders(h)
+
+	h.Write([]byte(id))
+
+	return
+}
+
+// KeyIdString returns the public key's fingerprint in capital hex
+// (e.g. "6C7EE1B8621CC013").
+func (pk *PublicKeyV3) KeyIdString() string {
+	return fmt.Sprintf("%X", pk.KeyId)
+}
+
+// KeyIdShortString returns the short form of public key's fingerprint
+// in capital hex, as shown by gpg --list-keys (e.g. "621CC013").
+func (pk *PublicKeyV3) KeyIdShortString() string {
+	return fmt.Sprintf("%X", pk.KeyId&0xFFFFFFFF)
+}
+
+// BitLength returns the bit length for the given public key.
+func (pk *PublicKeyV3) BitLength() (bitLength uint16, err error) {
+	switch pk.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:
+		bitLength = pk.n.bitLength
+	default:
+		err = errors.InvalidArgumentError("bad public-key algorithm")
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/reader.go b/vendor/golang.org/x/crypto/openpgp/packet/reader.go
new file mode 100644
index 0000000..34bc7c6
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/reader.go
@@ -0,0 +1,76 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"golang.org/x/crypto/openpgp/errors"
+	"io"
+)
+
+// Reader reads packets from an io.Reader and allows packets to be 'unread' so
+// that they result from the next call to Next.
+type Reader struct {
+	q       []Packet
+	readers []io.Reader
+}
+
+// New io.Readers are pushed when a compressed or encrypted packet is processed
+// and recursively treated as a new source of packets. However, a carefully
+// crafted packet can trigger an infinite recursive sequence of packets. See
+// http://mumble.net/~campbell/misc/pgp-quine
+// https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-4402
+// This constant limits the number of recursive packets that may be pushed.
+const maxReaders = 32
+
+// Next returns the most recently unread Packet, or reads another packet from
+// the top-most io.Reader. Unknown packet types are skipped.
+func (r *Reader) Next() (p Packet, err error) {
+	if len(r.q) > 0 {
+		p = r.q[len(r.q)-1]
+		r.q = r.q[:len(r.q)-1]
+		return
+	}
+
+	for len(r.readers) > 0 {
+		p, err = Read(r.readers[len(r.readers)-1])
+		if err == nil {
+			return
+		}
+		if err == io.EOF {
+			r.readers = r.readers[:len(r.readers)-1]
+			continue
+		}
+		if _, ok := err.(errors.UnknownPacketTypeError); !ok {
+			return nil, err
+		}
+	}
+
+	return nil, io.EOF
+}
+
+// Push causes the Reader to start reading from a new io.Reader. When an EOF
+// error is seen from the new io.Reader, it is popped and the Reader continues
+// to read from the next most recent io.Reader. Push returns a StructuralError
+// if pushing the reader would exceed the maximum recursion level, otherwise it
+// returns nil.
+func (r *Reader) Push(reader io.Reader) (err error) {
+	if len(r.readers) >= maxReaders {
+		return errors.StructuralError("too many layers of packets")
+	}
+	r.readers = append(r.readers, reader)
+	return nil
+}
+
+// Unread causes the given Packet to be returned from the next call to Next.
+func (r *Reader) Unread(p Packet) {
+	r.q = append(r.q, p)
+}
+
+func NewReader(r io.Reader) *Reader {
+	return &Reader{
+		q:       nil,
+		readers: []io.Reader{r},
+	}
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/signature.go b/vendor/golang.org/x/crypto/openpgp/packet/signature.go
new file mode 100644
index 0000000..6ce0cbe
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/signature.go
@@ -0,0 +1,731 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"crypto"
+	"crypto/dsa"
+	"crypto/ecdsa"
+	"encoding/asn1"
+	"encoding/binary"
+	"hash"
+	"io"
+	"math/big"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/s2k"
+)
+
+const (
+	// See RFC 4880, section 5.2.3.21 for details.
+	KeyFlagCertify = 1 << iota
+	KeyFlagSign
+	KeyFlagEncryptCommunications
+	KeyFlagEncryptStorage
+)
+
+// Signature represents a signature. See RFC 4880, section 5.2.
+type Signature struct {
+	SigType    SignatureType
+	PubKeyAlgo PublicKeyAlgorithm
+	Hash       crypto.Hash
+
+	// HashSuffix is extra data that is hashed in after the signed data.
+	HashSuffix []byte
+	// HashTag contains the first two bytes of the hash for fast rejection
+	// of bad signed data.
+	HashTag      [2]byte
+	CreationTime time.Time
+
+	RSASignature         parsedMPI
+	DSASigR, DSASigS     parsedMPI
+	ECDSASigR, ECDSASigS parsedMPI
+
+	// rawSubpackets contains the unparsed subpackets, in order.
+	rawSubpackets []outputSubpacket
+
+	// The following are optional so are nil when not included in the
+	// signature.
+
+	SigLifetimeSecs, KeyLifetimeSecs                        *uint32
+	PreferredSymmetric, PreferredHash, PreferredCompression []uint8
+	IssuerKeyId                                             *uint64
+	IsPrimaryId                                             *bool
+
+	// FlagsValid is set if any flags were given. See RFC 4880, section
+	// 5.2.3.21 for details.
+	FlagsValid                                                           bool
+	FlagCertify, FlagSign, FlagEncryptCommunications, FlagEncryptStorage bool
+
+	// RevocationReason is set if this signature has been revoked.
+	// See RFC 4880, section 5.2.3.23 for details.
+	RevocationReason     *uint8
+	RevocationReasonText string
+
+	// MDC is set if this signature has a feature packet that indicates
+	// support for MDC subpackets.
+	MDC bool
+
+	// EmbeddedSignature, if non-nil, is a signature of the parent key, by
+	// this key. This prevents an attacker from claiming another's signing
+	// subkey as their own.
+	EmbeddedSignature *Signature
+
+	outSubpackets []outputSubpacket
+}
+
+func (sig *Signature) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.2.3
+	var buf [5]byte
+	_, err = readFull(r, buf[:1])
+	if err != nil {
+		return
+	}
+	if buf[0] != 4 {
+		err = errors.UnsupportedError("signature packet version " + strconv.Itoa(int(buf[0])))
+		return
+	}
+
+	_, err = readFull(r, buf[:5])
+	if err != nil {
+		return
+	}
+	sig.SigType = SignatureType(buf[0])
+	sig.PubKeyAlgo = PublicKeyAlgorithm(buf[1])
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA, PubKeyAlgoECDSA:
+	default:
+		err = errors.UnsupportedError("public key algorithm " + strconv.Itoa(int(sig.PubKeyAlgo)))
+		return
+	}
+
+	var ok bool
+	sig.Hash, ok = s2k.HashIdToHash(buf[2])
+	if !ok {
+		return errors.UnsupportedError("hash function " + strconv.Itoa(int(buf[2])))
+	}
+
+	hashedSubpacketsLength := int(buf[3])<<8 | int(buf[4])
+	l := 6 + hashedSubpacketsLength
+	sig.HashSuffix = make([]byte, l+6)
+	sig.HashSuffix[0] = 4
+	copy(sig.HashSuffix[1:], buf[:5])
+	hashedSubpackets := sig.HashSuffix[6:l]
+	_, err = readFull(r, hashedSubpackets)
+	if err != nil {
+		return
+	}
+	// See RFC 4880, section 5.2.4
+	trailer := sig.HashSuffix[l:]
+	trailer[0] = 4
+	trailer[1] = 0xff
+	trailer[2] = uint8(l >> 24)
+	trailer[3] = uint8(l >> 16)
+	trailer[4] = uint8(l >> 8)
+	trailer[5] = uint8(l)
+
+	err = parseSignatureSubpackets(sig, hashedSubpackets, true)
+	if err != nil {
+		return
+	}
+
+	_, err = readFull(r, buf[:2])
+	if err != nil {
+		return
+	}
+	unhashedSubpacketsLength := int(buf[0])<<8 | int(buf[1])
+	unhashedSubpackets := make([]byte, unhashedSubpacketsLength)
+	_, err = readFull(r, unhashedSubpackets)
+	if err != nil {
+		return
+	}
+	err = parseSignatureSubpackets(sig, unhashedSubpackets, false)
+	if err != nil {
+		return
+	}
+
+	_, err = readFull(r, sig.HashTag[:2])
+	if err != nil {
+		return
+	}
+
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		sig.RSASignature.bytes, sig.RSASignature.bitLength, err = readMPI(r)
+	case PubKeyAlgoDSA:
+		sig.DSASigR.bytes, sig.DSASigR.bitLength, err = readMPI(r)
+		if err == nil {
+			sig.DSASigS.bytes, sig.DSASigS.bitLength, err = readMPI(r)
+		}
+	case PubKeyAlgoECDSA:
+		sig.ECDSASigR.bytes, sig.ECDSASigR.bitLength, err = readMPI(r)
+		if err == nil {
+			sig.ECDSASigS.bytes, sig.ECDSASigS.bitLength, err = readMPI(r)
+		}
+	default:
+		panic("unreachable")
+	}
+	return
+}
+
+// parseSignatureSubpackets parses subpackets of the main signature packet. See
+// RFC 4880, section 5.2.3.1.
+func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool) (err error) {
+	for len(subpackets) > 0 {
+		subpackets, err = parseSignatureSubpacket(sig, subpackets, isHashed)
+		if err != nil {
+			return
+		}
+	}
+
+	if sig.CreationTime.IsZero() {
+		err = errors.StructuralError("no creation time in signature")
+	}
+
+	return
+}
+
+type signatureSubpacketType uint8
+
+const (
+	creationTimeSubpacket        signatureSubpacketType = 2
+	signatureExpirationSubpacket signatureSubpacketType = 3
+	keyExpirationSubpacket       signatureSubpacketType = 9
+	prefSymmetricAlgosSubpacket  signatureSubpacketType = 11
+	issuerSubpacket              signatureSubpacketType = 16
+	prefHashAlgosSubpacket       signatureSubpacketType = 21
+	prefCompressionSubpacket     signatureSubpacketType = 22
+	primaryUserIdSubpacket       signatureSubpacketType = 25
+	keyFlagsSubpacket            signatureSubpacketType = 27
+	reasonForRevocationSubpacket signatureSubpacketType = 29
+	featuresSubpacket            signatureSubpacketType = 30
+	embeddedSignatureSubpacket   signatureSubpacketType = 32
+)
+
+// parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.
+func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err error) {
+	// RFC 4880, section 5.2.3.1
+	var (
+		length     uint32
+		packetType signatureSubpacketType
+		isCritical bool
+	)
+	switch {
+	case subpacket[0] < 192:
+		length = uint32(subpacket[0])
+		subpacket = subpacket[1:]
+	case subpacket[0] < 255:
+		if len(subpacket) < 2 {
+			goto Truncated
+		}
+		length = uint32(subpacket[0]-192)<<8 + uint32(subpacket[1]) + 192
+		subpacket = subpacket[2:]
+	default:
+		if len(subpacket) < 5 {
+			goto Truncated
+		}
+		length = uint32(subpacket[1])<<24 |
+			uint32(subpacket[2])<<16 |
+			uint32(subpacket[3])<<8 |
+			uint32(subpacket[4])
+		subpacket = subpacket[5:]
+	}
+	if length > uint32(len(subpacket)) {
+		goto Truncated
+	}
+	rest = subpacket[length:]
+	subpacket = subpacket[:length]
+	if len(subpacket) == 0 {
+		err = errors.StructuralError("zero length signature subpacket")
+		return
+	}
+	packetType = signatureSubpacketType(subpacket[0] & 0x7f)
+	isCritical = subpacket[0]&0x80 == 0x80
+	subpacket = subpacket[1:]
+	sig.rawSubpackets = append(sig.rawSubpackets, outputSubpacket{isHashed, packetType, isCritical, subpacket})
+	switch packetType {
+	case creationTimeSubpacket:
+		if !isHashed {
+			err = errors.StructuralError("signature creation time in non-hashed area")
+			return
+		}
+		if len(subpacket) != 4 {
+			err = errors.StructuralError("signature creation time not four bytes")
+			return
+		}
+		t := binary.BigEndian.Uint32(subpacket)
+		sig.CreationTime = time.Unix(int64(t), 0)
+	case signatureExpirationSubpacket:
+		// Signature expiration time, section 5.2.3.10
+		if !isHashed {
+			return
+		}
+		if len(subpacket) != 4 {
+			err = errors.StructuralError("expiration subpacket with bad length")
+			return
+		}
+		sig.SigLifetimeSecs = new(uint32)
+		*sig.SigLifetimeSecs = binary.BigEndian.Uint32(subpacket)
+	case keyExpirationSubpacket:
+		// Key expiration time, section 5.2.3.6
+		if !isHashed {
+			return
+		}
+		if len(subpacket) != 4 {
+			err = errors.StructuralError("key expiration subpacket with bad length")
+			return
+		}
+		sig.KeyLifetimeSecs = new(uint32)
+		*sig.KeyLifetimeSecs = binary.BigEndian.Uint32(subpacket)
+	case prefSymmetricAlgosSubpacket:
+		// Preferred symmetric algorithms, section 5.2.3.7
+		if !isHashed {
+			return
+		}
+		sig.PreferredSymmetric = make([]byte, len(subpacket))
+		copy(sig.PreferredSymmetric, subpacket)
+	case issuerSubpacket:
+		// Issuer, section 5.2.3.5
+		if len(subpacket) != 8 {
+			err = errors.StructuralError("issuer subpacket with bad length")
+			return
+		}
+		sig.IssuerKeyId = new(uint64)
+		*sig.IssuerKeyId = binary.BigEndian.Uint64(subpacket)
+	case prefHashAlgosSubpacket:
+		// Preferred hash algorithms, section 5.2.3.8
+		if !isHashed {
+			return
+		}
+		sig.PreferredHash = make([]byte, len(subpacket))
+		copy(sig.PreferredHash, subpacket)
+	case prefCompressionSubpacket:
+		// Preferred compression algorithms, section 5.2.3.9
+		if !isHashed {
+			return
+		}
+		sig.PreferredCompression = make([]byte, len(subpacket))
+		copy(sig.PreferredCompression, subpacket)
+	case primaryUserIdSubpacket:
+		// Primary User ID, section 5.2.3.19
+		if !isHashed {
+			return
+		}
+		if len(subpacket) != 1 {
+			err = errors.StructuralError("primary user id subpacket with bad length")
+			return
+		}
+		sig.IsPrimaryId = new(bool)
+		if subpacket[0] > 0 {
+			*sig.IsPrimaryId = true
+		}
+	case keyFlagsSubpacket:
+		// Key flags, section 5.2.3.21
+		if !isHashed {
+			return
+		}
+		if len(subpacket) == 0 {
+			err = errors.StructuralError("empty key flags subpacket")
+			return
+		}
+		sig.FlagsValid = true
+		if subpacket[0]&KeyFlagCertify != 0 {
+			sig.FlagCertify = true
+		}
+		if subpacket[0]&KeyFlagSign != 0 {
+			sig.FlagSign = true
+		}
+		if subpacket[0]&KeyFlagEncryptCommunications != 0 {
+			sig.FlagEncryptCommunications = true
+		}
+		if subpacket[0]&KeyFlagEncryptStorage != 0 {
+			sig.FlagEncryptStorage = true
+		}
+	case reasonForRevocationSubpacket:
+		// Reason For Revocation, section 5.2.3.23
+		if !isHashed {
+			return
+		}
+		if len(subpacket) == 0 {
+			err = errors.StructuralError("empty revocation reason subpacket")
+			return
+		}
+		sig.RevocationReason = new(uint8)
+		*sig.RevocationReason = subpacket[0]
+		sig.RevocationReasonText = string(subpacket[1:])
+	case featuresSubpacket:
+		// Features subpacket, section 5.2.3.24 specifies a very general
+		// mechanism for OpenPGP implementations to signal support for new
+		// features. In practice, the subpacket is used exclusively to
+		// indicate support for MDC-protected encryption.
+		sig.MDC = len(subpacket) >= 1 && subpacket[0]&1 == 1
+	case embeddedSignatureSubpacket:
+		// Only usage is in signatures that cross-certify
+		// signing subkeys. section 5.2.3.26 describes the
+		// format, with its usage described in section 11.1
+		if sig.EmbeddedSignature != nil {
+			err = errors.StructuralError("Cannot have multiple embedded signatures")
+			return
+		}
+		sig.EmbeddedSignature = new(Signature)
+		// Embedded signatures are required to be v4 signatures see
+		// section 12.1. However, we only parse v4 signatures in this
+		// file anyway.
+		if err := sig.EmbeddedSignature.parse(bytes.NewBuffer(subpacket)); err != nil {
+			return nil, err
+		}
+		if sigType := sig.EmbeddedSignature.SigType; sigType != SigTypePrimaryKeyBinding {
+			return nil, errors.StructuralError("cross-signature has unexpected type " + strconv.Itoa(int(sigType)))
+		}
+	default:
+		if isCritical {
+			err = errors.UnsupportedError("unknown critical signature subpacket type " + strconv.Itoa(int(packetType)))
+			return
+		}
+	}
+	return
+
+Truncated:
+	err = errors.StructuralError("signature subpacket truncated")
+	return
+}
+
+// subpacketLengthLength returns the length, in bytes, of an encoded length value.
+func subpacketLengthLength(length int) int {
+	if length < 192 {
+		return 1
+	}
+	if length < 16320 {
+		return 2
+	}
+	return 5
+}
+
+// serializeSubpacketLength marshals the given length into to.
+func serializeSubpacketLength(to []byte, length int) int {
+	// RFC 4880, Section 4.2.2.
+	if length < 192 {
+		to[0] = byte(length)
+		return 1
+	}
+	if length < 16320 {
+		length -= 192
+		to[0] = byte((length >> 8) + 192)
+		to[1] = byte(length)
+		return 2
+	}
+	to[0] = 255
+	to[1] = byte(length >> 24)
+	to[2] = byte(length >> 16)
+	to[3] = byte(length >> 8)
+	to[4] = byte(length)
+	return 5
+}
+
+// subpacketsLength returns the serialized length, in bytes, of the given
+// subpackets.
+func subpacketsLength(subpackets []outputSubpacket, hashed bool) (length int) {
+	for _, subpacket := range subpackets {
+		if subpacket.hashed == hashed {
+			length += subpacketLengthLength(len(subpacket.contents) + 1)
+			length += 1 // type byte
+			length += len(subpacket.contents)
+		}
+	}
+	return
+}
+
+// serializeSubpackets marshals the given subpackets into to.
+func serializeSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {
+	for _, subpacket := range subpackets {
+		if subpacket.hashed == hashed {
+			n := serializeSubpacketLength(to, len(subpacket.contents)+1)
+			to[n] = byte(subpacket.subpacketType)
+			to = to[1+n:]
+			n = copy(to, subpacket.contents)
+			to = to[n:]
+		}
+	}
+	return
+}
+
+// KeyExpired returns whether sig is a self-signature of a key that has
+// expired.
+func (sig *Signature) KeyExpired(currentTime time.Time) bool {
+	if sig.KeyLifetimeSecs == nil {
+		return false
+	}
+	expiry := sig.CreationTime.Add(time.Duration(*sig.KeyLifetimeSecs) * time.Second)
+	return currentTime.After(expiry)
+}
+
+// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.
+func (sig *Signature) buildHashSuffix() (err error) {
+	hashedSubpacketsLen := subpacketsLength(sig.outSubpackets, true)
+
+	var ok bool
+	l := 6 + hashedSubpacketsLen
+	sig.HashSuffix = make([]byte, l+6)
+	sig.HashSuffix[0] = 4
+	sig.HashSuffix[1] = uint8(sig.SigType)
+	sig.HashSuffix[2] = uint8(sig.PubKeyAlgo)
+	sig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)
+	if !ok {
+		sig.HashSuffix = nil
+		return errors.InvalidArgumentError("hash cannot be represented in OpenPGP: " + strconv.Itoa(int(sig.Hash)))
+	}
+	sig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)
+	sig.HashSuffix[5] = byte(hashedSubpacketsLen)
+	serializeSubpackets(sig.HashSuffix[6:l], sig.outSubpackets, true)
+	trailer := sig.HashSuffix[l:]
+	trailer[0] = 4
+	trailer[1] = 0xff
+	trailer[2] = byte(l >> 24)
+	trailer[3] = byte(l >> 16)
+	trailer[4] = byte(l >> 8)
+	trailer[5] = byte(l)
+	return
+}
+
+func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err error) {
+	err = sig.buildHashSuffix()
+	if err != nil {
+		return
+	}
+
+	h.Write(sig.HashSuffix)
+	digest = h.Sum(nil)
+	copy(sig.HashTag[:], digest)
+	return
+}
+
+// Sign signs a message with a private key. The hash, h, must contain
+// the hash of the message to be signed and will be mutated by this function.
+// On success, the signature is stored in sig. Call Serialize to write it out.
+// If config is nil, sensible defaults will be used.
+func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey, config *Config) (err error) {
+	sig.outSubpackets = sig.buildSubpackets()
+	digest, err := sig.signPrepareHash(h)
+	if err != nil {
+		return
+	}
+
+	switch priv.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		// supports both *rsa.PrivateKey and crypto.Signer
+		sig.RSASignature.bytes, err = priv.PrivateKey.(crypto.Signer).Sign(config.Random(), digest, sig.Hash)
+		sig.RSASignature.bitLength = uint16(8 * len(sig.RSASignature.bytes))
+	case PubKeyAlgoDSA:
+		dsaPriv := priv.PrivateKey.(*dsa.PrivateKey)
+
+		// Need to truncate hashBytes to match FIPS 186-3 section 4.6.
+		subgroupSize := (dsaPriv.Q.BitLen() + 7) / 8
+		if len(digest) > subgroupSize {
+			digest = digest[:subgroupSize]
+		}
+		r, s, err := dsa.Sign(config.Random(), dsaPriv, digest)
+		if err == nil {
+			sig.DSASigR.bytes = r.Bytes()
+			sig.DSASigR.bitLength = uint16(8 * len(sig.DSASigR.bytes))
+			sig.DSASigS.bytes = s.Bytes()
+			sig.DSASigS.bitLength = uint16(8 * len(sig.DSASigS.bytes))
+		}
+	case PubKeyAlgoECDSA:
+		var r, s *big.Int
+		if pk, ok := priv.PrivateKey.(*ecdsa.PrivateKey); ok {
+			// direct support, avoid asn1 wrapping/unwrapping
+			r, s, err = ecdsa.Sign(config.Random(), pk, digest)
+		} else {
+			var b []byte
+			b, err = priv.PrivateKey.(crypto.Signer).Sign(config.Random(), digest, nil)
+			if err == nil {
+				r, s, err = unwrapECDSASig(b)
+			}
+		}
+		if err == nil {
+			sig.ECDSASigR = fromBig(r)
+			sig.ECDSASigS = fromBig(s)
+		}
+	default:
+		err = errors.UnsupportedError("public key algorithm: " + strconv.Itoa(int(sig.PubKeyAlgo)))
+	}
+
+	return
+}
+
+// unwrapECDSASig parses the two integer components of an ASN.1-encoded ECDSA
+// signature.
+func unwrapECDSASig(b []byte) (r, s *big.Int, err error) {
+	var ecsdaSig struct {
+		R, S *big.Int
+	}
+	_, err = asn1.Unmarshal(b, &ecsdaSig)
+	if err != nil {
+		return
+	}
+	return ecsdaSig.R, ecsdaSig.S, nil
+}
+
+// SignUserId computes a signature from priv, asserting that pub is a valid
+// key for the identity id.  On success, the signature is stored in sig. Call
+// Serialize to write it out.
+// If config is nil, sensible defaults will be used.
+func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey, config *Config) error {
+	h, err := userIdSignatureHash(id, pub, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return sig.Sign(h, priv, config)
+}
+
+// SignKey computes a signature from priv, asserting that pub is a subkey. On
+// success, the signature is stored in sig. Call Serialize to write it out.
+// If config is nil, sensible defaults will be used.
+func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey, config *Config) error {
+	h, err := keySignatureHash(&priv.PublicKey, pub, sig.Hash)
+	if err != nil {
+		return err
+	}
+	return sig.Sign(h, priv, config)
+}
+
+// Serialize marshals sig to w. Sign, SignUserId or SignKey must have been
+// called first.
+func (sig *Signature) Serialize(w io.Writer) (err error) {
+	if len(sig.outSubpackets) == 0 {
+		sig.outSubpackets = sig.rawSubpackets
+	}
+	if sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil && sig.ECDSASigR.bytes == nil {
+		return errors.InvalidArgumentError("Signature: need to call Sign, SignUserId or SignKey before Serialize")
+	}
+
+	sigLength := 0
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		sigLength = 2 + len(sig.RSASignature.bytes)
+	case PubKeyAlgoDSA:
+		sigLength = 2 + len(sig.DSASigR.bytes)
+		sigLength += 2 + len(sig.DSASigS.bytes)
+	case PubKeyAlgoECDSA:
+		sigLength = 2 + len(sig.ECDSASigR.bytes)
+		sigLength += 2 + len(sig.ECDSASigS.bytes)
+	default:
+		panic("impossible")
+	}
+
+	unhashedSubpacketsLen := subpacketsLength(sig.outSubpackets, false)
+	length := len(sig.HashSuffix) - 6 /* trailer not included */ +
+		2 /* length of unhashed subpackets */ + unhashedSubpacketsLen +
+		2 /* hash tag */ + sigLength
+	err = serializeHeader(w, packetTypeSignature, length)
+	if err != nil {
+		return
+	}
+
+	_, err = w.Write(sig.HashSuffix[:len(sig.HashSuffix)-6])
+	if err != nil {
+		return
+	}
+
+	unhashedSubpackets := make([]byte, 2+unhashedSubpacketsLen)
+	unhashedSubpackets[0] = byte(unhashedSubpacketsLen >> 8)
+	unhashedSubpackets[1] = byte(unhashedSubpacketsLen)
+	serializeSubpackets(unhashedSubpackets[2:], sig.outSubpackets, false)
+
+	_, err = w.Write(unhashedSubpackets)
+	if err != nil {
+		return
+	}
+	_, err = w.Write(sig.HashTag[:])
+	if err != nil {
+		return
+	}
+
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		err = writeMPIs(w, sig.RSASignature)
+	case PubKeyAlgoDSA:
+		err = writeMPIs(w, sig.DSASigR, sig.DSASigS)
+	case PubKeyAlgoECDSA:
+		err = writeMPIs(w, sig.ECDSASigR, sig.ECDSASigS)
+	default:
+		panic("impossible")
+	}
+	return
+}
+
+// outputSubpacket represents a subpacket to be marshaled.
+type outputSubpacket struct {
+	hashed        bool // true if this subpacket is in the hashed area.
+	subpacketType signatureSubpacketType
+	isCritical    bool
+	contents      []byte
+}
+
+func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {
+	creationTime := make([]byte, 4)
+	binary.BigEndian.PutUint32(creationTime, uint32(sig.CreationTime.Unix()))
+	subpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, false, creationTime})
+
+	if sig.IssuerKeyId != nil {
+		keyId := make([]byte, 8)
+		binary.BigEndian.PutUint64(keyId, *sig.IssuerKeyId)
+		subpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, false, keyId})
+	}
+
+	if sig.SigLifetimeSecs != nil && *sig.SigLifetimeSecs != 0 {
+		sigLifetime := make([]byte, 4)
+		binary.BigEndian.PutUint32(sigLifetime, *sig.SigLifetimeSecs)
+		subpackets = append(subpackets, outputSubpacket{true, signatureExpirationSubpacket, true, sigLifetime})
+	}
+
+	// Key flags may only appear in self-signatures or certification signatures.
+
+	if sig.FlagsValid {
+		var flags byte
+		if sig.FlagCertify {
+			flags |= KeyFlagCertify
+		}
+		if sig.FlagSign {
+			flags |= KeyFlagSign
+		}
+		if sig.FlagEncryptCommunications {
+			flags |= KeyFlagEncryptCommunications
+		}
+		if sig.FlagEncryptStorage {
+			flags |= KeyFlagEncryptStorage
+		}
+		subpackets = append(subpackets, outputSubpacket{true, keyFlagsSubpacket, false, []byte{flags}})
+	}
+
+	// The following subpackets may only appear in self-signatures
+
+	if sig.KeyLifetimeSecs != nil && *sig.KeyLifetimeSecs != 0 {
+		keyLifetime := make([]byte, 4)
+		binary.BigEndian.PutUint32(keyLifetime, *sig.KeyLifetimeSecs)
+		subpackets = append(subpackets, outputSubpacket{true, keyExpirationSubpacket, true, keyLifetime})
+	}
+
+	if sig.IsPrimaryId != nil && *sig.IsPrimaryId {
+		subpackets = append(subpackets, outputSubpacket{true, primaryUserIdSubpacket, false, []byte{1}})
+	}
+
+	if len(sig.PreferredSymmetric) > 0 {
+		subpackets = append(subpackets, outputSubpacket{true, prefSymmetricAlgosSubpacket, false, sig.PreferredSymmetric})
+	}
+
+	if len(sig.PreferredHash) > 0 {
+		subpackets = append(subpackets, outputSubpacket{true, prefHashAlgosSubpacket, false, sig.PreferredHash})
+	}
+
+	if len(sig.PreferredCompression) > 0 {
+		subpackets = append(subpackets, outputSubpacket{true, prefCompressionSubpacket, false, sig.PreferredCompression})
+	}
+
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/signature_v3.go b/vendor/golang.org/x/crypto/openpgp/packet/signature_v3.go
new file mode 100644
index 0000000..6edff88
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/signature_v3.go
@@ -0,0 +1,146 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto"
+	"encoding/binary"
+	"fmt"
+	"io"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/s2k"
+)
+
+// SignatureV3 represents older version 3 signatures. These signatures are less secure
+// than version 4 and should not be used to create new signatures. They are included
+// here for backwards compatibility to read and validate with older key material.
+// See RFC 4880, section 5.2.2.
+type SignatureV3 struct {
+	SigType      SignatureType
+	CreationTime time.Time
+	IssuerKeyId  uint64
+	PubKeyAlgo   PublicKeyAlgorithm
+	Hash         crypto.Hash
+	HashTag      [2]byte
+
+	RSASignature     parsedMPI
+	DSASigR, DSASigS parsedMPI
+}
+
+func (sig *SignatureV3) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.2.2
+	var buf [8]byte
+	if _, err = readFull(r, buf[:1]); err != nil {
+		return
+	}
+	if buf[0] < 2 || buf[0] > 3 {
+		err = errors.UnsupportedError("signature packet version " + strconv.Itoa(int(buf[0])))
+		return
+	}
+	if _, err = readFull(r, buf[:1]); err != nil {
+		return
+	}
+	if buf[0] != 5 {
+		err = errors.UnsupportedError(
+			"invalid hashed material length " + strconv.Itoa(int(buf[0])))
+		return
+	}
+
+	// Read hashed material: signature type + creation time
+	if _, err = readFull(r, buf[:5]); err != nil {
+		return
+	}
+	sig.SigType = SignatureType(buf[0])
+	t := binary.BigEndian.Uint32(buf[1:5])
+	sig.CreationTime = time.Unix(int64(t), 0)
+
+	// Eight-octet Key ID of signer.
+	if _, err = readFull(r, buf[:8]); err != nil {
+		return
+	}
+	sig.IssuerKeyId = binary.BigEndian.Uint64(buf[:])
+
+	// Public-key and hash algorithm
+	if _, err = readFull(r, buf[:2]); err != nil {
+		return
+	}
+	sig.PubKeyAlgo = PublicKeyAlgorithm(buf[0])
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:
+	default:
+		err = errors.UnsupportedError("public key algorithm " + strconv.Itoa(int(sig.PubKeyAlgo)))
+		return
+	}
+	var ok bool
+	if sig.Hash, ok = s2k.HashIdToHash(buf[1]); !ok {
+		return errors.UnsupportedError("hash function " + strconv.Itoa(int(buf[2])))
+	}
+
+	// Two-octet field holding left 16 bits of signed hash value.
+	if _, err = readFull(r, sig.HashTag[:2]); err != nil {
+		return
+	}
+
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		sig.RSASignature.bytes, sig.RSASignature.bitLength, err = readMPI(r)
+	case PubKeyAlgoDSA:
+		if sig.DSASigR.bytes, sig.DSASigR.bitLength, err = readMPI(r); err != nil {
+			return
+		}
+		sig.DSASigS.bytes, sig.DSASigS.bitLength, err = readMPI(r)
+	default:
+		panic("unreachable")
+	}
+	return
+}
+
+// Serialize marshals sig to w. Sign, SignUserId or SignKey must have been
+// called first.
+func (sig *SignatureV3) Serialize(w io.Writer) (err error) {
+	buf := make([]byte, 8)
+
+	// Write the sig type and creation time
+	buf[0] = byte(sig.SigType)
+	binary.BigEndian.PutUint32(buf[1:5], uint32(sig.CreationTime.Unix()))
+	if _, err = w.Write(buf[:5]); err != nil {
+		return
+	}
+
+	// Write the issuer long key ID
+	binary.BigEndian.PutUint64(buf[:8], sig.IssuerKeyId)
+	if _, err = w.Write(buf[:8]); err != nil {
+		return
+	}
+
+	// Write public key algorithm, hash ID, and hash value
+	buf[0] = byte(sig.PubKeyAlgo)
+	hashId, ok := s2k.HashToHashId(sig.Hash)
+	if !ok {
+		return errors.UnsupportedError(fmt.Sprintf("hash function %v", sig.Hash))
+	}
+	buf[1] = hashId
+	copy(buf[2:4], sig.HashTag[:])
+	if _, err = w.Write(buf[:4]); err != nil {
+		return
+	}
+
+	if sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil {
+		return errors.InvalidArgumentError("Signature: need to call Sign, SignUserId or SignKey before Serialize")
+	}
+
+	switch sig.PubKeyAlgo {
+	case PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:
+		err = writeMPIs(w, sig.RSASignature)
+	case PubKeyAlgoDSA:
+		err = writeMPIs(w, sig.DSASigR, sig.DSASigS)
+	default:
+		panic("impossible")
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/symmetric_key_encrypted.go b/vendor/golang.org/x/crypto/openpgp/packet/symmetric_key_encrypted.go
new file mode 100644
index 0000000..744c2d2
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/symmetric_key_encrypted.go
@@ -0,0 +1,155 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"crypto/cipher"
+	"io"
+	"strconv"
+
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/s2k"
+)
+
+// This is the largest session key that we'll support. Since no 512-bit cipher
+// has even been seriously used, this is comfortably large.
+const maxSessionKeySizeInBytes = 64
+
+// SymmetricKeyEncrypted represents a passphrase protected session key. See RFC
+// 4880, section 5.3.
+type SymmetricKeyEncrypted struct {
+	CipherFunc   CipherFunction
+	s2k          func(out, in []byte)
+	encryptedKey []byte
+}
+
+const symmetricKeyEncryptedVersion = 4
+
+func (ske *SymmetricKeyEncrypted) parse(r io.Reader) error {
+	// RFC 4880, section 5.3.
+	var buf [2]byte
+	if _, err := readFull(r, buf[:]); err != nil {
+		return err
+	}
+	if buf[0] != symmetricKeyEncryptedVersion {
+		return errors.UnsupportedError("SymmetricKeyEncrypted version")
+	}
+	ske.CipherFunc = CipherFunction(buf[1])
+
+	if ske.CipherFunc.KeySize() == 0 {
+		return errors.UnsupportedError("unknown cipher: " + strconv.Itoa(int(buf[1])))
+	}
+
+	var err error
+	ske.s2k, err = s2k.Parse(r)
+	if err != nil {
+		return err
+	}
+
+	encryptedKey := make([]byte, maxSessionKeySizeInBytes)
+	// The session key may follow. We just have to try and read to find
+	// out. If it exists then we limit it to maxSessionKeySizeInBytes.
+	n, err := readFull(r, encryptedKey)
+	if err != nil && err != io.ErrUnexpectedEOF {
+		return err
+	}
+
+	if n != 0 {
+		if n == maxSessionKeySizeInBytes {
+			return errors.UnsupportedError("oversized encrypted session key")
+		}
+		ske.encryptedKey = encryptedKey[:n]
+	}
+
+	return nil
+}
+
+// Decrypt attempts to decrypt an encrypted session key and returns the key and
+// the cipher to use when decrypting a subsequent Symmetrically Encrypted Data
+// packet.
+func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) ([]byte, CipherFunction, error) {
+	key := make([]byte, ske.CipherFunc.KeySize())
+	ske.s2k(key, passphrase)
+
+	if len(ske.encryptedKey) == 0 {
+		return key, ske.CipherFunc, nil
+	}
+
+	// the IV is all zeros
+	iv := make([]byte, ske.CipherFunc.blockSize())
+	c := cipher.NewCFBDecrypter(ske.CipherFunc.new(key), iv)
+	plaintextKey := make([]byte, len(ske.encryptedKey))
+	c.XORKeyStream(plaintextKey, ske.encryptedKey)
+	cipherFunc := CipherFunction(plaintextKey[0])
+	if cipherFunc.blockSize() == 0 {
+		return nil, ske.CipherFunc, errors.UnsupportedError("unknown cipher: " + strconv.Itoa(int(cipherFunc)))
+	}
+	plaintextKey = plaintextKey[1:]
+	if l, cipherKeySize := len(plaintextKey), cipherFunc.KeySize(); l != cipherFunc.KeySize() {
+		return nil, cipherFunc, errors.StructuralError("length of decrypted key (" + strconv.Itoa(l) + ") " +
+			"not equal to cipher keysize (" + strconv.Itoa(cipherKeySize) + ")")
+	}
+	return plaintextKey, cipherFunc, nil
+}
+
+// SerializeSymmetricKeyEncrypted serializes a symmetric key packet to w. The
+// packet contains a random session key, encrypted by a key derived from the
+// given passphrase. The session key is returned and must be passed to
+// SerializeSymmetricallyEncrypted.
+// If config is nil, sensible defaults will be used.
+func SerializeSymmetricKeyEncrypted(w io.Writer, passphrase []byte, config *Config) (key []byte, err error) {
+	cipherFunc := config.Cipher()
+	keySize := cipherFunc.KeySize()
+	if keySize == 0 {
+		return nil, errors.UnsupportedError("unknown cipher: " + strconv.Itoa(int(cipherFunc)))
+	}
+
+	s2kBuf := new(bytes.Buffer)
+	keyEncryptingKey := make([]byte, keySize)
+	// s2k.Serialize salts and stretches the passphrase, and writes the
+	// resulting key to keyEncryptingKey and the s2k descriptor to s2kBuf.
+	err = s2k.Serialize(s2kBuf, keyEncryptingKey, config.Random(), passphrase, &s2k.Config{Hash: config.Hash(), S2KCount: config.PasswordHashIterations()})
+	if err != nil {
+		return
+	}
+	s2kBytes := s2kBuf.Bytes()
+
+	packetLength := 2 /* header */ + len(s2kBytes) + 1 /* cipher type */ + keySize
+	err = serializeHeader(w, packetTypeSymmetricKeyEncrypted, packetLength)
+	if err != nil {
+		return
+	}
+
+	var buf [2]byte
+	buf[0] = symmetricKeyEncryptedVersion
+	buf[1] = byte(cipherFunc)
+	_, err = w.Write(buf[:])
+	if err != nil {
+		return
+	}
+	_, err = w.Write(s2kBytes)
+	if err != nil {
+		return
+	}
+
+	sessionKey := make([]byte, keySize)
+	_, err = io.ReadFull(config.Random(), sessionKey)
+	if err != nil {
+		return
+	}
+	iv := make([]byte, cipherFunc.blockSize())
+	c := cipher.NewCFBEncrypter(cipherFunc.new(keyEncryptingKey), iv)
+	encryptedCipherAndKey := make([]byte, keySize+1)
+	c.XORKeyStream(encryptedCipherAndKey, buf[1:])
+	c.XORKeyStream(encryptedCipherAndKey[1:], sessionKey)
+	_, err = w.Write(encryptedCipherAndKey)
+	if err != nil {
+		return
+	}
+
+	key = sessionKey
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/symmetrically_encrypted.go b/vendor/golang.org/x/crypto/openpgp/packet/symmetrically_encrypted.go
new file mode 100644
index 0000000..6126030
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/symmetrically_encrypted.go
@@ -0,0 +1,290 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"crypto/cipher"
+	"crypto/sha1"
+	"crypto/subtle"
+	"golang.org/x/crypto/openpgp/errors"
+	"hash"
+	"io"
+	"strconv"
+)
+
+// SymmetricallyEncrypted represents a symmetrically encrypted byte string. The
+// encrypted contents will consist of more OpenPGP packets. See RFC 4880,
+// sections 5.7 and 5.13.
+type SymmetricallyEncrypted struct {
+	MDC      bool // true iff this is a type 18 packet and thus has an embedded MAC.
+	contents io.Reader
+	prefix   []byte
+}
+
+const symmetricallyEncryptedVersion = 1
+
+func (se *SymmetricallyEncrypted) parse(r io.Reader) error {
+	if se.MDC {
+		// See RFC 4880, section 5.13.
+		var buf [1]byte
+		_, err := readFull(r, buf[:])
+		if err != nil {
+			return err
+		}
+		if buf[0] != symmetricallyEncryptedVersion {
+			return errors.UnsupportedError("unknown SymmetricallyEncrypted version")
+		}
+	}
+	se.contents = r
+	return nil
+}
+
+// Decrypt returns a ReadCloser, from which the decrypted contents of the
+// packet can be read. An incorrect key can, with high probability, be detected
+// immediately and this will result in a KeyIncorrect error being returned.
+func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, error) {
+	keySize := c.KeySize()
+	if keySize == 0 {
+		return nil, errors.UnsupportedError("unknown cipher: " + strconv.Itoa(int(c)))
+	}
+	if len(key) != keySize {
+		return nil, errors.InvalidArgumentError("SymmetricallyEncrypted: incorrect key length")
+	}
+
+	if se.prefix == nil {
+		se.prefix = make([]byte, c.blockSize()+2)
+		_, err := readFull(se.contents, se.prefix)
+		if err != nil {
+			return nil, err
+		}
+	} else if len(se.prefix) != c.blockSize()+2 {
+		return nil, errors.InvalidArgumentError("can't try ciphers with different block lengths")
+	}
+
+	ocfbResync := OCFBResync
+	if se.MDC {
+		// MDC packets use a different form of OCFB mode.
+		ocfbResync = OCFBNoResync
+	}
+
+	s := NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)
+	if s == nil {
+		return nil, errors.ErrKeyIncorrect
+	}
+
+	plaintext := cipher.StreamReader{S: s, R: se.contents}
+
+	if se.MDC {
+		// MDC packets have an embedded hash that we need to check.
+		h := sha1.New()
+		h.Write(se.prefix)
+		return &seMDCReader{in: plaintext, h: h}, nil
+	}
+
+	// Otherwise, we just need to wrap plaintext so that it's a valid ReadCloser.
+	return seReader{plaintext}, nil
+}
+
+// seReader wraps an io.Reader with a no-op Close method.
+type seReader struct {
+	in io.Reader
+}
+
+func (ser seReader) Read(buf []byte) (int, error) {
+	return ser.in.Read(buf)
+}
+
+func (ser seReader) Close() error {
+	return nil
+}
+
+const mdcTrailerSize = 1 /* tag byte */ + 1 /* length byte */ + sha1.Size
+
+// An seMDCReader wraps an io.Reader, maintains a running hash and keeps hold
+// of the most recent 22 bytes (mdcTrailerSize). Upon EOF, those bytes form an
+// MDC packet containing a hash of the previous contents which is checked
+// against the running hash. See RFC 4880, section 5.13.
+type seMDCReader struct {
+	in          io.Reader
+	h           hash.Hash
+	trailer     [mdcTrailerSize]byte
+	scratch     [mdcTrailerSize]byte
+	trailerUsed int
+	error       bool
+	eof         bool
+}
+
+func (ser *seMDCReader) Read(buf []byte) (n int, err error) {
+	if ser.error {
+		err = io.ErrUnexpectedEOF
+		return
+	}
+	if ser.eof {
+		err = io.EOF
+		return
+	}
+
+	// If we haven't yet filled the trailer buffer then we must do that
+	// first.
+	for ser.trailerUsed < mdcTrailerSize {
+		n, err = ser.in.Read(ser.trailer[ser.trailerUsed:])
+		ser.trailerUsed += n
+		if err == io.EOF {
+			if ser.trailerUsed != mdcTrailerSize {
+				n = 0
+				err = io.ErrUnexpectedEOF
+				ser.error = true
+				return
+			}
+			ser.eof = true
+			n = 0
+			return
+		}
+
+		if err != nil {
+			n = 0
+			return
+		}
+	}
+
+	// If it's a short read then we read into a temporary buffer and shift
+	// the data into the caller's buffer.
+	if len(buf) <= mdcTrailerSize {
+		n, err = readFull(ser.in, ser.scratch[:len(buf)])
+		copy(buf, ser.trailer[:n])
+		ser.h.Write(buf[:n])
+		copy(ser.trailer[:], ser.trailer[n:])
+		copy(ser.trailer[mdcTrailerSize-n:], ser.scratch[:])
+		if n < len(buf) {
+			ser.eof = true
+			err = io.EOF
+		}
+		return
+	}
+
+	n, err = ser.in.Read(buf[mdcTrailerSize:])
+	copy(buf, ser.trailer[:])
+	ser.h.Write(buf[:n])
+	copy(ser.trailer[:], buf[n:])
+
+	if err == io.EOF {
+		ser.eof = true
+	}
+	return
+}
+
+// This is a new-format packet tag byte for a type 19 (MDC) packet.
+const mdcPacketTagByte = byte(0x80) | 0x40 | 19
+
+func (ser *seMDCReader) Close() error {
+	if ser.error {
+		return errors.SignatureError("error during reading")
+	}
+
+	for !ser.eof {
+		// We haven't seen EOF so we need to read to the end
+		var buf [1024]byte
+		_, err := ser.Read(buf[:])
+		if err == io.EOF {
+			break
+		}
+		if err != nil {
+			return errors.SignatureError("error during reading")
+		}
+	}
+
+	if ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {
+		return errors.SignatureError("MDC packet not found")
+	}
+	ser.h.Write(ser.trailer[:2])
+
+	final := ser.h.Sum(nil)
+	if subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {
+		return errors.SignatureError("hash mismatch")
+	}
+	return nil
+}
+
+// An seMDCWriter writes through to an io.WriteCloser while maintains a running
+// hash of the data written. On close, it emits an MDC packet containing the
+// running hash.
+type seMDCWriter struct {
+	w io.WriteCloser
+	h hash.Hash
+}
+
+func (w *seMDCWriter) Write(buf []byte) (n int, err error) {
+	w.h.Write(buf)
+	return w.w.Write(buf)
+}
+
+func (w *seMDCWriter) Close() (err error) {
+	var buf [mdcTrailerSize]byte
+
+	buf[0] = mdcPacketTagByte
+	buf[1] = sha1.Size
+	w.h.Write(buf[:2])
+	digest := w.h.Sum(nil)
+	copy(buf[2:], digest)
+
+	_, err = w.w.Write(buf[:])
+	if err != nil {
+		return
+	}
+	return w.w.Close()
+}
+
+// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.
+type noOpCloser struct {
+	w io.Writer
+}
+
+func (c noOpCloser) Write(data []byte) (n int, err error) {
+	return c.w.Write(data)
+}
+
+func (c noOpCloser) Close() error {
+	return nil
+}
+
+// SerializeSymmetricallyEncrypted serializes a symmetrically encrypted packet
+// to w and returns a WriteCloser to which the to-be-encrypted packets can be
+// written.
+// If config is nil, sensible defaults will be used.
+func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte, config *Config) (contents io.WriteCloser, err error) {
+	if c.KeySize() != len(key) {
+		return nil, errors.InvalidArgumentError("SymmetricallyEncrypted.Serialize: bad key length")
+	}
+	writeCloser := noOpCloser{w}
+	ciphertext, err := serializeStreamHeader(writeCloser, packetTypeSymmetricallyEncryptedMDC)
+	if err != nil {
+		return
+	}
+
+	_, err = ciphertext.Write([]byte{symmetricallyEncryptedVersion})
+	if err != nil {
+		return
+	}
+
+	block := c.new(key)
+	blockSize := block.BlockSize()
+	iv := make([]byte, blockSize)
+	_, err = config.Random().Read(iv)
+	if err != nil {
+		return
+	}
+	s, prefix := NewOCFBEncrypter(block, iv, OCFBNoResync)
+	_, err = ciphertext.Write(prefix)
+	if err != nil {
+		return
+	}
+	plaintext := cipher.StreamWriter{S: s, W: ciphertext}
+
+	h := sha1.New()
+	h.Write(iv)
+	h.Write(iv[blockSize-2:])
+	contents = &seMDCWriter{w: plaintext, h: h}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go b/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
new file mode 100644
index 0000000..96a2b38
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/userattribute.go
@@ -0,0 +1,91 @@
+// Copyright 2013 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"bytes"
+	"image"
+	"image/jpeg"
+	"io"
+	"io/ioutil"
+)
+
+const UserAttrImageSubpacket = 1
+
+// UserAttribute is capable of storing other types of data about a user
+// beyond name, email and a text comment. In practice, user attributes are typically used
+// to store a signed thumbnail photo JPEG image of the user.
+// See RFC 4880, section 5.12.
+type UserAttribute struct {
+	Contents []*OpaqueSubpacket
+}
+
+// NewUserAttributePhoto creates a user attribute packet
+// containing the given images.
+func NewUserAttributePhoto(photos ...image.Image) (uat *UserAttribute, err error) {
+	uat = new(UserAttribute)
+	for _, photo := range photos {
+		var buf bytes.Buffer
+		// RFC 4880, Section 5.12.1.
+		data := []byte{
+			0x10, 0x00, // Little-endian image header length (16 bytes)
+			0x01,       // Image header version 1
+			0x01,       // JPEG
+			0, 0, 0, 0, // 12 reserved octets, must be all zero.
+			0, 0, 0, 0,
+			0, 0, 0, 0}
+		if _, err = buf.Write(data); err != nil {
+			return
+		}
+		if err = jpeg.Encode(&buf, photo, nil); err != nil {
+			return
+		}
+		uat.Contents = append(uat.Contents, &OpaqueSubpacket{
+			SubType:  UserAttrImageSubpacket,
+			Contents: buf.Bytes()})
+	}
+	return
+}
+
+// NewUserAttribute creates a new user attribute packet containing the given subpackets.
+func NewUserAttribute(contents ...*OpaqueSubpacket) *UserAttribute {
+	return &UserAttribute{Contents: contents}
+}
+
+func (uat *UserAttribute) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.13
+	b, err := ioutil.ReadAll(r)
+	if err != nil {
+		return
+	}
+	uat.Contents, err = OpaqueSubpackets(b)
+	return
+}
+
+// Serialize marshals the user attribute to w in the form of an OpenPGP packet, including
+// header.
+func (uat *UserAttribute) Serialize(w io.Writer) (err error) {
+	var buf bytes.Buffer
+	for _, sp := range uat.Contents {
+		sp.Serialize(&buf)
+	}
+	if err = serializeHeader(w, packetTypeUserAttribute, buf.Len()); err != nil {
+		return err
+	}
+	_, err = w.Write(buf.Bytes())
+	return
+}
+
+// ImageData returns zero or more byte slices, each containing
+// JPEG File Interchange Format (JFIF), for each photo in the
+// the user attribute packet.
+func (uat *UserAttribute) ImageData() (imageData [][]byte) {
+	for _, sp := range uat.Contents {
+		if sp.SubType == UserAttrImageSubpacket && len(sp.Contents) > 16 {
+			imageData = append(imageData, sp.Contents[16:])
+		}
+	}
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/packet/userid.go b/vendor/golang.org/x/crypto/openpgp/packet/userid.go
new file mode 100644
index 0000000..d6bea7d
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/packet/userid.go
@@ -0,0 +1,160 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package packet
+
+import (
+	"io"
+	"io/ioutil"
+	"strings"
+)
+
+// UserId contains text that is intended to represent the name and email
+// address of the key holder. See RFC 4880, section 5.11. By convention, this
+// takes the form "Full Name (Comment) <email@example.com>"
+type UserId struct {
+	Id string // By convention, this takes the form "Full Name (Comment) <email@example.com>" which is split out in the fields below.
+
+	Name, Comment, Email string
+}
+
+func hasInvalidCharacters(s string) bool {
+	for _, c := range s {
+		switch c {
+		case '(', ')', '<', '>', 0:
+			return true
+		}
+	}
+	return false
+}
+
+// NewUserId returns a UserId or nil if any of the arguments contain invalid
+// characters. The invalid characters are '\x00', '(', ')', '<' and '>'
+func NewUserId(name, comment, email string) *UserId {
+	// RFC 4880 doesn't deal with the structure of userid strings; the
+	// name, comment and email form is just a convention. However, there's
+	// no convention about escaping the metacharacters and GPG just refuses
+	// to create user ids where, say, the name contains a '('. We mirror
+	// this behaviour.
+
+	if hasInvalidCharacters(name) || hasInvalidCharacters(comment) || hasInvalidCharacters(email) {
+		return nil
+	}
+
+	uid := new(UserId)
+	uid.Name, uid.Comment, uid.Email = name, comment, email
+	uid.Id = name
+	if len(comment) > 0 {
+		if len(uid.Id) > 0 {
+			uid.Id += " "
+		}
+		uid.Id += "("
+		uid.Id += comment
+		uid.Id += ")"
+	}
+	if len(email) > 0 {
+		if len(uid.Id) > 0 {
+			uid.Id += " "
+		}
+		uid.Id += "<"
+		uid.Id += email
+		uid.Id += ">"
+	}
+	return uid
+}
+
+func (uid *UserId) parse(r io.Reader) (err error) {
+	// RFC 4880, section 5.11
+	b, err := ioutil.ReadAll(r)
+	if err != nil {
+		return
+	}
+	uid.Id = string(b)
+	uid.Name, uid.Comment, uid.Email = parseUserId(uid.Id)
+	return
+}
+
+// Serialize marshals uid to w in the form of an OpenPGP packet, including
+// header.
+func (uid *UserId) Serialize(w io.Writer) error {
+	err := serializeHeader(w, packetTypeUserId, len(uid.Id))
+	if err != nil {
+		return err
+	}
+	_, err = w.Write([]byte(uid.Id))
+	return err
+}
+
+// parseUserId extracts the name, comment and email from a user id string that
+// is formatted as "Full Name (Comment) <email@example.com>".
+func parseUserId(id string) (name, comment, email string) {
+	var n, c, e struct {
+		start, end int
+	}
+	var state int
+
+	for offset, rune := range id {
+		switch state {
+		case 0:
+			// Entering name
+			n.start = offset
+			state = 1
+			fallthrough
+		case 1:
+			// In name
+			if rune == '(' {
+				state = 2
+				n.end = offset
+			} else if rune == '<' {
+				state = 5
+				n.end = offset
+			}
+		case 2:
+			// Entering comment
+			c.start = offset
+			state = 3
+			fallthrough
+		case 3:
+			// In comment
+			if rune == ')' {
+				state = 4
+				c.end = offset
+			}
+		case 4:
+			// Between comment and email
+			if rune == '<' {
+				state = 5
+			}
+		case 5:
+			// Entering email
+			e.start = offset
+			state = 6
+			fallthrough
+		case 6:
+			// In email
+			if rune == '>' {
+				state = 7
+				e.end = offset
+			}
+		default:
+			// After email
+		}
+	}
+	switch state {
+	case 1:
+		// ended in the name
+		n.end = len(id)
+	case 3:
+		// ended in comment
+		c.end = len(id)
+	case 6:
+		// ended in email
+		e.end = len(id)
+	}
+
+	name = strings.TrimSpace(id[n.start:n.end])
+	comment = strings.TrimSpace(id[c.start:c.end])
+	email = strings.TrimSpace(id[e.start:e.end])
+	return
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/read.go b/vendor/golang.org/x/crypto/openpgp/read.go
new file mode 100644
index 0000000..6ec664f
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/read.go
@@ -0,0 +1,442 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package openpgp implements high level operations on OpenPGP messages.
+package openpgp // import "golang.org/x/crypto/openpgp"
+
+import (
+	"crypto"
+	_ "crypto/sha256"
+	"hash"
+	"io"
+	"strconv"
+
+	"golang.org/x/crypto/openpgp/armor"
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/packet"
+)
+
+// SignatureType is the armor type for a PGP signature.
+var SignatureType = "PGP SIGNATURE"
+
+// readArmored reads an armored block with the given type.
+func readArmored(r io.Reader, expectedType string) (body io.Reader, err error) {
+	block, err := armor.Decode(r)
+	if err != nil {
+		return
+	}
+
+	if block.Type != expectedType {
+		return nil, errors.InvalidArgumentError("expected '" + expectedType + "', got: " + block.Type)
+	}
+
+	return block.Body, nil
+}
+
+// MessageDetails contains the result of parsing an OpenPGP encrypted and/or
+// signed message.
+type MessageDetails struct {
+	IsEncrypted              bool                // true if the message was encrypted.
+	EncryptedToKeyIds        []uint64            // the list of recipient key ids.
+	IsSymmetricallyEncrypted bool                // true if a passphrase could have decrypted the message.
+	DecryptedWith            Key                 // the private key used to decrypt the message, if any.
+	IsSigned                 bool                // true if the message is signed.
+	SignedByKeyId            uint64              // the key id of the signer, if any.
+	SignedBy                 *Key                // the key of the signer, if available.
+	LiteralData              *packet.LiteralData // the metadata of the contents
+	UnverifiedBody           io.Reader           // the contents of the message.
+
+	// If IsSigned is true and SignedBy is non-zero then the signature will
+	// be verified as UnverifiedBody is read. The signature cannot be
+	// checked until the whole of UnverifiedBody is read so UnverifiedBody
+	// must be consumed until EOF before the data can be trusted. Even if a
+	// message isn't signed (or the signer is unknown) the data may contain
+	// an authentication code that is only checked once UnverifiedBody has
+	// been consumed. Once EOF has been seen, the following fields are
+	// valid. (An authentication code failure is reported as a
+	// SignatureError error when reading from UnverifiedBody.)
+	SignatureError error               // nil if the signature is good.
+	Signature      *packet.Signature   // the signature packet itself, if v4 (default)
+	SignatureV3    *packet.SignatureV3 // the signature packet if it is a v2 or v3 signature
+
+	decrypted io.ReadCloser
+}
+
+// A PromptFunction is used as a callback by functions that may need to decrypt
+// a private key, or prompt for a passphrase. It is called with a list of
+// acceptable, encrypted private keys and a boolean that indicates whether a
+// passphrase is usable. It should either decrypt a private key or return a
+// passphrase to try. If the decrypted private key or given passphrase isn't
+// correct, the function will be called again, forever. Any error returned will
+// be passed up.
+type PromptFunction func(keys []Key, symmetric bool) ([]byte, error)
+
+// A keyEnvelopePair is used to store a private key with the envelope that
+// contains a symmetric key, encrypted with that key.
+type keyEnvelopePair struct {
+	key          Key
+	encryptedKey *packet.EncryptedKey
+}
+
+// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.
+// The given KeyRing should contain both public keys (for signature
+// verification) and, possibly encrypted, private keys for decrypting.
+// If config is nil, sensible defaults will be used.
+func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction, config *packet.Config) (md *MessageDetails, err error) {
+	var p packet.Packet
+
+	var symKeys []*packet.SymmetricKeyEncrypted
+	var pubKeys []keyEnvelopePair
+	var se *packet.SymmetricallyEncrypted
+
+	packets := packet.NewReader(r)
+	md = new(MessageDetails)
+	md.IsEncrypted = true
+
+	// The message, if encrypted, starts with a number of packets
+	// containing an encrypted decryption key. The decryption key is either
+	// encrypted to a public key, or with a passphrase. This loop
+	// collects these packets.
+ParsePackets:
+	for {
+		p, err = packets.Next()
+		if err != nil {
+			return nil, err
+		}
+		switch p := p.(type) {
+		case *packet.SymmetricKeyEncrypted:
+			// This packet contains the decryption key encrypted with a passphrase.
+			md.IsSymmetricallyEncrypted = true
+			symKeys = append(symKeys, p)
+		case *packet.EncryptedKey:
+			// This packet contains the decryption key encrypted to a public key.
+			md.EncryptedToKeyIds = append(md.EncryptedToKeyIds, p.KeyId)
+			switch p.Algo {
+			case packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSAEncryptOnly, packet.PubKeyAlgoElGamal:
+				break
+			default:
+				continue
+			}
+			var keys []Key
+			if p.KeyId == 0 {
+				keys = keyring.DecryptionKeys()
+			} else {
+				keys = keyring.KeysById(p.KeyId)
+			}
+			for _, k := range keys {
+				pubKeys = append(pubKeys, keyEnvelopePair{k, p})
+			}
+		case *packet.SymmetricallyEncrypted:
+			se = p
+			break ParsePackets
+		case *packet.Compressed, *packet.LiteralData, *packet.OnePassSignature:
+			// This message isn't encrypted.
+			if len(symKeys) != 0 || len(pubKeys) != 0 {
+				return nil, errors.StructuralError("key material not followed by encrypted message")
+			}
+			packets.Unread(p)
+			return readSignedMessage(packets, nil, keyring)
+		}
+	}
+
+	var candidates []Key
+	var decrypted io.ReadCloser
+
+	// Now that we have the list of encrypted keys we need to decrypt at
+	// least one of them or, if we cannot, we need to call the prompt
+	// function so that it can decrypt a key or give us a passphrase.
+FindKey:
+	for {
+		// See if any of the keys already have a private key available
+		candidates = candidates[:0]
+		candidateFingerprints := make(map[string]bool)
+
+		for _, pk := range pubKeys {
+			if pk.key.PrivateKey == nil {
+				continue
+			}
+			if !pk.key.PrivateKey.Encrypted {
+				if len(pk.encryptedKey.Key) == 0 {
+					pk.encryptedKey.Decrypt(pk.key.PrivateKey, config)
+				}
+				if len(pk.encryptedKey.Key) == 0 {
+					continue
+				}
+				decrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)
+				if err != nil && err != errors.ErrKeyIncorrect {
+					return nil, err
+				}
+				if decrypted != nil {
+					md.DecryptedWith = pk.key
+					break FindKey
+				}
+			} else {
+				fpr := string(pk.key.PublicKey.Fingerprint[:])
+				if v := candidateFingerprints[fpr]; v {
+					continue
+				}
+				candidates = append(candidates, pk.key)
+				candidateFingerprints[fpr] = true
+			}
+		}
+
+		if len(candidates) == 0 && len(symKeys) == 0 {
+			return nil, errors.ErrKeyIncorrect
+		}
+
+		if prompt == nil {
+			return nil, errors.ErrKeyIncorrect
+		}
+
+		passphrase, err := prompt(candidates, len(symKeys) != 0)
+		if err != nil {
+			return nil, err
+		}
+
+		// Try the symmetric passphrase first
+		if len(symKeys) != 0 && passphrase != nil {
+			for _, s := range symKeys {
+				key, cipherFunc, err := s.Decrypt(passphrase)
+				if err == nil {
+					decrypted, err = se.Decrypt(cipherFunc, key)
+					if err != nil && err != errors.ErrKeyIncorrect {
+						return nil, err
+					}
+					if decrypted != nil {
+						break FindKey
+					}
+				}
+
+			}
+		}
+	}
+
+	md.decrypted = decrypted
+	if err := packets.Push(decrypted); err != nil {
+		return nil, err
+	}
+	return readSignedMessage(packets, md, keyring)
+}
+
+// readSignedMessage reads a possibly signed message if mdin is non-zero then
+// that structure is updated and returned. Otherwise a fresh MessageDetails is
+// used.
+func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err error) {
+	if mdin == nil {
+		mdin = new(MessageDetails)
+	}
+	md = mdin
+
+	var p packet.Packet
+	var h hash.Hash
+	var wrappedHash hash.Hash
+FindLiteralData:
+	for {
+		p, err = packets.Next()
+		if err != nil {
+			return nil, err
+		}
+		switch p := p.(type) {
+		case *packet.Compressed:
+			if err := packets.Push(p.Body); err != nil {
+				return nil, err
+			}
+		case *packet.OnePassSignature:
+			if !p.IsLast {
+				return nil, errors.UnsupportedError("nested signatures")
+			}
+
+			h, wrappedHash, err = hashForSignature(p.Hash, p.SigType)
+			if err != nil {
+				md = nil
+				return
+			}
+
+			md.IsSigned = true
+			md.SignedByKeyId = p.KeyId
+			keys := keyring.KeysByIdUsage(p.KeyId, packet.KeyFlagSign)
+			if len(keys) > 0 {
+				md.SignedBy = &keys[0]
+			}
+		case *packet.LiteralData:
+			md.LiteralData = p
+			break FindLiteralData
+		}
+	}
+
+	if md.SignedBy != nil {
+		md.UnverifiedBody = &signatureCheckReader{packets, h, wrappedHash, md}
+	} else if md.decrypted != nil {
+		md.UnverifiedBody = checkReader{md}
+	} else {
+		md.UnverifiedBody = md.LiteralData.Body
+	}
+
+	return md, nil
+}
+
+// hashForSignature returns a pair of hashes that can be used to verify a
+// signature. The signature may specify that the contents of the signed message
+// should be preprocessed (i.e. to normalize line endings). Thus this function
+// returns two hashes. The second should be used to hash the message itself and
+// performs any needed preprocessing.
+func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, error) {
+	if !hashId.Available() {
+		return nil, nil, errors.UnsupportedError("hash not available: " + strconv.Itoa(int(hashId)))
+	}
+	h := hashId.New()
+
+	switch sigType {
+	case packet.SigTypeBinary:
+		return h, h, nil
+	case packet.SigTypeText:
+		return h, NewCanonicalTextHash(h), nil
+	}
+
+	return nil, nil, errors.UnsupportedError("unsupported signature type: " + strconv.Itoa(int(sigType)))
+}
+
+// checkReader wraps an io.Reader from a LiteralData packet. When it sees EOF
+// it closes the ReadCloser from any SymmetricallyEncrypted packet to trigger
+// MDC checks.
+type checkReader struct {
+	md *MessageDetails
+}
+
+func (cr checkReader) Read(buf []byte) (n int, err error) {
+	n, err = cr.md.LiteralData.Body.Read(buf)
+	if err == io.EOF {
+		mdcErr := cr.md.decrypted.Close()
+		if mdcErr != nil {
+			err = mdcErr
+		}
+	}
+	return
+}
+
+// signatureCheckReader wraps an io.Reader from a LiteralData packet and hashes
+// the data as it is read. When it sees an EOF from the underlying io.Reader
+// it parses and checks a trailing Signature packet and triggers any MDC checks.
+type signatureCheckReader struct {
+	packets        *packet.Reader
+	h, wrappedHash hash.Hash
+	md             *MessageDetails
+}
+
+func (scr *signatureCheckReader) Read(buf []byte) (n int, err error) {
+	n, err = scr.md.LiteralData.Body.Read(buf)
+	scr.wrappedHash.Write(buf[:n])
+	if err == io.EOF {
+		var p packet.Packet
+		p, scr.md.SignatureError = scr.packets.Next()
+		if scr.md.SignatureError != nil {
+			return
+		}
+
+		var ok bool
+		if scr.md.Signature, ok = p.(*packet.Signature); ok {
+			scr.md.SignatureError = scr.md.SignedBy.PublicKey.VerifySignature(scr.h, scr.md.Signature)
+		} else if scr.md.SignatureV3, ok = p.(*packet.SignatureV3); ok {
+			scr.md.SignatureError = scr.md.SignedBy.PublicKey.VerifySignatureV3(scr.h, scr.md.SignatureV3)
+		} else {
+			scr.md.SignatureError = errors.StructuralError("LiteralData not followed by Signature")
+			return
+		}
+
+		// The SymmetricallyEncrypted packet, if any, might have an
+		// unsigned hash of its own. In order to check this we need to
+		// close that Reader.
+		if scr.md.decrypted != nil {
+			mdcErr := scr.md.decrypted.Close()
+			if mdcErr != nil {
+				err = mdcErr
+			}
+		}
+	}
+	return
+}
+
+// CheckDetachedSignature takes a signed file and a detached signature and
+// returns the signer if the signature is valid. If the signer isn't known,
+// ErrUnknownIssuer is returned.
+func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {
+	var issuerKeyId uint64
+	var hashFunc crypto.Hash
+	var sigType packet.SignatureType
+	var keys []Key
+	var p packet.Packet
+
+	packets := packet.NewReader(signature)
+	for {
+		p, err = packets.Next()
+		if err == io.EOF {
+			return nil, errors.ErrUnknownIssuer
+		}
+		if err != nil {
+			return nil, err
+		}
+
+		switch sig := p.(type) {
+		case *packet.Signature:
+			if sig.IssuerKeyId == nil {
+				return nil, errors.StructuralError("signature doesn't have an issuer")
+			}
+			issuerKeyId = *sig.IssuerKeyId
+			hashFunc = sig.Hash
+			sigType = sig.SigType
+		case *packet.SignatureV3:
+			issuerKeyId = sig.IssuerKeyId
+			hashFunc = sig.Hash
+			sigType = sig.SigType
+		default:
+			return nil, errors.StructuralError("non signature packet found")
+		}
+
+		keys = keyring.KeysByIdUsage(issuerKeyId, packet.KeyFlagSign)
+		if len(keys) > 0 {
+			break
+		}
+	}
+
+	if len(keys) == 0 {
+		panic("unreachable")
+	}
+
+	h, wrappedHash, err := hashForSignature(hashFunc, sigType)
+	if err != nil {
+		return nil, err
+	}
+
+	if _, err := io.Copy(wrappedHash, signed); err != nil && err != io.EOF {
+		return nil, err
+	}
+
+	for _, key := range keys {
+		switch sig := p.(type) {
+		case *packet.Signature:
+			err = key.PublicKey.VerifySignature(h, sig)
+		case *packet.SignatureV3:
+			err = key.PublicKey.VerifySignatureV3(h, sig)
+		default:
+			panic("unreachable")
+		}
+
+		if err == nil {
+			return key.Entity, nil
+		}
+	}
+
+	return nil, err
+}
+
+// CheckArmoredDetachedSignature performs the same actions as
+// CheckDetachedSignature but expects the signature to be armored.
+func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err error) {
+	body, err := readArmored(signature, SignatureType)
+	if err != nil {
+		return
+	}
+
+	return CheckDetachedSignature(keyring, signed, body)
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/s2k/s2k.go b/vendor/golang.org/x/crypto/openpgp/s2k/s2k.go
new file mode 100644
index 0000000..4b9a44c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/s2k/s2k.go
@@ -0,0 +1,273 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package s2k implements the various OpenPGP string-to-key transforms as
+// specified in RFC 4800 section 3.7.1.
+package s2k // import "golang.org/x/crypto/openpgp/s2k"
+
+import (
+	"crypto"
+	"hash"
+	"io"
+	"strconv"
+
+	"golang.org/x/crypto/openpgp/errors"
+)
+
+// Config collects configuration parameters for s2k key-stretching
+// transformatioms. A nil *Config is valid and results in all default
+// values. Currently, Config is used only by the Serialize function in
+// this package.
+type Config struct {
+	// Hash is the default hash function to be used. If
+	// nil, SHA1 is used.
+	Hash crypto.Hash
+	// S2KCount is only used for symmetric encryption. It
+	// determines the strength of the passphrase stretching when
+	// the said passphrase is hashed to produce a key. S2KCount
+	// should be between 1024 and 65011712, inclusive. If Config
+	// is nil or S2KCount is 0, the value 65536 used. Not all
+	// values in the above range can be represented. S2KCount will
+	// be rounded up to the next representable value if it cannot
+	// be encoded exactly. When set, it is strongly encrouraged to
+	// use a value that is at least 65536. See RFC 4880 Section
+	// 3.7.1.3.
+	S2KCount int
+}
+
+func (c *Config) hash() crypto.Hash {
+	if c == nil || uint(c.Hash) == 0 {
+		// SHA1 is the historical default in this package.
+		return crypto.SHA1
+	}
+
+	return c.Hash
+}
+
+func (c *Config) encodedCount() uint8 {
+	if c == nil || c.S2KCount == 0 {
+		return 96 // The common case. Correspoding to 65536
+	}
+
+	i := c.S2KCount
+	switch {
+	// Behave like GPG. Should we make 65536 the lowest value used?
+	case i < 1024:
+		i = 1024
+	case i > 65011712:
+		i = 65011712
+	}
+
+	return encodeCount(i)
+}
+
+// encodeCount converts an iterative "count" in the range 1024 to
+// 65011712, inclusive, to an encoded count. The return value is the
+// octet that is actually stored in the GPG file. encodeCount panics
+// if i is not in the above range (encodedCount above takes care to
+// pass i in the correct range). See RFC 4880 Section 3.7.7.1.
+func encodeCount(i int) uint8 {
+	if i < 1024 || i > 65011712 {
+		panic("count arg i outside the required range")
+	}
+
+	for encoded := 0; encoded < 256; encoded++ {
+		count := decodeCount(uint8(encoded))
+		if count >= i {
+			return uint8(encoded)
+		}
+	}
+
+	return 255
+}
+
+// decodeCount returns the s2k mode 3 iterative "count" corresponding to
+// the encoded octet c.
+func decodeCount(c uint8) int {
+	return (16 + int(c&15)) << (uint32(c>>4) + 6)
+}
+
+// Simple writes to out the result of computing the Simple S2K function (RFC
+// 4880, section 3.7.1.1) using the given hash and input passphrase.
+func Simple(out []byte, h hash.Hash, in []byte) {
+	Salted(out, h, in, nil)
+}
+
+var zero [1]byte
+
+// Salted writes to out the result of computing the Salted S2K function (RFC
+// 4880, section 3.7.1.2) using the given hash, input passphrase and salt.
+func Salted(out []byte, h hash.Hash, in []byte, salt []byte) {
+	done := 0
+	var digest []byte
+
+	for i := 0; done < len(out); i++ {
+		h.Reset()
+		for j := 0; j < i; j++ {
+			h.Write(zero[:])
+		}
+		h.Write(salt)
+		h.Write(in)
+		digest = h.Sum(digest[:0])
+		n := copy(out[done:], digest)
+		done += n
+	}
+}
+
+// Iterated writes to out the result of computing the Iterated and Salted S2K
+// function (RFC 4880, section 3.7.1.3) using the given hash, input passphrase,
+// salt and iteration count.
+func Iterated(out []byte, h hash.Hash, in []byte, salt []byte, count int) {
+	combined := make([]byte, len(in)+len(salt))
+	copy(combined, salt)
+	copy(combined[len(salt):], in)
+
+	if count < len(combined) {
+		count = len(combined)
+	}
+
+	done := 0
+	var digest []byte
+	for i := 0; done < len(out); i++ {
+		h.Reset()
+		for j := 0; j < i; j++ {
+			h.Write(zero[:])
+		}
+		written := 0
+		for written < count {
+			if written+len(combined) > count {
+				todo := count - written
+				h.Write(combined[:todo])
+				written = count
+			} else {
+				h.Write(combined)
+				written += len(combined)
+			}
+		}
+		digest = h.Sum(digest[:0])
+		n := copy(out[done:], digest)
+		done += n
+	}
+}
+
+// Parse reads a binary specification for a string-to-key transformation from r
+// and returns a function which performs that transform.
+func Parse(r io.Reader) (f func(out, in []byte), err error) {
+	var buf [9]byte
+
+	_, err = io.ReadFull(r, buf[:2])
+	if err != nil {
+		return
+	}
+
+	hash, ok := HashIdToHash(buf[1])
+	if !ok {
+		return nil, errors.UnsupportedError("hash for S2K function: " + strconv.Itoa(int(buf[1])))
+	}
+	if !hash.Available() {
+		return nil, errors.UnsupportedError("hash not available: " + strconv.Itoa(int(hash)))
+	}
+	h := hash.New()
+
+	switch buf[0] {
+	case 0:
+		f := func(out, in []byte) {
+			Simple(out, h, in)
+		}
+		return f, nil
+	case 1:
+		_, err = io.ReadFull(r, buf[:8])
+		if err != nil {
+			return
+		}
+		f := func(out, in []byte) {
+			Salted(out, h, in, buf[:8])
+		}
+		return f, nil
+	case 3:
+		_, err = io.ReadFull(r, buf[:9])
+		if err != nil {
+			return
+		}
+		count := decodeCount(buf[8])
+		f := func(out, in []byte) {
+			Iterated(out, h, in, buf[:8], count)
+		}
+		return f, nil
+	}
+
+	return nil, errors.UnsupportedError("S2K function")
+}
+
+// Serialize salts and stretches the given passphrase and writes the
+// resulting key into key. It also serializes an S2K descriptor to
+// w. The key stretching can be configured with c, which may be
+// nil. In that case, sensible defaults will be used.
+func Serialize(w io.Writer, key []byte, rand io.Reader, passphrase []byte, c *Config) error {
+	var buf [11]byte
+	buf[0] = 3 /* iterated and salted */
+	buf[1], _ = HashToHashId(c.hash())
+	salt := buf[2:10]
+	if _, err := io.ReadFull(rand, salt); err != nil {
+		return err
+	}
+	encodedCount := c.encodedCount()
+	count := decodeCount(encodedCount)
+	buf[10] = encodedCount
+	if _, err := w.Write(buf[:]); err != nil {
+		return err
+	}
+
+	Iterated(key, c.hash().New(), passphrase, salt, count)
+	return nil
+}
+
+// hashToHashIdMapping contains pairs relating OpenPGP's hash identifier with
+// Go's crypto.Hash type. See RFC 4880, section 9.4.
+var hashToHashIdMapping = []struct {
+	id   byte
+	hash crypto.Hash
+	name string
+}{
+	{1, crypto.MD5, "MD5"},
+	{2, crypto.SHA1, "SHA1"},
+	{3, crypto.RIPEMD160, "RIPEMD160"},
+	{8, crypto.SHA256, "SHA256"},
+	{9, crypto.SHA384, "SHA384"},
+	{10, crypto.SHA512, "SHA512"},
+	{11, crypto.SHA224, "SHA224"},
+}
+
+// HashIdToHash returns a crypto.Hash which corresponds to the given OpenPGP
+// hash id.
+func HashIdToHash(id byte) (h crypto.Hash, ok bool) {
+	for _, m := range hashToHashIdMapping {
+		if m.id == id {
+			return m.hash, true
+		}
+	}
+	return 0, false
+}
+
+// HashIdToString returns the name of the hash function corresponding to the
+// given OpenPGP hash id.
+func HashIdToString(id byte) (name string, ok bool) {
+	for _, m := range hashToHashIdMapping {
+		if m.id == id {
+			return m.name, true
+		}
+	}
+
+	return "", false
+}
+
+// HashIdToHash returns an OpenPGP hash id which corresponds the given Hash.
+func HashToHashId(h crypto.Hash) (id byte, ok bool) {
+	for _, m := range hashToHashIdMapping {
+		if m.hash == h {
+			return m.id, true
+		}
+	}
+	return 0, false
+}
diff --git a/vendor/golang.org/x/crypto/openpgp/write.go b/vendor/golang.org/x/crypto/openpgp/write.go
new file mode 100644
index 0000000..65a304c
--- /dev/null
+++ b/vendor/golang.org/x/crypto/openpgp/write.go
@@ -0,0 +1,378 @@
+// Copyright 2011 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package openpgp
+
+import (
+	"crypto"
+	"hash"
+	"io"
+	"strconv"
+	"time"
+
+	"golang.org/x/crypto/openpgp/armor"
+	"golang.org/x/crypto/openpgp/errors"
+	"golang.org/x/crypto/openpgp/packet"
+	"golang.org/x/crypto/openpgp/s2k"
+)
+
+// DetachSign signs message with the private key from signer (which must
+// already have been decrypted) and writes the signature to w.
+// If config is nil, sensible defaults will be used.
+func DetachSign(w io.Writer, signer *Entity, message io.Reader, config *packet.Config) error {
+	return detachSign(w, signer, message, packet.SigTypeBinary, config)
+}
+
+// ArmoredDetachSign signs message with the private key from signer (which
+// must already have been decrypted) and writes an armored signature to w.
+// If config is nil, sensible defaults will be used.
+func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader, config *packet.Config) (err error) {
+	return armoredDetachSign(w, signer, message, packet.SigTypeBinary, config)
+}
+
+// DetachSignText signs message (after canonicalising the line endings) with
+// the private key from signer (which must already have been decrypted) and
+// writes the signature to w.
+// If config is nil, sensible defaults will be used.
+func DetachSignText(w io.Writer, signer *Entity, message io.Reader, config *packet.Config) error {
+	return detachSign(w, signer, message, packet.SigTypeText, config)
+}
+
+// ArmoredDetachSignText signs message (after canonicalising the line endings)
+// with the private key from signer (which must already have been decrypted)
+// and writes an armored signature to w.
+// If config is nil, sensible defaults will be used.
+func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader, config *packet.Config) error {
+	return armoredDetachSign(w, signer, message, packet.SigTypeText, config)
+}
+
+func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType, config *packet.Config) (err error) {
+	out, err := armor.Encode(w, SignatureType, nil)
+	if err != nil {
+		return
+	}
+	err = detachSign(out, signer, message, sigType, config)
+	if err != nil {
+		return
+	}
+	return out.Close()
+}
+
+func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType, config *packet.Config) (err error) {
+	if signer.PrivateKey == nil {
+		return errors.InvalidArgumentError("signing key doesn't have a private key")
+	}
+	if signer.PrivateKey.Encrypted {
+		return errors.InvalidArgumentError("signing key is encrypted")
+	}
+
+	sig := new(packet.Signature)
+	sig.SigType = sigType
+	sig.PubKeyAlgo = signer.PrivateKey.PubKeyAlgo
+	sig.Hash = config.Hash()
+	sig.CreationTime = config.Now()
+	sig.IssuerKeyId = &signer.PrivateKey.KeyId
+
+	h, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)
+	if err != nil {
+		return
+	}
+	io.Copy(wrappedHash, message)
+
+	err = sig.Sign(h, signer.PrivateKey, config)
+	if err != nil {
+		return
+	}
+
+	return sig.Serialize(w)
+}
+
+// FileHints contains metadata about encrypted files. This metadata is, itself,
+// encrypted.
+type FileHints struct {
+	// IsBinary can be set to hint that the contents are binary data.
+	IsBinary bool
+	// FileName hints at the name of the file that should be written. It's
+	// truncated to 255 bytes if longer. It may be empty to suggest that the
+	// file should not be written to disk. It may be equal to "_CONSOLE" to
+	// suggest the data should not be written to disk.
+	FileName string
+	// ModTime contains the modification time of the file, or the zero time if not applicable.
+	ModTime time.Time
+}
+
+// SymmetricallyEncrypt acts like gpg -c: it encrypts a file with a passphrase.
+// The resulting WriteCloser must be closed after the contents of the file have
+// been written.
+// If config is nil, sensible defaults will be used.
+func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHints, config *packet.Config) (plaintext io.WriteCloser, err error) {
+	if hints == nil {
+		hints = &FileHints{}
+	}
+
+	key, err := packet.SerializeSymmetricKeyEncrypted(ciphertext, passphrase, config)
+	if err != nil {
+		return
+	}
+	w, err := packet.SerializeSymmetricallyEncrypted(ciphertext, config.Cipher(), key, config)
+	if err != nil {
+		return
+	}
+
+	literaldata := w
+	if algo := config.Compression(); algo != packet.CompressionNone {
+		var compConfig *packet.CompressionConfig
+		if config != nil {
+			compConfig = config.CompressionConfig
+		}
+		literaldata, err = packet.SerializeCompressed(w, algo, compConfig)
+		if err != nil {
+			return
+		}
+	}
+
+	var epochSeconds uint32
+	if !hints.ModTime.IsZero() {
+		epochSeconds = uint32(hints.ModTime.Unix())
+	}
+	return packet.SerializeLiteral(literaldata, hints.IsBinary, hints.FileName, epochSeconds)
+}
+
+// intersectPreferences mutates and returns a prefix of a that contains only
+// the values in the intersection of a and b. The order of a is preserved.
+func intersectPreferences(a []uint8, b []uint8) (intersection []uint8) {
+	var j int
+	for _, v := range a {
+		for _, v2 := range b {
+			if v == v2 {
+				a[j] = v
+				j++
+				break
+			}
+		}
+	}
+
+	return a[:j]
+}
+
+func hashToHashId(h crypto.Hash) uint8 {
+	v, ok := s2k.HashToHashId(h)
+	if !ok {
+		panic("tried to convert unknown hash")
+	}
+	return v
+}
+
+// Encrypt encrypts a message to a number of recipients and, optionally, signs
+// it. hints contains optional information, that is also encrypted, that aids
+// the recipients in processing the message. The resulting WriteCloser must
+// be closed after the contents of the file have been written.
+// If config is nil, sensible defaults will be used.
+func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHints, config *packet.Config) (plaintext io.WriteCloser, err error) {
+	var signer *packet.PrivateKey
+	if signed != nil {
+		signKey, ok := signed.signingKey(config.Now())
+		if !ok {
+			return nil, errors.InvalidArgumentError("no valid signing keys")
+		}
+		signer = signKey.PrivateKey
+		if signer == nil {
+			return nil, errors.InvalidArgumentError("no private key in signing key")
+		}
+		if signer.Encrypted {
+			return nil, errors.InvalidArgumentError("signing key must be decrypted")
+		}
+	}
+
+	// These are the possible ciphers that we'll use for the message.
+	candidateCiphers := []uint8{
+		uint8(packet.CipherAES128),
+		uint8(packet.CipherAES256),
+		uint8(packet.CipherCAST5),
+	}
+	// These are the possible hash functions that we'll use for the signature.
+	candidateHashes := []uint8{
+		hashToHashId(crypto.SHA256),
+		hashToHashId(crypto.SHA512),
+		hashToHashId(crypto.SHA1),
+		hashToHashId(crypto.RIPEMD160),
+	}
+	// In the event that a recipient doesn't specify any supported ciphers
+	// or hash functions, these are the ones that we assume that every
+	// implementation supports.
+	defaultCiphers := candidateCiphers[len(candidateCiphers)-1:]
+	defaultHashes := candidateHashes[len(candidateHashes)-1:]
+
+	encryptKeys := make([]Key, len(to))
+	for i := range to {
+		var ok bool
+		encryptKeys[i], ok = to[i].encryptionKey(config.Now())
+		if !ok {
+			return nil, errors.InvalidArgumentError("cannot encrypt a message to key id " + strconv.FormatUint(to[i].PrimaryKey.KeyId, 16) + " because it has no encryption keys")
+		}
+
+		sig := to[i].primaryIdentity().SelfSignature
+
+		preferredSymmetric := sig.PreferredSymmetric
+		if len(preferredSymmetric) == 0 {
+			preferredSymmetric = defaultCiphers
+		}
+		preferredHashes := sig.PreferredHash
+		if len(preferredHashes) == 0 {
+			preferredHashes = defaultHashes
+		}
+		candidateCiphers = intersectPreferences(candidateCiphers, preferredSymmetric)
+		candidateHashes = intersectPreferences(candidateHashes, preferredHashes)
+	}
+
+	if len(candidateCiphers) == 0 || len(candidateHashes) == 0 {
+		return nil, errors.InvalidArgumentError("cannot encrypt because recipient set shares no common algorithms")
+	}
+
+	cipher := packet.CipherFunction(candidateCiphers[0])
+	// If the cipher specified by config is a candidate, we'll use that.
+	configuredCipher := config.Cipher()
+	for _, c := range candidateCiphers {
+		cipherFunc := packet.CipherFunction(c)
+		if cipherFunc == configuredCipher {
+			cipher = cipherFunc
+			break
+		}
+	}
+
+	var hash crypto.Hash
+	for _, hashId := range candidateHashes {
+		if h, ok := s2k.HashIdToHash(hashId); ok && h.Available() {
+			hash = h
+			break
+		}
+	}
+
+	// If the hash specified by config is a candidate, we'll use that.
+	if configuredHash := config.Hash(); configuredHash.Available() {
+		for _, hashId := range candidateHashes {
+			if h, ok := s2k.HashIdToHash(hashId); ok && h == configuredHash {
+				hash = h
+				break
+			}
+		}
+	}
+
+	if hash == 0 {
+		hashId := candidateHashes[0]
+		name, ok := s2k.HashIdToString(hashId)
+		if !ok {
+			name = "#" + strconv.Itoa(int(hashId))
+		}
+		return nil, errors.InvalidArgumentError("cannot encrypt because no candidate hash functions are compiled in. (Wanted " + name + " in this case.)")
+	}
+
+	symKey := make([]byte, cipher.KeySize())
+	if _, err := io.ReadFull(config.Random(), symKey); err != nil {
+		return nil, err
+	}
+
+	for _, key := range encryptKeys {
+		if err := packet.SerializeEncryptedKey(ciphertext, key.PublicKey, cipher, symKey, config); err != nil {
+			return nil, err
+		}
+	}
+
+	encryptedData, err := packet.SerializeSymmetricallyEncrypted(ciphertext, cipher, symKey, config)
+	if err != nil {
+		return
+	}
+
+	if signer != nil {
+		ops := &packet.OnePassSignature{
+			SigType:    packet.SigTypeBinary,
+			Hash:       hash,
+			PubKeyAlgo: signer.PubKeyAlgo,
+			KeyId:      signer.KeyId,
+			IsLast:     true,
+		}
+		if err := ops.Serialize(encryptedData); err != nil {
+			return nil, err
+		}
+	}
+
+	if hints == nil {
+		hints = &FileHints{}
+	}
+
+	w := encryptedData
+	if signer != nil {
+		// If we need to write a signature packet after the literal
+		// data then we need to stop literalData from closing
+		// encryptedData.
+		w = noOpCloser{encryptedData}
+
+	}
+	var epochSeconds uint32
+	if !hints.ModTime.IsZero() {
+		epochSeconds = uint32(hints.ModTime.Unix())
+	}
+	literalData, err := packet.SerializeLiteral(w, hints.IsBinary, hints.FileName, epochSeconds)
+	if err != nil {
+		return nil, err
+	}
+
+	if signer != nil {
+		return signatureWriter{encryptedData, literalData, hash, hash.New(), signer, config}, nil
+	}
+	return literalData, nil
+}
+
+// signatureWriter hashes the contents of a message while passing it along to
+// literalData. When closed, it closes literalData, writes a signature packet
+// to encryptedData and then also closes encryptedData.
+type signatureWriter struct {
+	encryptedData io.WriteCloser
+	literalData   io.WriteCloser
+	hashType      crypto.Hash
+	h             hash.Hash
+	signer        *packet.PrivateKey
+	config        *packet.Config
+}
+
+func (s signatureWriter) Write(data []byte) (int, error) {
+	s.h.Write(data)
+	return s.literalData.Write(data)
+}
+
+func (s signatureWriter) Close() error {
+	sig := &packet.Signature{
+		SigType:      packet.SigTypeBinary,
+		PubKeyAlgo:   s.signer.PubKeyAlgo,
+		Hash:         s.hashType,
+		CreationTime: s.config.Now(),
+		IssuerKeyId:  &s.signer.KeyId,
+	}
+
+	if err := sig.Sign(s.h, s.signer, s.config); err != nil {
+		return err
+	}
+	if err := s.literalData.Close(); err != nil {
+		return err
+	}
+	if err := sig.Serialize(s.encryptedData); err != nil {
+		return err
+	}
+	return s.encryptedData.Close()
+}
+
+// noOpCloser is like an ioutil.NopCloser, but for an io.Writer.
+// TODO: we have two of these in OpenPGP packages alone. This probably needs
+// to be promoted somewhere more common.
+type noOpCloser struct {
+	w io.Writer
+}
+
+func (c noOpCloser) Write(data []byte) (n int, err error) {
+	return c.w.Write(data)
+}
+
+func (c noOpCloser) Close() error {
+	return nil
+}
-- 
2.7.4


From 6937db16ffaf8b4b154ce3a26bc94fddf70cef5a Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 7 Aug 2018 16:37:37 -0400
Subject: [PATCH 73/79] Fix some copyright in headers

---
 images/gpg.go     | 16 ++++++++++++++++
 images/openpgp.go |  3 ++-
 2 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/images/gpg.go b/images/gpg.go
index 9c90067..e7c914c 100644
--- a/images/gpg.go
+++ b/images/gpg.go
@@ -1,3 +1,19 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
 package images
 
 import (
diff --git a/images/openpgp.go b/images/openpgp.go
index 810520e..4aa91a9 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -12,8 +12,9 @@
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
+*/
 
-
+/*
    Some parts of this file were copied from golang's openpgp implementation
    which is under the following license:
 
-- 
2.7.4


From fe57dc9efbb917b12363f1f651d3f13d1a832b57 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 28 Aug 2018 16:54:45 -0400
Subject: [PATCH 74/79] Fix code check

---
 cmd/ctr/commands/images/decrypt.go | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index 39a1c73..d7d9c69 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -18,8 +18,8 @@ package images
 
 import (
 	"fmt"
+	"os"
 	"strings"
-	"syscall"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
 	"github.com/containerd/containerd/errdefs"
@@ -163,7 +163,7 @@ func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient)
 				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
 				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
 
-				password, err := terminal.ReadPassword(syscall.Stdin)
+				password, err := terminal.ReadPassword(int(os.Stdin.Fd()))
 				fmt.Printf("\n")
 				if err != nil {
 					return layerSymkeyMap, err
-- 
2.7.4


From bc6bf2de58443a2aa7a7b53acd30e90f3ac68c63 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 28 Aug 2018 12:38:07 -0400
Subject: [PATCH 75/79] fix compilation error after rebase

---
 images/image.go | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/images/image.go b/images/image.go
index ecf1b26..0ce8e59 100644
--- a/images/image.go
+++ b/images/image.go
@@ -836,7 +836,7 @@ func CryptImage(ctx context.Context, cs content.Store, desc ocispec.Descriptor,
 // We determine the KeyIds starting with  the given OCI Decriptor, recursing to lower-level descriptors
 // until we get them from the layer descriptors
 func GetImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descriptor, lf *LayerFilter, layerNum int32) ([]LayerInfo, error) {
-	return getImageLayerInfo(ctx, cs, desc, lf, layerNum, platforms.Default())
+	return getImageLayerInfo(ctx, cs, desc, lf, layerNum, platforms.DefaultString())
 }
 
 // getImageLayerInfo is the recursive version of GetImageLayerInfo that takes the platform
-- 
2.7.4


From d6c6622aa871d1432efb32b84dca9691c32f04c0 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 28 Aug 2018 14:59:19 -0400
Subject: [PATCH 76/79] Move getSynmmetricKeys to images.GetSymmetricKeys

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 cmd/ctr/commands/images/decrypt.go | 86 +-------------------------------------
 cmd/ctr/commands/images/encrypt.go |  2 +-
 cmd/ctr/commands/utils.go          | 15 -------
 images/encryption.go               | 81 +++++++++++++++++++++++++++++++++++
 images/utils.go                    | 32 ++++++++++++++
 5 files changed, 115 insertions(+), 101 deletions(-)
 create mode 100644 images/utils.go

diff --git a/cmd/ctr/commands/images/decrypt.go b/cmd/ctr/commands/images/decrypt.go
index d7d9c69..c3f32be 100644
--- a/cmd/ctr/commands/images/decrypt.go
+++ b/cmd/ctr/commands/images/decrypt.go
@@ -18,16 +18,11 @@ package images
 
 import (
 	"fmt"
-	"os"
-	"strings"
 
 	"github.com/containerd/containerd/cmd/ctr/commands"
-	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/images"
 	"github.com/pkg/errors"
 	"github.com/urfave/cli"
-
-	"golang.org/x/crypto/ssh/terminal"
 )
 
 var decryptCommand = cli.Command{
@@ -106,7 +101,7 @@ var decryptCommand = cli.Command{
 			return nil
 		}
 
-		layerSymKeyMap, err := getSymmetricKeys(layerInfos, gpgClient)
+		layerSymKeyMap, err := images.GetSymmetricKeys(layerInfos, gpgClient)
 		if err != nil {
 			return err
 		}
@@ -122,82 +117,3 @@ var decryptCommand = cli.Command{
 		return err
 	},
 }
-
-// getSymmetricKeys walks the list of layerInfos and tries to decrypt the
-// wrapped symmetric keys. For this it determines which private keys are on
-// this system and prompts for the passwords for those that are available.
-// If we do not find a private key on the system for getting to the symmetric
-// key of a layer then an error is generated. Otherwise the wrapped symmetric
-// key is decrypted using the private key and added to a map that describes
-// the layer by platform name and layer number as key and the symmetric key
-// data as value
-func getSymmetricKeys(layerInfos []images.LayerInfo, gpgClient images.GPGClient) (map[string]images.DecryptKeyData, error) {
-	type PrivKeyData struct {
-		KeyData         []byte
-		KeyDataPassword []byte
-	}
-	var pkd PrivKeyData
-	keyIDPasswordMap := make(map[uint64]PrivKeyData)
-	layerSymkeyMap := make(map[string]images.DecryptKeyData)
-
-	// we need to decrypt one symmetric key per encrypted layer per platform
-	for _, layerInfo := range layerInfos {
-
-		keyIds, err := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
-		if err != nil {
-			return layerSymkeyMap, err
-		}
-
-		found := false
-		for _, keyid := range keyIds {
-			// do we have this key?
-			keyinfo, haveKey, _ := gpgClient.GetSecretKeyDetails(keyid)
-			// this may fail if the key is not here; we ignore the error
-			if !haveKey {
-				// key not on this system
-				continue
-			}
-
-			var ok bool
-			if pkd, ok = keyIDPasswordMap[keyid]; !ok {
-				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
-				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
-
-				password, err := terminal.ReadPassword(int(os.Stdin.Fd()))
-				fmt.Printf("\n")
-				if err != nil {
-					return layerSymkeyMap, err
-				}
-				keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
-				if err != nil {
-					return layerSymkeyMap, err
-				}
-				pkd = PrivKeyData{
-					KeyData:         keydata,
-					KeyDataPassword: password,
-				}
-				keyIDPasswordMap[keyid] = pkd
-			}
-
-			symKeyData, symKeyCipher, err := images.DecryptSymmetricKey(layerInfo.WrappedKeys, keyid, pkd.KeyData, pkd.KeyDataPassword, nil)
-			if err != nil {
-				return layerSymkeyMap, err
-			}
-
-			index := fmt.Sprintf("%s:%d", layerInfo.Platform, layerInfo.ID)
-			layerSymkeyMap[index] = images.DecryptKeyData{
-				SymKeyData:   symKeyData,
-				SymKeyCipher: uint8(symKeyCipher),
-			}
-			found = true
-			break
-		}
-		if !found && len(layerInfo.WrappedKeys) > 0 {
-			keyIds, _ := images.WrappedKeysToKeyIds(layerInfo.WrappedKeys)
-			ids := commands.Uint64ToStringArray("0x%x", keyIds)
-
-			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %s", layerInfo.ID, layerInfo.Platform, strings.Join(ids, ", "))
-		}
-	}
-	return layerSymkeyMap, nil
-}
diff --git a/cmd/ctr/commands/images/encrypt.go b/cmd/ctr/commands/images/encrypt.go
index 69b3b76..8432df8 100644
--- a/cmd/ctr/commands/images/encrypt.go
+++ b/cmd/ctr/commands/images/encrypt.go
@@ -118,7 +118,7 @@ var encryptCommand = cli.Command{
 			if err != nil {
 				return err
 			}
-			layerSymKeyMap, err = getSymmetricKeys(layerInfos, gpgClient)
+			layerSymKeyMap, err = images.GetSymmetricKeys(layerInfos, gpgClient)
 			if err != nil {
 				return err
 			}
diff --git a/cmd/ctr/commands/utils.go b/cmd/ctr/commands/utils.go
index f848522..e25467e 100644
--- a/cmd/ctr/commands/utils.go
+++ b/cmd/ctr/commands/utils.go
@@ -16,10 +16,6 @@
 
 package commands
 
-import (
-	"fmt"
-)
-
 // IntToInt32Array converts an array of int's to int32's
 func IntToInt32Array(in []int) []int32 {
 	var ret []int32
@@ -29,14 +25,3 @@ func IntToInt32Array(in []int) []int32 {
 	}
 	return ret
 }
-
-// Uint64ToStringArray converts an array of uint64's to an array of strings
-// by applying a format string to each uint64
-func Uint64ToStringArray(format string, in []uint64) []string {
-	var ret []string
-
-	for _, v := range in {
-		ret = append(ret, fmt.Sprintf(format, v))
-	}
-	return ret
-}
diff --git a/images/encryption.go b/images/encryption.go
index 06bc310..0c06c9a 100644
--- a/images/encryption.go
+++ b/images/encryption.go
@@ -21,6 +21,7 @@ import (
 	"fmt"
 	"io/ioutil"
 	"net/mail"
+	"os"
 	"strings"
 
 	"github.com/containerd/containerd/errdefs"
@@ -28,6 +29,7 @@ import (
 	"github.com/pkg/errors"
 	"golang.org/x/crypto/openpgp"
 	"golang.org/x/crypto/openpgp/packet"
+	"golang.org/x/crypto/ssh/terminal"
 )
 
 // EncryptConfig is the container image PGP encryption configuration holding
@@ -191,3 +193,82 @@ func Decrypt(dc *DecryptConfig, encBody []byte, desc ocispec.Descriptor, layerNu
 	}
 	return ioutil.ReadAll(md.UnverifiedBody)
 }
+
+// GetSymmetricKeys walks the list of layerInfos and tries to decrypt the
+// wrapped symmetric keys. For this it determines which private keys are on
+// this system and prompts for the passwords for those that are available.
+// If we do not find a private key on the system for getting to the symmetric
+// key of a layer then an error is generated. Otherwise the wrapped symmetric
+// key is decrypted using the private key and added to a map that describes
+// the layer by platform name and layer number as key and the symmetric key
+// data as value
+func GetSymmetricKeys(layerInfos []LayerInfo, gpgClient GPGClient) (map[string]DecryptKeyData, error) {
+	type PrivKeyData struct {
+		KeyData         []byte
+		KeyDataPassword []byte
+	}
+	var pkd PrivKeyData
+	keyIDPasswordMap := make(map[uint64]PrivKeyData)
+	layerSymkeyMap := make(map[string]DecryptKeyData)
+
+	// we need to decrypt one symmetric key per encrypted layer per platform
+	for _, layerInfo := range layerInfos {
+
+		keyIds, err := WrappedKeysToKeyIds(layerInfo.WrappedKeys)
+		if err != nil {
+			return layerSymkeyMap, err
+		}
+
+		found := false
+		for _, keyid := range keyIds {
+			// do we have this key?
+			keyinfo, haveKey, _ := gpgClient.GetSecretKeyDetails(keyid)
+			// this may fail if the key is not here; we ignore the error
+			if !haveKey {
+				// key not on this system
+				continue
+			}
+
+			var ok bool
+			if pkd, ok = keyIDPasswordMap[keyid]; !ok {
+				fmt.Printf("Passphrase required for Key id 0x%x: \n%v", keyid, string(keyinfo))
+				fmt.Printf("Enter passphrase for key with Id 0x%x: ", keyid)
+
+				password, err := terminal.ReadPassword(int(os.Stdin.Fd()))
+				fmt.Printf("\n")
+				if err != nil {
+					return layerSymkeyMap, err
+				}
+				keydata, err := gpgClient.GetGPGPrivateKey(keyid, string(password))
+				if err != nil {
+					return layerSymkeyMap, err
+				}
+				pkd = PrivKeyData{
+					KeyData:         keydata,
+					KeyDataPassword: password,
+				}
+				keyIDPasswordMap[keyid] = pkd
+			}
+
+			symKeyData, symKeyCipher, err := DecryptSymmetricKey(layerInfo.WrappedKeys, keyid, pkd.KeyData, pkd.KeyDataPassword, nil)
+			if err != nil {
+				return layerSymkeyMap, err
+			}
+
+			index := fmt.Sprintf("%s:%d", layerInfo.Platform, layerInfo.ID)
+			layerSymkeyMap[index] = DecryptKeyData{
+				SymKeyData:   symKeyData,
+				SymKeyCipher: uint8(symKeyCipher),
+			}
+			found = true
+			break
+		}
+		if !found && len(layerInfo.WrappedKeys) > 0 {
+			keyIds, _ := WrappedKeysToKeyIds(layerInfo.WrappedKeys)
+			ids := Uint64ToStringArray("0x%x", keyIds)
+
+			return layerSymkeyMap, errors.Wrapf(errdefs.ErrNotFound, "Missing key for decryption of layer %d of %s. Need one of the following keys: %s", layerInfo.ID, layerInfo.Platform, strings.Join(ids, ", "))
+		}
+	}
+	return layerSymkeyMap, nil
+}
diff --git a/images/utils.go b/images/utils.go
new file mode 100644
index 0000000..23dd9a0
--- /dev/null
+++ b/images/utils.go
@@ -0,0 +1,32 @@
+/*
+   Copyright The containerd Authors.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+*/
+
+package images
+
+import (
+	"fmt"
+)
+
+// Uint64ToStringArray converts an array of uint64's to an array of strings
+// by applying a format string to each uint64
+func Uint64ToStringArray(format string, in []uint64) []string {
+	var ret []string
+
+	for _, v := range in {
+		ret = append(ret, fmt.Sprintf(format, v))
+	}
+	return ret
+}
-- 
2.7.4


From 96025190f1b63c5ed182506bc2f3e3c3eba89067 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Tue, 28 Aug 2018 12:09:53 -0400
Subject: [PATCH 77/79] Add decryption of image for 'ctr image pull'

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 client.go                       |  2 +-
 cmd/ctr/commands/images/pull.go | 25 +++++++++++++-
 image.go                        | 18 ++++++----
 images/image.go                 | 73 +++++++++++++++++++++++++++++++++++++++++
 rootfs/apply.go                 |  2 ++
 5 files changed, 112 insertions(+), 8 deletions(-)

diff --git a/client.go b/client.go
index fd20c3d..a027c6a 100644
--- a/client.go
+++ b/client.go
@@ -377,7 +377,7 @@ func (c *Client) Pull(ctx context.Context, ref string, opts ...RemoteOpt) (Image
 		return nil, err
 	}
 
-	i := NewImageWithPlatform(c, img, pullCtx.PlatformMatcher)
+	i := NewImageWithPlatform(c, img, pullCtx.PlatformMatcher, nil)
 
 	if pullCtx.Unpack {
 		if err := i.Unpack(ctx, pullCtx.Snapshotter); err != nil {
diff --git a/cmd/ctr/commands/images/pull.go b/cmd/ctr/commands/images/pull.go
index 3216976..f6da1b1 100644
--- a/cmd/ctr/commands/images/pull.go
+++ b/cmd/ctr/commands/images/pull.go
@@ -53,6 +53,13 @@ command. As part of this process, we do the following:
 			Name:  "all-platforms",
 			Usage: "pull content from all platforms",
 		},
+		cli.StringFlag{
+			Name:  "gpg-homedir",
+			Usage: "The GPG homedir to use; by default gpg uses ~/.gnupg",
+		}, cli.StringFlag{
+			Name:  "gpg-version",
+			Usage: "The GPG version (\"v1\" or \"v2\"), default will make an educated guess",
+		},
 	),
 	Action: func(context *cli.Context) error {
 		var (
@@ -106,9 +113,25 @@ command. As part of this process, we do the following:
 			p = append(p, platforms.DefaultSpec())
 		}
 
+		// Create gpg client
+		gpgVersion := context.String("gpg-version")
+		v := new(images.GPGVersion)
+		switch gpgVersion {
+		case "v1":
+			*v = images.GPGv1
+		case "v2":
+			*v = images.GPGv2
+		default:
+			v = nil
+		}
+		gpgClient, err := images.NewGPGClient(v, context.String("gpg-homedir"))
+		if err != nil {
+			return errors.New("Unable to create GPG Client")
+		}
+
 		for _, platform := range p {
 			fmt.Printf("unpacking %s %s...\n", platforms.Format(platform), img.Target.Digest)
-			i := containerd.NewImageWithPlatform(client, img, platforms.Only(platform))
+			i := containerd.NewImageWithPlatform(client, img, platforms.Only(platform), gpgClient)
 			err = i.Unpack(ctx, context.String("snapshotter"))
 			if err != nil {
 				return err
diff --git a/image.go b/image.go
index f12cd59..bd1a9b8 100644
--- a/image.go
+++ b/image.go
@@ -63,19 +63,21 @@ func NewImage(client *Client, i images.Image) Image {
 }
 
 // NewImageWithPlatform returns a client image object from the metadata image
-func NewImageWithPlatform(client *Client, i images.Image, platform platforms.MatchComparer) Image {
+func NewImageWithPlatform(client *Client, i images.Image, platform platforms.MatchComparer, gpgClient images.GPGClient) Image {
 	return &image{
-		client:   client,
-		i:        i,
-		platform: platform,
+		client:    client,
+		i:         i,
+		platform:  platform,
+		gpgClient: gpgClient,
 	}
 }
 
 type image struct {
 	client *Client
 
-	i        images.Image
-	platform platforms.MatchComparer
+	i         images.Image
+	platform  platforms.MatchComparer
+	gpgClient images.GPGClient
 }
 
 func (i *image) Name() string {
@@ -132,6 +134,10 @@ func (i *image) Unpack(ctx context.Context, snapshotterName string) error {
 	if err != nil {
 		return err
 	}
+	layers, err = images.DecryptLayers(ctx, i.ContentStore(), layers, i.gpgClient)
+	if err != nil {
+		return err
+	}
 
 	var (
 		sn = i.client.SnapshotService(snapshotterName)
diff --git a/images/image.go b/images/image.go
index 0ce8e59..8ead893 100644
--- a/images/image.go
+++ b/images/image.go
@@ -30,6 +30,7 @@ import (
 	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/platforms"
+	"github.com/containerd/containerd/rootfs"
 	digest "github.com/opencontainers/go-digest"
 	specs "github.com/opencontainers/image-spec/specs-go"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
@@ -915,3 +916,75 @@ func getImageLayerInfo(ctx context.Context, cs content.Store, desc ocispec.Descr
 
 	return lis, nil
 }
+
+// DecryptLayers decrypts the given array of rootfs.Layer and returns a an array of
+// rootfs.Layer with the OCI descriptors adapted to point to the decrypted layers.
+// This function will determine the necessary key(s) to decrypt the image and search
+// for them using the gpg client
+func DecryptLayers(ctx context.Context, cs content.Store, layers []rootfs.Layer, gpgClient GPGClient) ([]rootfs.Layer, error) {
+	var (
+		newLayers      []rootfs.Layer
+		layerInfos     []LayerInfo
+		layerSymKeyMap map[string]DecryptKeyData
+		err            error
+	)
+
+	// in the 1st pass through the layers we gather required keys
+	isEncrypted := false
+	for id, layer := range layers {
+		layerInfo := LayerInfo{
+			ID:       uint32(id),
+			Digest:   layer.Blob.Digest.String(),
+			Platform: platforms.DefaultString(),
+		}
+		switch layer.Blob.MediaType {
+		case MediaTypeDockerSchema2LayerPGP, MediaTypeDockerSchema2LayerGzipPGP:
+			isEncrypted = true
+			layerInfo.Encryption = "pgp"
+
+			layerInfo.WrappedKeys, err = getWrappedKeys(layer.Blob)
+			if err != nil {
+				return []rootfs.Layer{}, err
+			}
+		}
+		layerInfos = append(layerInfos, layerInfo)
+	}
+
+	if !isEncrypted {
+		// nothing to do here
+		return layers, nil
+	}
+
+	if gpgClient == nil {
+		// in K8s case we may get the private key(s) and password(s) via ctx
+		return []rootfs.Layer{}, errors.Wrapf(errdefs.ErrNotImplemented, "Need a gpgClient to decrypt the image\n")
+	}
+
+	// in ctr case we may just want to consult gpg/gpg2 for the key(s)
+	layerSymKeyMap, err = GetSymmetricKeys(layerInfos, gpgClient)
+	if err != nil {
+		return []rootfs.Layer{}, err
+	}
+	cc := &CryptoConfig{
+		Dc: &DecryptConfig{
+			LayerSymKeyMap: layerSymKeyMap,
+		},
+	}
+	thisPlatform := platforms.DefaultSpec()
+
+	// in the 2nd pass we decrypt the layers
+	for i, layer := range layers {
+		if layerInfos[i].Encryption != "" {
+			// need to decrypt this layer
+			newDesc, err := cryptLayer(ctx, cs, layer.Blob, cc, int32(i), &thisPlatform, false)
+			if err != nil {
+				return []rootfs.Layer{}, err
+			}
+			fmt.Printf("encrypt:%s -> decrypted:%s\n", layer.Blob.Digest, newDesc.Digest)
+			layer.Blob = newDesc
+		}
+		newLayers = append(newLayers, layer)
+	}
+
+	return newLayers, nil
+}
diff --git a/rootfs/apply.go b/rootfs/apply.go
index 3ea830f..fc0bb39 100644
--- a/rootfs/apply.go
+++ b/rootfs/apply.go
@@ -144,6 +144,8 @@ func applyLayers(ctx context.Context, layers []Layer, chain []digest.Digest, sn
 		}
 	}()
 
+	fmt.Printf("rootfs/apply.go::applyLayers(): layer.Blob.MediaType = %s\n", layer.Blob.MediaType)
+	fmt.Printf("rootfs/apply.go::applyLayers(): layer.Blob.Digest = %s\n", layer.Blob.Digest)
 	diff, err = a.Apply(ctx, layer.Blob, mounts)
 	if err != nil {
 		err = errors.Wrapf(err, "failed to extract layer %s", layer.Diff.Digest)
-- 
2.7.4


From cec1d3ab480965be8952f28c45d8720db53aedfc Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 29 Aug 2018 15:36:18 -0400
Subject: [PATCH 78/79] Use decrypted private key to decrypt symmetric key
 right away

Do not decrypt all private keys first and then try one after the
other but try to use the private key right away.

Signed-off-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
---
 images/openpgp.go | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 4aa91a9..9bc0f52 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -315,16 +315,13 @@ ParsePackets:
 	}
 	// decrypt them
 	decKeys := entityList.KeysByIdUsage(ek.KeyId, packet.KeyFlagEncryptCommunications)
+	decrypted := false
 	for _, k := range decKeys {
 		if k.PrivateKey.Encrypted {
 			if err := k.PrivateKey.Decrypt(keyDataPassword); err != nil {
 				return []byte{}, 0, errors.Wrapf(err, "passphrase invalid for private key")
 			}
 		}
-	}
-	decrypted := false
-
-	for _, k := range decKeys {
 		err = ek.Decrypt(k.PrivateKey, config)
 		if err == nil {
 			decrypted = true
-- 
2.7.4


From cd93e280ef2fc6679dd80694818e908fa09b5ef5 Mon Sep 17 00:00:00 2001
From: Stefan Berger <stefanb@linux.vnet.ibm.com>
Date: Wed, 29 Aug 2018 15:40:36 -0400
Subject: [PATCH 79/79] Fix documentation of DecryptSymmetricKey function

---
 images/openpgp.go | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/images/openpgp.go b/images/openpgp.go
index 9bc0f52..c08e0b9 100644
--- a/images/openpgp.go
+++ b/images/openpgp.go
@@ -272,9 +272,10 @@ ParsePackets:
 	return keyids, nil
 }
 
-// DecryptSymmetricKey decrypts a symmetric key from an array of wrapped keys. The public
-// key with the given keyid is attempted to be decrypted using the private key given
-// by keyData and keyDataPassword
+// DecryptSymmetricKey decrypts a symmetric key from an array of wrapped keys. The private
+// key with the given keyid is retrieved from the keyData byte array and decrypted using
+// the given keyDataPassword; the private key is then used to decrypt the wrapped symmetric
+// key
 func DecryptSymmetricKey(keys [][]byte, keyid uint64, keyData []byte, keyDataPassword []byte, config *packet.Config) ([]byte, packet.CipherFunction, error) {
 	kbytes := make([]byte, 0)
 	for _, k := range keys {
-- 
2.7.4

